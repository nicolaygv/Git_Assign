/*!
 * @preserve
 * espn-web-player-bundle v3.3.40
 * 2021-08-26T19:55:29.765Z
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.DTCIVideoPlayer = factory());
}(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var check = function (it) {
	  return it && it.Math == Math && it;
	};

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global_1 =
	  // eslint-disable-next-line es/no-global-this -- safe
	  check(typeof globalThis == 'object' && globalThis) ||
	  check(typeof window == 'object' && window) ||
	  // eslint-disable-next-line no-restricted-globals -- safe
	  check(typeof self == 'object' && self) ||
	  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
	  // eslint-disable-next-line no-new-func -- fallback
	  (function () { return this; })() || Function('return this')();

	var fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	// Detect IE8's incomplete defineProperty implementation
	var descriptors = !fails(function () {
	  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
	  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
	});

	var $propertyIsEnumerable = {}.propertyIsEnumerable;
	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	var getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;

	// Nashorn ~ JDK8 bug
	var NASHORN_BUG = getOwnPropertyDescriptor$2 && !$propertyIsEnumerable.call({ 1: 2 }, 1);

	// `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
	var f$3 = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor$2(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : $propertyIsEnumerable;

	var objectPropertyIsEnumerable = {
		f: f$3
	};

	var createPropertyDescriptor = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var toString$1 = {}.toString;

	var classofRaw = function (it) {
	  return toString$1.call(it).slice(8, -1);
	};

	var split = ''.split;

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var indexedObject = fails(function () {
	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
	  // eslint-disable-next-line no-prototype-builtins -- safe
	  return !Object('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
	} : Object;

	// `RequireObjectCoercible` abstract operation
	// https://tc39.es/ecma262/#sec-requireobjectcoercible
	var requireObjectCoercible = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on " + it);
	  return it;
	};

	// toObject with fallback for non-array-like ES3 strings



	var toIndexedObject = function (it) {
	  return indexedObject(requireObjectCoercible(it));
	};

	var isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	// `ToPrimitive` abstract operation
	// https://tc39.es/ecma262/#sec-toprimitive
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var toPrimitive = function (input, PREFERRED_STRING) {
	  if (!isObject(input)) return input;
	  var fn, val;
	  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
	  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
	  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	// `ToObject` abstract operation
	// https://tc39.es/ecma262/#sec-toobject
	var toObject = function (argument) {
	  return Object(requireObjectCoercible(argument));
	};

	var hasOwnProperty$1 = {}.hasOwnProperty;

	var has$1 = Object.hasOwn || function hasOwn(it, key) {
	  return hasOwnProperty$1.call(toObject(it), key);
	};

	var document$3 = global_1.document;
	// typeof document.createElement is 'object' in old IE
	var EXISTS = isObject(document$3) && isObject(document$3.createElement);

	var documentCreateElement = function (it) {
	  return EXISTS ? document$3.createElement(it) : {};
	};

	// Thank's IE8 for his funny defineProperty
	var ie8DomDefine = !descriptors && !fails(function () {
	  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
	  return Object.defineProperty(documentCreateElement('div'), 'a', {
	    get: function () { return 7; }
	  }).a != 7;
	});

	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
	var f$2 = descriptors ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject(O);
	  P = toPrimitive(P, true);
	  if (ie8DomDefine) try {
	    return $getOwnPropertyDescriptor(O, P);
	  } catch (error) { /* empty */ }
	  if (has$1(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
	};

	var objectGetOwnPropertyDescriptor = {
		f: f$2
	};

	var replacement = /#|\.prototype\./;

	var isForced = function (feature, detection) {
	  var value = data[normalize(feature)];
	  return value == POLYFILL ? true
	    : value == NATIVE ? false
	    : typeof detection == 'function' ? fails(detection)
	    : !!detection;
	};

	var normalize = isForced.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};

	var data = isForced.data = {};
	var NATIVE = isForced.NATIVE = 'N';
	var POLYFILL = isForced.POLYFILL = 'P';

	var isForced_1 = isForced;

	var path = {};

	var aFunction$1 = function (it) {
	  if (typeof it != 'function') {
	    throw TypeError(String(it) + ' is not a function');
	  } return it;
	};

	// optional / simple context binding
	var functionBindContext = function (fn, that, length) {
	  aFunction$1(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 0: return function () {
	      return fn.call(that);
	    };
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var anObject = function (it) {
	  if (!isObject(it)) {
	    throw TypeError(String(it) + ' is not an object');
	  } return it;
	};

	// eslint-disable-next-line es/no-object-defineproperty -- safe
	var $defineProperty = Object.defineProperty;

	// `Object.defineProperty` method
	// https://tc39.es/ecma262/#sec-object.defineproperty
	var f$1 = descriptors ? $defineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (ie8DomDefine) try {
	    return $defineProperty(O, P, Attributes);
	  } catch (error) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var objectDefineProperty = {
		f: f$1
	};

	var createNonEnumerableProperty = descriptors ? function (object, key, value) {
	  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






	var wrapConstructor = function (NativeConstructor) {
	  var Wrapper = function (a, b, c) {
	    if (this instanceof NativeConstructor) {
	      switch (arguments.length) {
	        case 0: return new NativeConstructor();
	        case 1: return new NativeConstructor(a);
	        case 2: return new NativeConstructor(a, b);
	      } return new NativeConstructor(a, b, c);
	    } return NativeConstructor.apply(this, arguments);
	  };
	  Wrapper.prototype = NativeConstructor.prototype;
	  return Wrapper;
	};

	/*
	  options.target      - name of the target object
	  options.global      - target is the global object
	  options.stat        - export as static methods of target
	  options.proto       - export as prototype methods of target
	  options.real        - real prototype method for the `pure` version
	  options.forced      - export even if the native feature is available
	  options.bind        - bind methods to the target, required for the `pure` version
	  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
	  options.sham        - add a flag to not completely full polyfills
	  options.enumerable  - export as enumerable property
	  options.noTargetGet - prevent calling a getter on target
	*/
	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var PROTO = options.proto;

	  var nativeSource = GLOBAL ? global_1 : STATIC ? global_1[TARGET] : (global_1[TARGET] || {}).prototype;

	  var target = GLOBAL ? path : path[TARGET] || (path[TARGET] = {});
	  var targetPrototype = target.prototype;

	  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
	  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

	  for (key in source) {
	    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
	    // contains in native
	    USE_NATIVE = !FORCED && nativeSource && has$1(nativeSource, key);

	    targetProperty = target[key];

	    if (USE_NATIVE) if (options.noTargetGet) {
	      descriptor = getOwnPropertyDescriptor$1(nativeSource, key);
	      nativeProperty = descriptor && descriptor.value;
	    } else nativeProperty = nativeSource[key];

	    // export native or implementation
	    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];

	    if (USE_NATIVE && typeof targetProperty === typeof sourceProperty) continue;

	    // bind timers to global for call from export context
	    if (options.bind && USE_NATIVE) resultProperty = functionBindContext(sourceProperty, global_1);
	    // wrap global constructors for prevent changs in this version
	    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
	    // make static versions for prototype methods
	    else if (PROTO && typeof sourceProperty == 'function') resultProperty = functionBindContext(Function.call, sourceProperty);
	    // default case
	    else resultProperty = sourceProperty;

	    // add a flag to not completely full polyfills
	    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {
	      createNonEnumerableProperty(resultProperty, 'sham', true);
	    }

	    target[key] = resultProperty;

	    if (PROTO) {
	      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';
	      if (!has$1(path, VIRTUAL_PROTOTYPE)) {
	        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
	      }
	      // export virtual prototype methods
	      path[VIRTUAL_PROTOTYPE][key] = sourceProperty;
	      // export real prototype methods
	      if (options.real && targetPrototype && !targetPrototype[key]) {
	        createNonEnumerableProperty(targetPrototype, key, sourceProperty);
	      }
	    }
	  }
	};

	var isPure = true;

	var setGlobal = function (key, value) {
	  try {
	    createNonEnumerableProperty(global_1, key, value);
	  } catch (error) {
	    global_1[key] = value;
	  } return value;
	};

	var SHARED = '__core-js_shared__';
	var store$1 = global_1[SHARED] || setGlobal(SHARED, {});

	var sharedStore = store$1;

	var shared = createCommonjsModule(function (module) {
	(module.exports = function (key, value) {
	  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: '3.13.1',
	  mode: 'pure' ,
	  copyright: '© 2021 Denis Pushkarev (zloirock.ru)'
	});
	});

	var id = 0;
	var postfix = Math.random();

	var uid = function (key) {
	  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
	};

	var keys$3 = shared('keys');

	var sharedKey = function (key) {
	  return keys$3[key] || (keys$3[key] = uid(key));
	};

	var correctPrototypeGetter = !fails(function () {
	  function F() { /* empty */ }
	  F.prototype.constructor = null;
	  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var IE_PROTO$1 = sharedKey('IE_PROTO');
	var ObjectPrototype = Object.prototype;

	// `Object.getPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.getprototypeof
	// eslint-disable-next-line es/no-object-getprototypeof -- safe
	var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
	  O = toObject(O);
	  if (has$1(O, IE_PROTO$1)) return O[IE_PROTO$1];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectPrototype : null;
	};

	var aPossiblePrototype = function (it) {
	  if (!isObject(it) && it !== null) {
	    throw TypeError("Can't set " + String(it) + ' as a prototype');
	  } return it;
	};

	/* eslint-disable no-proto -- safe */



	// `Object.setPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.setprototypeof
	// Works with __proto__ only. Old v8 can't work with null proto objects.
	// eslint-disable-next-line es/no-object-setprototypeof -- safe
	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
	  var CORRECT_SETTER = false;
	  var test = {};
	  var setter;
	  try {
	    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
	    setter.call(test, []);
	    CORRECT_SETTER = test instanceof Array;
	  } catch (error) { /* empty */ }
	  return function setPrototypeOf(O, proto) {
	    anObject(O);
	    aPossiblePrototype(proto);
	    if (CORRECT_SETTER) setter.call(O, proto);
	    else O.__proto__ = proto;
	    return O;
	  };
	}() : undefined);

	var ceil = Math.ceil;
	var floor = Math.floor;

	// `ToInteger` abstract operation
	// https://tc39.es/ecma262/#sec-tointeger
	var toInteger = function (argument) {
	  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
	};

	var min$2 = Math.min;

	// `ToLength` abstract operation
	// https://tc39.es/ecma262/#sec-tolength
	var toLength = function (argument) {
	  return argument > 0 ? min$2(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
	};

	var max$2 = Math.max;
	var min$1 = Math.min;

	// Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
	var toAbsoluteIndex = function (index, length) {
	  var integer = toInteger(index);
	  return integer < 0 ? max$2(integer + length, 0) : min$1(integer, length);
	};

	// `Array.prototype.{ indexOf, includes }` methods implementation
	var createMethod$4 = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare -- NaN check
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare -- NaN check
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var arrayIncludes = {
	  // `Array.prototype.includes` method
	  // https://tc39.es/ecma262/#sec-array.prototype.includes
	  includes: createMethod$4(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.es/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod$4(false)
	};

	var hiddenKeys = {};

	var indexOf$3 = arrayIncludes.indexOf;


	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) !has$1(hiddenKeys, key) && has$1(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (has$1(O, key = names[i++])) {
	    ~indexOf$3(result, key) || result.push(key);
	  }
	  return result;
	};

	// IE8- don't enum bug keys
	var enumBugKeys = [
	  'constructor',
	  'hasOwnProperty',
	  'isPrototypeOf',
	  'propertyIsEnumerable',
	  'toLocaleString',
	  'toString',
	  'valueOf'
	];

	// `Object.keys` method
	// https://tc39.es/ecma262/#sec-object.keys
	// eslint-disable-next-line es/no-object-keys -- safe
	var objectKeys = Object.keys || function keys(O) {
	  return objectKeysInternal(O, enumBugKeys);
	};

	// `Object.defineProperties` method
	// https://tc39.es/ecma262/#sec-object.defineproperties
	// eslint-disable-next-line es/no-object-defineproperties -- safe
	var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;
	  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
	  return O;
	};

	var aFunction = function (variable) {
	  return typeof variable == 'function' ? variable : undefined;
	};

	var getBuiltIn = function (namespace, method) {
	  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace])
	    : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
	};

	var html = getBuiltIn('document', 'documentElement');

	var GT = '>';
	var LT = '<';
	var PROTOTYPE = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO = sharedKey('IE_PROTO');

	var EmptyConstructor = function () { /* empty */ };

	var scriptTag = function (content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	};

	// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
	var NullProtoObjectViaActiveX = function (activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null; // avoid memory leak
	  return temp;
	};

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var NullProtoObjectViaIFrame = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  // https://github.com/zloirock/core-js/issues/475
	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	};

	// Check for document.domain and active x support
	// No need to use active x approach when document.domain is not set
	// see https://github.com/es-shims/es5-shim/issues/150
	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	// avoid IE GC bug
	var activeXDocument;
	var NullProtoObject = function () {
	  try {
	    /* global ActiveXObject -- old IE */
	    activeXDocument = document.domain && new ActiveXObject('htmlfile');
	  } catch (error) { /* ignore */ }
	  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
	  var length = enumBugKeys.length;
	  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
	  return NullProtoObject();
	};

	hiddenKeys[IE_PROTO] = true;

	// `Object.create` method
	// https://tc39.es/ecma262/#sec-object.create
	var objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE] = anObject(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = NullProtoObject();
	  return Properties === undefined ? result : objectDefineProperties(result, Properties);
	};

	var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

	var process$3 = global_1.process;
	var versions = process$3 && process$3.versions;
	var v8 = versions && versions.v8;
	var match, version;

	if (v8) {
	  match = v8.split('.');
	  version = match[0] < 4 ? 1 : match[0] + match[1];
	} else if (engineUserAgent) {
	  match = engineUserAgent.match(/Edge\/(\d+)/);
	  if (!match || match[1] >= 74) {
	    match = engineUserAgent.match(/Chrome\/(\d+)/);
	    if (match) version = match[1];
	  }
	}

	var engineV8Version = version && +version;

	/* eslint-disable es/no-symbol -- required for testing */



	// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
	var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
	  var symbol = Symbol();
	  // Chrome 38 Symbol has incorrect toString conversion
	  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
	  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
	    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
	    !Symbol.sham && engineV8Version && engineV8Version < 41;
	});

	/* eslint-disable es/no-symbol -- required for testing */


	var useSymbolAsUid = nativeSymbol
	  && !Symbol.sham
	  && typeof Symbol.iterator == 'symbol';

	var WellKnownSymbolsStore = shared('wks');
	var Symbol$2 = global_1.Symbol;
	var createWellKnownSymbol = useSymbolAsUid ? Symbol$2 : Symbol$2 && Symbol$2.withoutSetter || uid;

	var wellKnownSymbol = function (name) {
	  if (!has$1(WellKnownSymbolsStore, name) || !(nativeSymbol || typeof WellKnownSymbolsStore[name] == 'string')) {
	    if (nativeSymbol && has$1(Symbol$2, name)) {
	      WellKnownSymbolsStore[name] = Symbol$2[name];
	    } else {
	      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
	    }
	  } return WellKnownSymbolsStore[name];
	};

	var iterators = {};

	var ITERATOR$4 = wellKnownSymbol('iterator');
	var ArrayPrototype$8 = Array.prototype;

	// check on default Array iterator
	var isArrayIteratorMethod = function (it) {
	  return it !== undefined && (iterators.Array === it || ArrayPrototype$8[ITERATOR$4] === it);
	};

	var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
	var test$1 = {};

	test$1[TO_STRING_TAG$3] = 'z';

	var toStringTagSupport = String(test$1) === '[object z]';

	var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
	// ES3 wrong here
	var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (error) { /* empty */ }
	};

	// getting tag from ES6+ `Object.prototype.toString`
	var classof = toStringTagSupport ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == 'string' ? tag
	    // builtinTag case
	    : CORRECT_ARGUMENTS ? classofRaw(O)
	    // ES3 arguments fallback
	    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
	};

	var ITERATOR$3 = wellKnownSymbol('iterator');

	var getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$3]
	    || it['@@iterator']
	    || iterators[classof(it)];
	};

	var iteratorClose = function (iterator) {
	  var returnMethod = iterator['return'];
	  if (returnMethod !== undefined) {
	    return anObject(returnMethod.call(iterator)).value;
	  }
	};

	var Result = function (stopped, result) {
	  this.stopped = stopped;
	  this.result = result;
	};

	var iterate = function (iterable, unboundFunction, options) {
	  var that = options && options.that;
	  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
	  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
	  var INTERRUPTED = !!(options && options.INTERRUPTED);
	  var fn = functionBindContext(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
	  var iterator, iterFn, index, length, result, next, step;

	  var stop = function (condition) {
	    if (iterator) iteratorClose(iterator);
	    return new Result(true, condition);
	  };

	  var callFn = function (value) {
	    if (AS_ENTRIES) {
	      anObject(value);
	      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
	    } return INTERRUPTED ? fn(value, stop) : fn(value);
	  };

	  if (IS_ITERATOR) {
	    iterator = iterable;
	  } else {
	    iterFn = getIteratorMethod(iterable);
	    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
	    // optimisation for array iterators
	    if (isArrayIteratorMethod(iterFn)) {
	      for (index = 0, length = toLength(iterable.length); length > index; index++) {
	        result = callFn(iterable[index]);
	        if (result && result instanceof Result) return result;
	      } return new Result(false);
	    }
	    iterator = iterFn.call(iterable);
	  }

	  next = iterator.next;
	  while (!(step = next.call(iterator)).done) {
	    try {
	      result = callFn(step.value);
	    } catch (error) {
	      iteratorClose(iterator);
	      throw error;
	    }
	    if (typeof result == 'object' && result && result instanceof Result) return result;
	  } return new Result(false);
	};

	var $AggregateError = function AggregateError(errors, message) {
	  var that = this;
	  if (!(that instanceof $AggregateError)) return new $AggregateError(errors, message);
	  if (objectSetPrototypeOf) {
	    // eslint-disable-next-line unicorn/error-message -- expected
	    that = objectSetPrototypeOf(new Error(undefined), objectGetPrototypeOf(that));
	  }
	  if (message !== undefined) createNonEnumerableProperty(that, 'message', String(message));
	  var errorsArray = [];
	  iterate(errors, errorsArray.push, { that: errorsArray });
	  createNonEnumerableProperty(that, 'errors', errorsArray);
	  return that;
	};

	$AggregateError.prototype = objectCreate(Error.prototype, {
	  constructor: createPropertyDescriptor(5, $AggregateError),
	  message: createPropertyDescriptor(5, ''),
	  name: createPropertyDescriptor(5, 'AggregateError')
	});

	// `AggregateError` constructor
	// https://tc39.es/ecma262/#sec-aggregate-error-constructor
	_export({ global: true }, {
	  AggregateError: $AggregateError
	});

	var nativePromiseConstructor = global_1.Promise;

	var redefine = function (target, key, value, options) {
	  if (options && options.enumerable) target[key] = value;
	  else createNonEnumerableProperty(target, key, value);
	};

	var redefineAll = function (target, src, options) {
	  for (var key in src) {
	    if (options && options.unsafe && target[key]) target[key] = src[key];
	    else redefine(target, key, src[key], options);
	  } return target;
	};

	// `Object.prototype.toString` method implementation
	// https://tc39.es/ecma262/#sec-object.prototype.tostring
	var objectToString$1 = toStringTagSupport ? {}.toString : function toString() {
	  return '[object ' + classof(this) + ']';
	};

	var defineProperty = objectDefineProperty.f;





	var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');

	var setToStringTag = function (it, TAG, STATIC, SET_METHOD) {
	  if (it) {
	    var target = STATIC ? it : it.prototype;
	    if (!has$1(target, TO_STRING_TAG$1)) {
	      defineProperty(target, TO_STRING_TAG$1, { configurable: true, value: TAG });
	    }
	    if (SET_METHOD && !toStringTagSupport) {
	      createNonEnumerableProperty(target, 'toString', objectToString$1);
	    }
	  }
	};

	var SPECIES$5 = wellKnownSymbol('species');

	var setSpecies = function (CONSTRUCTOR_NAME) {
	  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
	  var defineProperty = objectDefineProperty.f;

	  if (descriptors && Constructor && !Constructor[SPECIES$5]) {
	    defineProperty(Constructor, SPECIES$5, {
	      configurable: true,
	      get: function () { return this; }
	    });
	  }
	};

	var anInstance = function (it, Constructor, name) {
	  if (!(it instanceof Constructor)) {
	    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
	  } return it;
	};

	var functionToString = Function.toString;

	// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
	if (typeof sharedStore.inspectSource != 'function') {
	  sharedStore.inspectSource = function (it) {
	    return functionToString.call(it);
	  };
	}

	var inspectSource = sharedStore.inspectSource;

	var ITERATOR$2 = wellKnownSymbol('iterator');
	var SAFE_CLOSING = false;

	try {
	  var called = 0;
	  var iteratorWithReturn = {
	    next: function () {
	      return { done: !!called++ };
	    },
	    'return': function () {
	      SAFE_CLOSING = true;
	    }
	  };
	  iteratorWithReturn[ITERATOR$2] = function () {
	    return this;
	  };
	  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
	  Array.from(iteratorWithReturn, function () { throw 2; });
	} catch (error) { /* empty */ }

	var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
	  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
	  var ITERATION_SUPPORT = false;
	  try {
	    var object = {};
	    object[ITERATOR$2] = function () {
	      return {
	        next: function () {
	          return { done: ITERATION_SUPPORT = true };
	        }
	      };
	    };
	    exec(object);
	  } catch (error) { /* empty */ }
	  return ITERATION_SUPPORT;
	};

	var SPECIES$4 = wellKnownSymbol('species');

	// `SpeciesConstructor` abstract operation
	// https://tc39.es/ecma262/#sec-speciesconstructor
	var speciesConstructor = function (O, defaultConstructor) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES$4]) == undefined ? defaultConstructor : aFunction$1(S);
	};

	var engineIsIos = /(?:iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent);

	var engineIsNode = classofRaw(global_1.process) == 'process';

	var location = global_1.location;
	var set$1 = global_1.setImmediate;
	var clear = global_1.clearImmediate;
	var process$2 = global_1.process;
	var MessageChannel = global_1.MessageChannel;
	var Dispatch = global_1.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;

	var run = function (id) {
	  // eslint-disable-next-line no-prototype-builtins -- safe
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};

	var runner = function (id) {
	  return function () {
	    run(id);
	  };
	};

	var listener = function (event) {
	  run(event.data);
	};

	var post = function (id) {
	  // old engines have not location.origin
	  global_1.postMessage(id + '', location.protocol + '//' + location.host);
	};

	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!set$1 || !clear) {
	  set$1 = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func -- spec requirement
	      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clear = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (engineIsNode) {
	    defer = function (id) {
	      process$2.nextTick(runner(id));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(runner(id));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  // except iOS - https://github.com/zloirock/core-js/issues/624
	  } else if (MessageChannel && !engineIsIos) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = functionBindContext(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (
	    global_1.addEventListener &&
	    typeof postMessage == 'function' &&
	    !global_1.importScripts &&
	    location && location.protocol !== 'file:' &&
	    !fails(post)
	  ) {
	    defer = post;
	    global_1.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
	    defer = function (id) {
	      html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(runner(id), 0);
	    };
	  }
	}

	var task$1 = {
	  set: set$1,
	  clear: clear
	};

	var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(engineUserAgent);

	var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	var macrotask = task$1.set;




	var MutationObserver = global_1.MutationObserver || global_1.WebKitMutationObserver;
	var document$2 = global_1.document;
	var process$1 = global_1.process;
	var Promise$1 = global_1.Promise;
	// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
	var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global_1, 'queueMicrotask');
	var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

	var flush, head, last, notify$1, toggle, node, promise$3, then;

	// modern engines have queueMicrotask method
	if (!queueMicrotask) {
	  flush = function () {
	    var parent, fn;
	    if (engineIsNode && (parent = process$1.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (error) {
	        if (head) notify$1();
	        else last = undefined;
	        throw error;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };

	  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
	  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
	  if (!engineIsIos && !engineIsNode && !engineIsWebosWebkit && MutationObserver && document$2) {
	    toggle = true;
	    node = document$2.createTextNode('');
	    new MutationObserver(flush).observe(node, { characterData: true });
	    notify$1 = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise$1 && Promise$1.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    promise$3 = Promise$1.resolve(undefined);
	    // workaround of WebKit ~ iOS Safari 10.1 bug
	    promise$3.constructor = Promise$1;
	    then = promise$3.then;
	    notify$1 = function () {
	      then.call(promise$3, flush);
	    };
	  // Node.js without promises
	  } else if (engineIsNode) {
	    notify$1 = function () {
	      process$1.nextTick(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify$1 = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global_1, flush);
	    };
	  }
	}

	var microtask = queueMicrotask || function (fn) {
	  var task = { fn: fn, next: undefined };
	  if (last) last.next = task;
	  if (!head) {
	    head = task;
	    notify$1();
	  } last = task;
	};

	var PromiseCapability = function (C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction$1(resolve);
	  this.reject = aFunction$1(reject);
	};

	// `NewPromiseCapability` abstract operation
	// https://tc39.es/ecma262/#sec-newpromisecapability
	var f = function (C) {
	  return new PromiseCapability(C);
	};

	var newPromiseCapability$1 = {
		f: f
	};

	var promiseResolve = function (C, x) {
	  anObject(C);
	  if (isObject(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability$1.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var hostReportErrors = function (a, b) {
	  var console = global_1.console;
	  if (console && console.error) {
	    arguments.length === 1 ? console.error(a) : console.error(a, b);
	  }
	};

	var perform = function (exec) {
	  try {
	    return { error: false, value: exec() };
	  } catch (error) {
	    return { error: true, value: error };
	  }
	};

	var WeakMap$1 = global_1.WeakMap;

	var nativeWeakMap = typeof WeakMap$1 === 'function' && /native code/.test(inspectSource(WeakMap$1));

	var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
	var WeakMap = global_1.WeakMap;
	var set, get, has;

	var enforce = function (it) {
	  return has(it) ? get(it) : set(it, {});
	};

	var getterFor = function (TYPE) {
	  return function (it) {
	    var state;
	    if (!isObject(it) || (state = get(it)).type !== TYPE) {
	      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
	    } return state;
	  };
	};

	if (nativeWeakMap || sharedStore.state) {
	  var store = sharedStore.state || (sharedStore.state = new WeakMap());
	  var wmget = store.get;
	  var wmhas = store.has;
	  var wmset = store.set;
	  set = function (it, metadata) {
	    if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
	    metadata.facade = it;
	    wmset.call(store, it, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return wmget.call(store, it) || {};
	  };
	  has = function (it) {
	    return wmhas.call(store, it);
	  };
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys[STATE] = true;
	  set = function (it, metadata) {
	    if (has$1(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
	    metadata.facade = it;
	    createNonEnumerableProperty(it, STATE, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return has$1(it, STATE) ? it[STATE] : {};
	  };
	  has = function (it) {
	    return has$1(it, STATE);
	  };
	}

	var internalState = {
	  set: set,
	  get: get,
	  has: has,
	  enforce: enforce,
	  getterFor: getterFor
	};

	var engineIsBrowser = typeof window == 'object';

	var task = task$1.set;












	var SPECIES$3 = wellKnownSymbol('species');
	var PROMISE = 'Promise';
	var getInternalState$2 = internalState.get;
	var setInternalState$2 = internalState.set;
	var getInternalPromiseState = internalState.getterFor(PROMISE);
	var NativePromisePrototype = nativePromiseConstructor && nativePromiseConstructor.prototype;
	var PromiseConstructor = nativePromiseConstructor;
	var PromiseConstructorPrototype = NativePromisePrototype;
	var TypeError$1 = global_1.TypeError;
	var document$1 = global_1.document;
	var process = global_1.process;
	var newPromiseCapability = newPromiseCapability$1.f;
	var newGenericPromiseCapability = newPromiseCapability;
	var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global_1.dispatchEvent);
	var NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == 'function';
	var UNHANDLED_REJECTION = 'unhandledrejection';
	var REJECTION_HANDLED = 'rejectionhandled';
	var PENDING = 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	var HANDLED = 1;
	var UNHANDLED = 2;
	var SUBCLASSING = false;
	var Internal, OwnPromiseCapability, PromiseWrapper;

	var FORCED$5 = isForced_1(PROMISE, function () {
	  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
	  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	  // We can't detect it synchronously, so just check versions
	  if (!GLOBAL_CORE_JS_PROMISE && engineV8Version === 66) return true;
	  // We need Promise#finally in the pure version for preventing prototype pollution
	  if (!PromiseConstructorPrototype['finally']) return true;
	  // We can't use @@species feature detection in V8 since it causes
	  // deoptimization and performance degradation
	  // https://github.com/zloirock/core-js/issues/679
	  if (engineV8Version >= 51 && /native code/.test(PromiseConstructor)) return false;
	  // Detect correctness of subclassing with @@species support
	  var promise = new PromiseConstructor(function (resolve) { resolve(1); });
	  var FakePromise = function (exec) {
	    exec(function () { /* empty */ }, function () { /* empty */ });
	  };
	  var constructor = promise.constructor = {};
	  constructor[SPECIES$3] = FakePromise;
	  SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
	  if (!SUBCLASSING) return true;
	  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	  return !GLOBAL_CORE_JS_PROMISE && engineIsBrowser && !NATIVE_REJECTION_EVENT;
	});

	var INCORRECT_ITERATION = FORCED$5 || !checkCorrectnessOfIteration(function (iterable) {
	  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
	});

	// helpers
	var isThenable = function (it) {
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};

	var notify = function (state, isReject) {
	  if (state.notified) return;
	  state.notified = true;
	  var chain = state.reactions;
	  microtask(function () {
	    var value = state.value;
	    var ok = state.state == FULFILLED;
	    var index = 0;
	    // variable length - can't use forEach
	    while (chain.length > index) {
	      var reaction = chain[index++];
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (state.rejection === UNHANDLED) onHandleUnhandled(state);
	            state.rejection = HANDLED;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value); // can throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (error) {
	        if (domain && !exited) domain.exit();
	        reject(error);
	      }
	    }
	    state.reactions = [];
	    state.notified = false;
	    if (isReject && !state.rejection) onUnhandled(state);
	  });
	};

	var dispatchEvent = function (name, promise, reason) {
	  var event, handler;
	  if (DISPATCH_EVENT) {
	    event = document$1.createEvent('Event');
	    event.promise = promise;
	    event.reason = reason;
	    event.initEvent(name, false, true);
	    global_1.dispatchEvent(event);
	  } else event = { promise: promise, reason: reason };
	  if (!NATIVE_REJECTION_EVENT && (handler = global_1['on' + name])) handler(event);
	  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
	};

	var onUnhandled = function (state) {
	  task.call(global_1, function () {
	    var promise = state.facade;
	    var value = state.value;
	    var IS_UNHANDLED = isUnhandled(state);
	    var result;
	    if (IS_UNHANDLED) {
	      result = perform(function () {
	        if (engineIsNode) {
	          process.emit('unhandledRejection', value, promise);
	        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      state.rejection = engineIsNode || isUnhandled(state) ? UNHANDLED : HANDLED;
	      if (result.error) throw result.value;
	    }
	  });
	};

	var isUnhandled = function (state) {
	  return state.rejection !== HANDLED && !state.parent;
	};

	var onHandleUnhandled = function (state) {
	  task.call(global_1, function () {
	    var promise = state.facade;
	    if (engineIsNode) {
	      process.emit('rejectionHandled', promise);
	    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
	  });
	};

	var bind$3 = function (fn, state, unwrap) {
	  return function (value) {
	    fn(state, value, unwrap);
	  };
	};

	var internalReject = function (state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  state.value = value;
	  state.state = REJECTED;
	  notify(state, true);
	};

	var internalResolve = function (state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  try {
	    if (state.facade === value) throw TypeError$1("Promise can't be resolved itself");
	    var then = isThenable(value);
	    if (then) {
	      microtask(function () {
	        var wrapper = { done: false };
	        try {
	          then.call(value,
	            bind$3(internalResolve, wrapper, state),
	            bind$3(internalReject, wrapper, state)
	          );
	        } catch (error) {
	          internalReject(wrapper, error, state);
	        }
	      });
	    } else {
	      state.value = value;
	      state.state = FULFILLED;
	      notify(state, false);
	    }
	  } catch (error) {
	    internalReject({ done: false }, error, state);
	  }
	};

	// constructor polyfill
	if (FORCED$5) {
	  // 25.4.3.1 Promise(executor)
	  PromiseConstructor = function Promise(executor) {
	    anInstance(this, PromiseConstructor, PROMISE);
	    aFunction$1(executor);
	    Internal.call(this);
	    var state = getInternalState$2(this);
	    try {
	      executor(bind$3(internalResolve, state), bind$3(internalReject, state));
	    } catch (error) {
	      internalReject(state, error);
	    }
	  };
	  PromiseConstructorPrototype = PromiseConstructor.prototype;
	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  Internal = function Promise(executor) {
	    setInternalState$2(this, {
	      type: PROMISE,
	      done: false,
	      notified: false,
	      parent: false,
	      reactions: [],
	      rejection: false,
	      state: PENDING,
	      value: undefined
	    });
	  };
	  Internal.prototype = redefineAll(PromiseConstructorPrototype, {
	    // `Promise.prototype.then` method
	    // https://tc39.es/ecma262/#sec-promise.prototype.then
	    then: function then(onFulfilled, onRejected) {
	      var state = getInternalPromiseState(this);
	      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = engineIsNode ? process.domain : undefined;
	      state.parent = true;
	      state.reactions.push(reaction);
	      if (state.state != PENDING) notify(state, false);
	      return reaction.promise;
	    },
	    // `Promise.prototype.catch` method
	    // https://tc39.es/ecma262/#sec-promise.prototype.catch
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    var state = getInternalState$2(promise);
	    this.promise = promise;
	    this.resolve = bind$3(internalResolve, state);
	    this.reject = bind$3(internalReject, state);
	  };
	  newPromiseCapability$1.f = newPromiseCapability = function (C) {
	    return C === PromiseConstructor || C === PromiseWrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };
	}

	_export({ global: true, wrap: true, forced: FORCED$5 }, {
	  Promise: PromiseConstructor
	});

	setToStringTag(PromiseConstructor, PROMISE, false, true);
	setSpecies(PROMISE);

	PromiseWrapper = getBuiltIn(PROMISE);

	// statics
	_export({ target: PROMISE, stat: true, forced: FORCED$5 }, {
	  // `Promise.reject` method
	  // https://tc39.es/ecma262/#sec-promise.reject
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this);
	    capability.reject.call(undefined, r);
	    return capability.promise;
	  }
	});

	_export({ target: PROMISE, stat: true, forced: isPure  }, {
	  // `Promise.resolve` method
	  // https://tc39.es/ecma262/#sec-promise.resolve
	  resolve: function resolve(x) {
	    return promiseResolve(this === PromiseWrapper ? PromiseConstructor : this, x);
	  }
	});

	_export({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
	  // `Promise.all` method
	  // https://tc39.es/ecma262/#sec-promise.all
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction$1(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        $promiseResolve.call(C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  },
	  // `Promise.race` method
	  // https://tc39.es/ecma262/#sec-promise.race
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction$1(C.resolve);
	      iterate(iterable, function (promise) {
	        $promiseResolve.call(C, promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	// `Promise.allSettled` method
	// https://tc39.es/ecma262/#sec-promise.allsettled
	_export({ target: 'Promise', stat: true }, {
	  allSettled: function allSettled(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1.f(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var promiseResolve = aFunction$1(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        promiseResolve.call(C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = { status: 'fulfilled', value: value };
	          --remaining || resolve(values);
	        }, function (error) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = { status: 'rejected', reason: error };
	          --remaining || resolve(values);
	        });
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	var PROMISE_ANY_ERROR = 'No one promise resolved';

	// `Promise.any` method
	// https://tc39.es/ecma262/#sec-promise.any
	_export({ target: 'Promise', stat: true }, {
	  any: function any(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1.f(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var promiseResolve = aFunction$1(C.resolve);
	      var errors = [];
	      var counter = 0;
	      var remaining = 1;
	      var alreadyResolved = false;
	      iterate(iterable, function (promise) {
	        var index = counter++;
	        var alreadyRejected = false;
	        errors.push(undefined);
	        remaining++;
	        promiseResolve.call(C, promise).then(function (value) {
	          if (alreadyRejected || alreadyResolved) return;
	          alreadyResolved = true;
	          resolve(value);
	        }, function (error) {
	          if (alreadyRejected || alreadyResolved) return;
	          alreadyRejected = true;
	          errors[index] = error;
	          --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
	        });
	      });
	      --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
	var NON_GENERIC = !!nativePromiseConstructor && fails(function () {
	  nativePromiseConstructor.prototype['finally'].call({ then: function () { /* empty */ } }, function () { /* empty */ });
	});

	// `Promise.prototype.finally` method
	// https://tc39.es/ecma262/#sec-promise.prototype.finally
	_export({ target: 'Promise', proto: true, real: true, forced: NON_GENERIC }, {
	  'finally': function (onFinally) {
	    var C = speciesConstructor(this, getBuiltIn('Promise'));
	    var isFunction = typeof onFinally == 'function';
	    return this.then(
	      isFunction ? function (x) {
	        return promiseResolve(C, onFinally()).then(function () { return x; });
	      } : onFinally,
	      isFunction ? function (e) {
	        return promiseResolve(C, onFinally()).then(function () { throw e; });
	      } : onFinally
	    );
	  }
	});

	// `String.prototype.{ codePointAt, at }` methods implementation
	var createMethod$3 = function (CONVERT_TO_STRING) {
	  return function ($this, pos) {
	    var S = String(requireObjectCoercible($this));
	    var position = toInteger(pos);
	    var size = S.length;
	    var first, second;
	    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
	    first = S.charCodeAt(position);
	    return first < 0xD800 || first > 0xDBFF || position + 1 === size
	      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
	        ? CONVERT_TO_STRING ? S.charAt(position) : first
	        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
	  };
	};

	var stringMultibyte = {
	  // `String.prototype.codePointAt` method
	  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
	  codeAt: createMethod$3(false),
	  // `String.prototype.at` method
	  // https://github.com/mathiasbynens/String.prototype.at
	  charAt: createMethod$3(true)
	};

	var ITERATOR$1 = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS$1 = false;

	var returnThis$2 = function () { return this; };

	// `%IteratorPrototype%` object
	// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
	var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;

	/* eslint-disable es/no-array-prototype-keys -- safe */
	if ([].keys) {
	  arrayIterator = [].keys();
	  // Safari 8 has buggy iterators w/o `next`
	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;
	  else {
	    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
	  }
	}

	var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails(function () {
	  var test = {};
	  // FF44- legacy iterators case
	  return IteratorPrototype$2[ITERATOR$1].call(test) !== test;
	});

	if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};

	// `%IteratorPrototype%[@@iterator]()` method
	// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
	if ((NEW_ITERATOR_PROTOTYPE) && !has$1(IteratorPrototype$2, ITERATOR$1)) {
	  createNonEnumerableProperty(IteratorPrototype$2, ITERATOR$1, returnThis$2);
	}

	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype$2,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
	};

	var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;





	var returnThis$1 = function () { return this; };

	var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });
	  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
	  iterators[TO_STRING_TAG] = returnThis$1;
	  return IteratorConstructor;
	};

	var IteratorPrototype = iteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS = iteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR = wellKnownSymbol('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';

	var returnThis = function () { return this; };

	var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);

	  var getIterationMethod = function (KIND) {
	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
	    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
	    switch (KIND) {
	      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
	      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
	      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
	    } return function () { return new IteratorConstructor(this); };
	  };

	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR]
	    || IterablePrototype['@@iterator']
	    || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY;

	  // fix native
	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
	    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
	      iterators[TO_STRING_TAG] = returnThis;
	    }
	  }

	  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
	  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    INCORRECT_VALUES_NAME = true;
	    defaultIterator = function values() { return nativeIterator.call(this); };
	  }

	  // define iterator
	  if ((FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
	    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
	  }
	  iterators[NAME] = defaultIterator;

	  // export additional methods
	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        redefine(IterablePrototype, KEY, methods[KEY]);
	      }
	    } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
	  }

	  return methods;
	};

	var charAt = stringMultibyte.charAt;



	var STRING_ITERATOR = 'String Iterator';
	var setInternalState$1 = internalState.set;
	var getInternalState$1 = internalState.getterFor(STRING_ITERATOR);

	// `String.prototype[@@iterator]` method
	// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
	defineIterator(String, 'String', function (iterated) {
	  setInternalState$1(this, {
	    type: STRING_ITERATOR,
	    string: String(iterated),
	    index: 0
	  });
	// `%StringIteratorPrototype%.next` method
	// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
	}, function next() {
	  var state = getInternalState$1(this);
	  var string = state.string;
	  var index = state.index;
	  var point;
	  if (index >= string.length) return { value: undefined, done: true };
	  point = charAt(string, index);
	  state.index += point.length;
	  return { value: point, done: false };
	});

	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState = internalState.set;
	var getInternalState = internalState.getterFor(ARRAY_ITERATOR);

	// `Array.prototype.entries` method
	// https://tc39.es/ecma262/#sec-array.prototype.entries
	// `Array.prototype.keys` method
	// https://tc39.es/ecma262/#sec-array.prototype.keys
	// `Array.prototype.values` method
	// https://tc39.es/ecma262/#sec-array.prototype.values
	// `Array.prototype[@@iterator]` method
	// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
	// `CreateArrayIterator` internal method
	// https://tc39.es/ecma262/#sec-createarrayiterator
	defineIterator(Array, 'Array', function (iterated, kind) {
	  setInternalState(this, {
	    type: ARRAY_ITERATOR,
	    target: toIndexedObject(iterated), // target
	    index: 0,                          // next index
	    kind: kind                         // kind
	  });
	// `%ArrayIteratorPrototype%.next` method
	// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
	}, function () {
	  var state = getInternalState(this);
	  var target = state.target;
	  var kind = state.kind;
	  var index = state.index++;
	  if (!target || index >= target.length) {
	    state.target = undefined;
	    return { value: undefined, done: true };
	  }
	  if (kind == 'keys') return { value: index, done: false };
	  if (kind == 'values') return { value: target[index], done: false };
	  return { value: [index, target[index]], done: false };
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values%
	// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
	// https://tc39.es/ecma262/#sec-createmappedargumentsobject
	iterators.Arguments = iterators.Array;

	// iterable DOM collections
	// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
	var domIterables = {
	  CSSRuleList: 0,
	  CSSStyleDeclaration: 0,
	  CSSValueList: 0,
	  ClientRectList: 0,
	  DOMRectList: 0,
	  DOMStringList: 0,
	  DOMTokenList: 1,
	  DataTransferItemList: 0,
	  FileList: 0,
	  HTMLAllCollection: 0,
	  HTMLCollection: 0,
	  HTMLFormElement: 0,
	  HTMLSelectElement: 0,
	  MediaList: 0,
	  MimeTypeArray: 0,
	  NamedNodeMap: 0,
	  NodeList: 1,
	  PaintRequestList: 0,
	  Plugin: 0,
	  PluginArray: 0,
	  SVGLengthList: 0,
	  SVGNumberList: 0,
	  SVGPathSegList: 0,
	  SVGPointList: 0,
	  SVGStringList: 0,
	  SVGTransformList: 0,
	  SourceBufferList: 0,
	  StyleSheetList: 0,
	  TextTrackCueList: 0,
	  TextTrackList: 0,
	  TouchList: 0
	};

	var TO_STRING_TAG = wellKnownSymbol('toStringTag');

	for (var COLLECTION_NAME in domIterables) {
	  var Collection = global_1[COLLECTION_NAME];
	  var CollectionPrototype = Collection && Collection.prototype;
	  if (CollectionPrototype && classof(CollectionPrototype) !== TO_STRING_TAG) {
	    createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
	  }
	  iterators[COLLECTION_NAME] = iterators.Array;
	}

	var promise$2 = path.Promise;

	var promise$1 = promise$2;

	var promise = promise$1;

	var EventCoordinator = (function () {
	    function EventCoordinator() {
	        this.interceptors = {};
	        this.listeners = {};
	    }
	    EventCoordinator.prototype.addEventListener = function (event, listener) {
	        var listeners = this.listeners[event] || [];
	        listeners.push(listener);
	        this.listeners[event] = listeners;
	        return this;
	    };
	    EventCoordinator.prototype.removeEventListener = function (event, listener) {
	        this.listeners[event] = (this.listeners[event] || []).filter(function (l) { return l !== listener; });
	        return this;
	    };
	    EventCoordinator.prototype.addEventInterceptor = function (event, interceptor) {
	        this.interceptors[event] = interceptor;
	        return this;
	    };
	    EventCoordinator.prototype.removeEventInterceptor = function (event) {
	        delete this.interceptors[event];
	        return this;
	    };
	    EventCoordinator.prototype.coordinate = function (event, value) {
	        var interceptor = this.interceptors[event] || (function () { return Promise.resolve(value); });
	        var listeners = this.listeners[event] || [];
	        return Promise.resolve()
	            .then(function () { return interceptor.call(null, value); })
	            .then(function (result) {
	            listeners.forEach(function (listener) {
	                listener.call(null, result);
	            });
	            return result;
	        });
	    };
	    return EventCoordinator;
	}());

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics = function(d, b) {
	    extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics(d, b);
	};

	function __extends(d, b) {
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign = function() {
	    __assign = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};

	function __awaiter(thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	}

	function __generator(thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	}

	function __read(o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	}

	function __spread() {
	    for (var ar = [], i = 0; i < arguments.length; i++)
	        ar = ar.concat(__read(arguments[i]));
	    return ar;
	}

	var Brand;
	(function (Brand) {
	    Brand["abc"] = "abc";
	    Brand["abcNews"] = "abcnews";
	    Brand["abcNewsLive"] = "abcnewslive";
	    Brand["abcOtv"] = "abcotv";
	    Brand["cricinfo"] = "cricinfo";
	    Brand["disney"] = "dch";
	    Brand["disneyJr"] = "djr";
	    Brand["disneyXD"] = "dxd";
	    Brand["disneyNow"] = "dnow";
	    Brand["espn"] = "espn";
	    Brand["espnFantasy"] = "espnFantasy";
	    Brand["fiveThirtyEight"] = "fivethirtyeight";
	    Brand["foxLatam"] = "foxlatam";
	    Brand["freeform"] = "ff";
	    Brand["fxNow"] = "fxnow";
	    Brand["fx"] = "fx";
	    Brand["fxm"] = "fxm";
	    Brand["fxx"] = "fxx";
	    Brand["oscar"] = "oscar";
	    Brand["marvel"] = "marvel";
	    Brand["natGeoTV"] = "ngtv";
	    Brand["natGeo"] = "ngc";
	    Brand["natGeoWild"] = "ngw";
	    Brand["natgeoBrasil"] = "natgeobrasil";
	    Brand["theUndefeated"] = "theundefeated";
	    Brand["unknown"] = "000";
	})(Brand || (Brand = {}));
	function getBrandNames(brand) {
	    switch (brand) {
	        case Brand.abc:
	            return 'ABC';
	        case Brand.abcNews:
	            return 'ABC News';
	        case Brand.abcNewsLive:
	            return 'ABC News Live';
	        case Brand.abcOtv:
	            return 'ABC OTV';
	        case Brand.cricinfo:
	            return 'ESPNcricinfo';
	        case Brand.disney:
	            return 'Disney';
	        case Brand.disneyJr:
	            return 'Disney Junior';
	        case Brand.disneyXD:
	            return 'Disney XD';
	        case Brand.disneyNow:
	            return 'DisneyNow';
	        case Brand.espn:
	            return 'ESPN';
	        case Brand.espnFantasy:
	            return 'ESPN Fantasy';
	        case Brand.fiveThirtyEight:
	            return 'FiveThirtyEight';
	        case Brand.foxLatam:
	            return 'Fox Latam';
	        case Brand.freeform:
	            return 'Freeform';
	        case Brand.fxNow:
	            return 'FX Now';
	        case Brand.fx:
	            return 'FX Networks';
	        case Brand.fxm:
	            return 'FX Movie Channel';
	        case Brand.fxx:
	            return 'FXX';
	        case Brand.oscar:
	            return 'Oscar';
	        case Brand.marvel:
	            return 'Marvel';
	        case Brand.natGeoTV:
	            return 'National Geographic TV ';
	        case Brand.natGeo:
	            return 'National Geographic Chanel';
	        case Brand.natGeoWild:
	            return 'National Geographic Wild';
	        case Brand.theUndefeated:
	            return 'The Undefeated';
	        case Brand.unknown:
	            return Brand.unknown;
	    }
	}
	function brandLegacyId(brand) {
	    switch (brand) {
	        case Brand.abc:
	            return '001';
	        case Brand.freeform:
	            return '002';
	        case Brand.abcNews:
	            return '003';
	        case Brand.disney:
	            return '004';
	        case Brand.disneyJr:
	            return '008';
	        case Brand.disneyXD:
	            return '009';
	        case Brand.disneyNow:
	            return '011';
	        case Brand.oscar:
	            return '005';
	        case Brand.fxNow:
	            return '025';
	        case Brand.fx:
	            return '020';
	        case Brand.fxm:
	            return '022';
	        case Brand.fxx:
	            return '021';
	        case Brand.natGeoTV:
	            return '026';
	        case Brand.natGeo:
	            return '023';
	        case Brand.natGeoWild:
	            return '024';
	        case Brand.unknown:
	            return Brand.unknown;
	    }
	}
	function brandResourceId(brand) {
	    switch (brand) {
	        case Brand.abc:
	            return 'ABC';
	        case Brand.freeform:
	            return 'ABCFamily';
	        case Brand.abcNews:
	            return 'ABC';
	        case Brand.disney:
	            return 'Disney';
	        case Brand.disneyJr:
	            return 'DisneyJunior';
	        case Brand.disneyXD:
	            return 'DisneyXD';
	        case Brand.disneyNow:
	            return 'DisneyNow';
	        case Brand.oscar:
	            return 'ABC';
	        case Brand.fxNow:
	            return 'fxNow';
	        case Brand.fx:
	            return 'fx';
	        case Brand.fxm:
	            return 'fxm';
	        case Brand.fxx:
	            return 'fxx';
	        case Brand.natGeoTV:
	            return 'ngtv';
	        case Brand.natGeo:
	            return 'ngc';
	        case Brand.natGeoWild:
	            return 'ngw';
	        case Brand.unknown:
	            return Brand.unknown;
	    }
	}
	function getBrandFromString(value) {
	    switch (value) {
	        case 'abc':
	        case '001':
	            return Brand.abc;
	        case 'abcf':
	        case '002':
	        case 'abcfamily':
	        case 'ff':
	        case 'ABCFamily':
	            return Brand.freeform;
	        case 'abcn':
	        case '003':
	        case 'abcnews':
	            return Brand.abcNews;
	        case 'dch':
	        case 'dc':
	        case 'dis':
	        case '004':
	        case 'disney':
	            return Brand.disney;
	        case 'djr':
	        case '008':
	        case 'disneyjunior':
	            return Brand.disneyJr;
	        case 'dxd':
	        case '009':
	        case 'disneyxd':
	            return Brand.disneyXD;
	        case '005':
	        case 'oscar':
	            return Brand.oscar;
	        case 'dnow':
	        case '011':
	        case 'disneynow':
	        case 'dnw':
	        case 'Dnow':
	            return Brand.disneyNow;
	        case 'fx':
	        case '020':
	        case 'FX':
	            return Brand.fx;
	        case 'fxm':
	        case '022':
	        case 'FXM':
	            return Brand.fxm;
	        case 'fxx':
	        case '021':
	        case 'FXX':
	            return Brand.fxx;
	        case 'fxnow':
	        case '025':
	        case 'FXnow':
	        case 'FXNow':
	            return Brand.fxNow;
	        case 'natgeo':
	        case '023':
	        case 'NatGeo':
	        case 'ngc':
	            return Brand.natGeo;
	        case 'natgeowild':
	        case '024':
	        case 'NatGeoWild':
	        case 'ngw':
	            return Brand.natGeoWild;
	        case 'natgeotv':
	        case '026':
	        case 'NatGeoTV':
	            return Brand.natGeoTV;
	        default:
	            return Brand.unknown;
	    }
	}

	var StorageType;
	(function (StorageType) {
	    StorageType["localStorage"] = "LOCAL_STORAGE";
	    StorageType["sessionStorage"] = "SESSION_STORAGE";
	})(StorageType || (StorageType = {}));

	var AuthenticatedProvider = (function () {
	    function AuthenticatedProvider(id, name, logoUrl, websiteUrl) {
	        this.id = id;
	        this.name = name;
	        this.logoUrl = logoUrl;
	        this.websiteUrl = websiteUrl;
	    }
	    AuthenticatedProvider.prototype.toString = function () {
	        return "<AuthenticatedProvider id:" + this.id + ", name:" + this.name + ", logoUrl:" + this.logoUrl + ", websiteUrl:" + this.websiteUrl + ">";
	    };
	    AuthenticatedProvider.fromObject = function (json) {
	        return new AuthenticatedProvider(json.id, json.name, json.logoUrl, json.websiteUrl);
	    };
	    return AuthenticatedProvider;
	}());

	var CustomDataKey;
	(function (CustomDataKey) {
	    CustomDataKey["token"] = "token";
	    CustomDataKey["tokenType"] = "tokenType";
	    CustomDataKey["resource"] = "resource";
	    CustomDataKey["requestor"] = "requestor";
	    CustomDataKey["fullToken"] = "fullToken";
	    CustomDataKey["zipcode"] = "zipcode";
	    CustomDataKey["mvpd"] = "mvpd";
	})(CustomDataKey || (CustomDataKey = {}));
	var AuthorizationPayload = (function () {
	    function AuthorizationPayload(authenticationType, authenticatedProvider, authenticatedIdentity, customData) {
	        if (customData === void 0) { customData = {}; }
	        this.authenticationType = authenticationType;
	        this.authenticatedProvider = authenticatedProvider;
	        this.authenticatedIdentity = authenticatedIdentity;
	        this.customData = customData;
	    }
	    AuthorizationPayload.CustomDataKey = CustomDataKey;
	    return AuthorizationPayload;
	}());

	var AuthorizationResult = (function () {
	    function AuthorizationResult(success, payload) {
	        this.success = success;
	        this.payload = payload;
	    }
	    return AuthorizationResult;
	}());

	var AdProvider$1;
	(function (AdProvider) {
	    AdProvider["standard"] = "default";
	    AdProvider["googleAdManager"] = "gam";
	})(AdProvider$1 || (AdProvider$1 = {}));

	var AdEnvironment;
	(function (AdEnvironment) {
	    AdEnvironment["standard"] = "default";
	    AdEnvironment["prod"] = "prod";
	    AdEnvironment["development"] = "dev";
	})(AdEnvironment || (AdEnvironment = {}));

	var EVT_LOAD = 'load';
	var EVT_ERROR = 'error';
	var LOAD_TIMEOUT = 4000;
	function loadScript$1(url, timeout) {
	    if (timeout === void 0) { timeout = LOAD_TIMEOUT; }
	    var win = typeof window !== 'undefined' && window;
	    var doc = win && win.document;
	    var docHead = doc && doc.getElementsByTagName && doc.getElementsByTagName('head')[0];
	    var docBody = doc && doc.body;
	    var docTarget = docHead || docBody;
	    if (!(docTarget && url)) {
	        return Promise.reject();
	    }
	    return new Promise(function injectScript(resolve, reject) {
	        var script = document.createElement('script');
	        var disposers = [];
	        var loadTimeout = null;
	        var dispose = function () {
	            disposers.forEach(function (disposer) { return disposer(); });
	            disposers = null;
	            clearTimeout(loadTimeout);
	            loadTimeout = null;
	        };
	        var onLoad = function disposeAndResolve(evt) {
	            dispose();
	            resolve(evt);
	        };
	        var onError = function disposeAndReject(err) {
	            dispose();
	            reject(err);
	        };
	        script.type = 'text/javascript';
	        script.src = url;
	        script.addEventListener(EVT_LOAD, onLoad);
	        disposers.push(function () { return script.removeEventListener(EVT_LOAD, onLoad); });
	        script.addEventListener(EVT_ERROR, onError);
	        disposers.push(function () { return script.removeEventListener(EVT_ERROR, onError); });
	        loadTimeout = setTimeout(function () { return onError(new Error("Timeout (" + timeout + ") while fetching " + url)); }, LOAD_TIMEOUT);
	        docTarget.appendChild(script);
	    });
	}

	var NO_PAL_FALLBACK = Object.freeze({});
	var EMPTY_STR = Object.freeze('');
	var DEFAULT_PLAYER_SIZE = '640x480';
	var PAL_LOADER_SRC = 'https://imasdk.googleapis.com/pal/sdkloader/pal.js';
	var VIDEO_DELIVERY_METHOD_LIVE = 'vod';
	var win = typeof window !== 'undefined' && window;
	var logError = function (err) {
	    win && win.console && win.console.error(err);
	};
	var palSdkInstance;
	var nonceLoader;
	var cachedNonce;
	var loadPalDependencies = function embedPalLoader() {
	    return __awaiter(this, void 0, void 0, function () {
	        var pal, hadBC, err_1;
	        return __generator(this, function (_a) {
	            switch (_a.label) {
	                case 0:
	                    pal = palSdkInstance || (win.goog && win.goog.pal);
	                    hadBC = win && win.bc;
	                    if (!!pal) return [3, 5];
	                    _a.label = 1;
	                case 1:
	                    _a.trys.push([1, 3, , 4]);
	                    return [4, loadScript$1(PAL_LOADER_SRC)];
	                case 2:
	                    _a.sent();
	                    return [3, 4];
	                case 3:
	                    err_1 = _a.sent();
	                    logError(err_1);
	                    return [3, 4];
	                case 4:
	                    pal = win.goog && win.goog.pal;
	                    if (pal) {
	                        palSdkInstance = pal;
	                    }
	                    if (!hadBC && win.bc) {
	                        win.bc = null;
	                    }
	                    _a.label = 5;
	                case 5: return [2, pal || NO_PAL_FALLBACK];
	            }
	        });
	    });
	};
	function mapAdvertisingInfoToGoogleNonceRequestData(advertisingInfo) {
	    var _a = __read(String(advertisingInfo.videoPlayerSize || DEFAULT_PLAYER_SIZE).split('x'), 2), videoWidth = _a[0], videoHeight = _a[1];
	    return {
	        adWillAutoPlay: advertisingInfo.isAutoplay,
	        adWillPlayMuted: advertisingInfo.isMute,
	        continuousPlayback: advertisingInfo.videoDeliveryMethod === VIDEO_DELIVERY_METHOD_LIVE,
	        descriptionUrl: advertisingInfo.descriptionUrl || EMPTY_STR,
	        iconsSupported: advertisingInfo.vastIconsSupported,
	        playerType: advertisingInfo.videoPlayerType || EMPTY_STR,
	        playerVersion: advertisingInfo.videoPlayerVersion || EMPTY_STR,
	        ppid: advertisingInfo.ppid || advertisingInfo.swid || EMPTY_STR,
	        videoHeight: parseInt(videoHeight, 10),
	        videoWidth: parseInt(videoWidth, 10),
	    };
	}
	function generateNonce(advertisingInfo, maxLength, reinstantiateLoader, useSessionNonce, dependencyLoader) {
	    if (maxLength === void 0) { maxLength = 3000; }
	    if (reinstantiateLoader === void 0) { reinstantiateLoader = false; }
	    if (useSessionNonce === void 0) { useSessionNonce = true; }
	    if (dependencyLoader === void 0) { dependencyLoader = loadPalDependencies; }
	    return __awaiter(this, void 0, void 0, function () {
	        var nonce, NonceLoader, NonceRequest, palSdk, err_2, nonceManager, nonceRequest, err_3;
	        return __generator(this, function (_a) {
	            switch (_a.label) {
	                case 0:
	                    nonce = (useSessionNonce && cachedNonce) || EMPTY_STR;
	                    if (!!nonce) return [3, 10];
	                    NonceLoader = void 0, NonceRequest = void 0;
	                    _a.label = 1;
	                case 1:
	                    _a.trys.push([1, 3, , 4]);
	                    return [4, dependencyLoader()];
	                case 2:
	                    palSdk = _a.sent();
	                    if (palSdk) {
	                        NonceLoader = palSdk.NonceLoader;
	                        NonceRequest = palSdk.NonceRequest;
	                    }
	                    return [3, 4];
	                case 3:
	                    err_2 = _a.sent();
	                    logError(err_2);
	                    return [3, 4];
	                case 4:
	                    if (!(!(useSessionNonce && cachedNonce) && NonceLoader && NonceRequest)) return [3, 10];
	                    nonceManager = void 0;
	                    _a.label = 5;
	                case 5:
	                    _a.trys.push([5, 7, , 8]);
	                    nonceLoader = !nonceLoader || reinstantiateLoader ? new NonceLoader() : nonceLoader;
	                    nonceRequest = Object.assign(new NonceRequest(), mapAdvertisingInfoToGoogleNonceRequestData(advertisingInfo));
	                    return [4, nonceLoader.loadNonceManager(nonceRequest)];
	                case 6:
	                    nonceManager = _a.sent();
	                    return [3, 8];
	                case 7:
	                    err_3 = _a.sent();
	                    logError(err_3);
	                    return [3, 8];
	                case 8:
	                    if (!nonceManager) return [3, 10];
	                    return [4, nonceManager.getNonce()];
	                case 9:
	                    nonce = _a.sent();
	                    if (!nonce || (Number(maxLength) > 0 && String(nonce).length > maxLength)) {
	                        nonce = EMPTY_STR;
	                    }
	                    if (nonce) {
	                        cachedNonce = nonce;
	                    }
	                    _a.label = 10;
	                case 10: return [2, nonce];
	            }
	        });
	    });
	}

	var optionalInt = function (val) {
	    if (val === null) {
	        return null;
	    }
	    return val ? '1' : '0';
	};
	var optionalBool = function (first, second) {
	    if (first !== null && first !== undefined) {
	        return first;
	    }
	    return second;
	};
	var AdvertisingInfo = (function () {
	    function AdvertisingInfo(aff, alt, accessLevel, adRule, an, beacType, collection, cbp, descriptionUrl, edition, fcap, hashedIp, hl, isAuth, idType, impl, isLat, iu, msid, npa, ltd, nlsnPlat, output, palNonce, playlist, ppid, rdid, tags, transId, tfcd, url, varResolution, vpa, vpi, vadFormat, vpmute, authenticationProvider, bundleId, deviceOS, deviceType, isAutoplay, isMute, language, nielsenAppId, nielsenDeviceGroup, noAds, objectId, pageType, platform, stitchingProvider, swid, testAdTargeting, tag, unid, vastIconsSupported, videoDeliveryMethod, videoPlayerSize, videoPlayerType, videoPlayerVersion, userInfo, isDoNotTrackEnabled, pp, cmsid, vid, adEnvironment, adProvider, usPrivacy, additionalConsent, rdp) {
	        if (aff === void 0) { aff = null; }
	        if (alt === void 0) { alt = null; }
	        if (accessLevel === void 0) { accessLevel = null; }
	        if (adRule === void 0) { adRule = null; }
	        if (an === void 0) { an = 'espn'; }
	        if (beacType === void 0) { beacType = null; }
	        if (collection === void 0) { collection = null; }
	        if (cbp === void 0) { cbp = null; }
	        if (descriptionUrl === void 0) { descriptionUrl = null; }
	        if (edition === void 0) { edition = null; }
	        if (fcap === void 0) { fcap = null; }
	        if (hashedIp === void 0) { hashedIp = null; }
	        if (hl === void 0) { hl = null; }
	        if (isAuth === void 0) { isAuth = null; }
	        if (idType === void 0) { idType = null; }
	        if (impl === void 0) { impl = null; }
	        if (isLat === void 0) { isLat = false; }
	        if (iu === void 0) { iu = null; }
	        if (msid === void 0) { msid = null; }
	        if (npa === void 0) { npa = false; }
	        if (ltd === void 0) { ltd = false; }
	        if (nlsnPlat === void 0) { nlsnPlat = null; }
	        if (output === void 0) { output = null; }
	        if (palNonce === void 0) { palNonce = null; }
	        if (playlist === void 0) { playlist = null; }
	        if (ppid === void 0) { ppid = null; }
	        if (rdid === void 0) { rdid = null; }
	        if (tags === void 0) { tags = null; }
	        if (transId === void 0) { transId = null; }
	        if (tfcd === void 0) { tfcd = false; }
	        if (url === void 0) { url = null; }
	        if (varResolution === void 0) { varResolution = null; }
	        if (vpa === void 0) { vpa = null; }
	        if (vpi === void 0) { vpi = null; }
	        if (vadFormat === void 0) { vadFormat = null; }
	        if (vpmute === void 0) { vpmute = null; }
	        if (authenticationProvider === void 0) { authenticationProvider = null; }
	        if (bundleId === void 0) { bundleId = null; }
	        if (deviceOS === void 0) { deviceOS = null; }
	        if (deviceType === void 0) { deviceType = null; }
	        if (isAutoplay === void 0) { isAutoplay = null; }
	        if (isMute === void 0) { isMute = null; }
	        if (language === void 0) { language = null; }
	        if (nielsenAppId === void 0) { nielsenAppId = null; }
	        if (nielsenDeviceGroup === void 0) { nielsenDeviceGroup = null; }
	        if (noAds === void 0) { noAds = null; }
	        if (objectId === void 0) { objectId = null; }
	        if (pageType === void 0) { pageType = null; }
	        if (platform === void 0) { platform = null; }
	        if (stitchingProvider === void 0) { stitchingProvider = null; }
	        if (swid === void 0) { swid = null; }
	        if (testAdTargeting === void 0) { testAdTargeting = null; }
	        if (tag === void 0) { tag = null; }
	        if (unid === void 0) { unid = null; }
	        if (vastIconsSupported === void 0) { vastIconsSupported = false; }
	        if (videoDeliveryMethod === void 0) { videoDeliveryMethod = null; }
	        if (videoPlayerSize === void 0) { videoPlayerSize = null; }
	        if (videoPlayerType === void 0) { videoPlayerType = null; }
	        if (videoPlayerVersion === void 0) { videoPlayerVersion = null; }
	        if (userInfo === void 0) { userInfo = {}; }
	        if (isDoNotTrackEnabled === void 0) { isDoNotTrackEnabled = null; }
	        if (pp === void 0) { pp = null; }
	        if (cmsid === void 0) { cmsid = null; }
	        if (vid === void 0) { vid = null; }
	        if (adEnvironment === void 0) { adEnvironment = AdEnvironment.standard; }
	        if (adProvider === void 0) { adProvider = AdProvider$1.standard; }
	        if (usPrivacy === void 0) { usPrivacy = null; }
	        if (additionalConsent === void 0) { additionalConsent = null; }
	        if (rdp === void 0) { rdp = null; }
	        this.aff = aff;
	        this.alt = alt;
	        this.accessLevel = accessLevel;
	        this.adRule = adRule;
	        this.an = an;
	        this.beacType = beacType;
	        this.collection = collection;
	        this.cbp = cbp;
	        this.descriptionUrl = descriptionUrl;
	        this.edition = edition;
	        this.fcap = fcap;
	        this.hashedIp = hashedIp;
	        this.hl = hl;
	        this.isAuth = isAuth;
	        this.idType = idType;
	        this.impl = impl;
	        this.isLat = isLat;
	        this.iu = iu;
	        this.msid = msid;
	        this.npa = npa;
	        this.ltd = ltd;
	        this.nlsnPlat = nlsnPlat;
	        this.output = output;
	        this.palNonce = palNonce;
	        this.playlist = playlist;
	        this.ppid = ppid;
	        this.rdid = rdid;
	        this.tags = tags;
	        this.transId = transId;
	        this.tfcd = tfcd;
	        this.url = url;
	        this.varResolution = varResolution;
	        this.vpa = vpa;
	        this.vpi = vpi;
	        this.vadFormat = vadFormat;
	        this.vpmute = vpmute;
	        this.authenticationProvider = authenticationProvider;
	        this.bundleId = bundleId;
	        this.deviceOS = deviceOS;
	        this.deviceType = deviceType;
	        this.isAutoplay = isAutoplay;
	        this.isMute = isMute;
	        this.language = language;
	        this.nielsenAppId = nielsenAppId;
	        this.nielsenDeviceGroup = nielsenDeviceGroup;
	        this.noAds = noAds;
	        this.objectId = objectId;
	        this.pageType = pageType;
	        this.platform = platform;
	        this.stitchingProvider = stitchingProvider;
	        this.swid = swid;
	        this.testAdTargeting = testAdTargeting;
	        this.tag = tag;
	        this.unid = unid;
	        this.vastIconsSupported = vastIconsSupported;
	        this.videoDeliveryMethod = videoDeliveryMethod;
	        this.videoPlayerSize = videoPlayerSize;
	        this.videoPlayerType = videoPlayerType;
	        this.videoPlayerVersion = videoPlayerVersion;
	        this.userInfo = userInfo;
	        this.isDoNotTrackEnabled = isDoNotTrackEnabled;
	        this.pp = pp;
	        this.cmsid = cmsid;
	        this.vid = vid;
	        this.adEnvironment = adEnvironment;
	        this.adProvider = adProvider;
	        this.usPrivacy = usPrivacy;
	        this.additionalConsent = additionalConsent;
	        this.rdp = rdp;
	    }
	    AdvertisingInfo.prototype.merge = function (other) {
	        if (!other) {
	            return this;
	        }
	        this.adRule = other.adRule || this.adRule;
	        this.an = other.an || this.an;
	        this.descriptionUrl = other.descriptionUrl || this.descriptionUrl;
	        this.fcap = other.fcap || this.fcap;
	        this.hashedIp = other.hashedIp || this.hashedIp;
	        this.hl = other.hl || this.hl;
	        this.idType = other.idType || this.idType;
	        this.isLat = optionalBool(other.isLat, this.isLat);
	        this.iu = other.iu || this.iu;
	        this.msid = other.msid || this.msid;
	        this.npa = optionalBool(other.npa, this.npa);
	        this.ltd = optionalBool(other.ltd, this.ltd);
	        this.output = other.output || this.output;
	        this.ppid = other.ppid || this.ppid;
	        this.rdid = other.rdid || this.rdid;
	        this.rdp = other.rdp || this.rdp;
	        this.tfcd = other.tfcd || this.tfcd;
	        this.url = other.url || this.url;
	        this.vpa = other.vpa || this.vpa;
	        this.vpi = other.vpi || this.vpi;
	        this.vadFormat = other.vadFormat || this.vadFormat;
	        this.vpmute = optionalBool(other.vpmute, this.vpmute);
	        this.authenticationProvider = other.authenticationProvider || this.authenticationProvider;
	        this.bundleId = other.bundleId || this.bundleId;
	        this.deviceOS = other.deviceOS || this.deviceOS;
	        this.deviceType = other.deviceType || this.deviceType;
	        this.isAutoplay = optionalBool(other.isAutoplay, this.isAutoplay);
	        this.isMute = optionalBool(other.isMute, this.isMute);
	        this.language = other.language || this.language;
	        this.palNonce = other.palNonce || this.palNonce;
	        this.nielsenAppId = other.nielsenAppId || this.nielsenAppId;
	        this.nielsenDeviceGroup = other.nielsenDeviceGroup || this.nielsenDeviceGroup;
	        this.noAds = optionalBool(other.noAds, this.noAds);
	        this.objectId = other.objectId || this.objectId;
	        this.platform = other.platform || this.platform;
	        this.stitchingProvider = other.stitchingProvider || this.stitchingProvider;
	        this.swid = other.swid || this.swid;
	        this.tags = other.tags || this.tags;
	        this.testAdTargeting = other.testAdTargeting || this.testAdTargeting;
	        this.unid = other.unid || this.unid;
	        this.alt = other.alt || this.alt;
	        this.beacType = other.beacType || this.beacType;
	        this.transId = other.transId || this.transId;
	        this.accessLevel = other.accessLevel || this.accessLevel;
	        this.varResolution = other.varResolution || this.varResolution;
	        this.nlsnPlat = other.nlsnPlat || this.nlsnPlat;
	        this.tag = other.tag || this.tag;
	        this.aff = other.aff || this.aff;
	        this.playlist = other.playlist || this.playlist;
	        this.cbp = other.cbp || this.cbp;
	        this.collection = other.collection || this.collection;
	        this.impl = other.impl || this.impl;
	        this.isAuth = other.isAuth || this.isAuth;
	        this.vastIconsSupported = optionalBool(other.vastIconsSupported, this.vastIconsSupported);
	        this.videoDeliveryMethod = other.videoDeliveryMethod || this.videoDeliveryMethod;
	        this.videoPlayerSize = other.videoPlayerSize || this.videoPlayerSize;
	        this.videoPlayerType = other.videoPlayerType || this.videoPlayerType;
	        this.videoPlayerVersion = other.videoPlayerVersion || this.videoPlayerVersion;
	        this.isDoNotTrackEnabled = optionalBool(other.isDoNotTrackEnabled, this.isDoNotTrackEnabled);
	        this.pp = other.pp || this.pp;
	        this.cmsid = other.cmsid || this.cmsid;
	        this.usPrivacy = other.usPrivacy || this.usPrivacy;
	        this.additionalConsent = other.additionalConsent || this.additionalConsent;
	        this.vid = other.vid || this.vid;
	        if (!this.userInfo) {
	            this.userInfo = other.userInfo;
	        }
	        else {
	            Object.assign(this.userInfo, other.userInfo);
	        }
	        this.adEnvironment = other.adEnvironment !== AdEnvironment.standard ? other.adEnvironment : this.adEnvironment;
	        this.adProvider = other.adProvider !== AdProvider$1.standard ? other.adProvider : this.adProvider;
	        return this;
	    };
	    AdvertisingInfo.prototype.dictionaryForStartSession = function () {
	        var info = {};
	        info['ad.tfcd'] = optionalInt(this.tfcd);
	        info['ad.is_lat'] = optionalInt(this.isLat);
	        info['ad.idtype'] = this.idType;
	        info['ad.rdid'] = this.rdid;
	        info['ad.ppid'] = this.ppid || this.swid;
	        info['ad.description_url'] = this.descriptionUrl;
	        info['ad.hl'] = this.hl;
	        info['ad.paln'] = this.palNonce;
	        info['ad.npa'] = optionalInt(this.npa);
	        info['ad.ltd'] = optionalInt(this.ltd);
	        info['ad.msid'] = this.msid;
	        info['ad.an'] = this.an;
	        info['ad.url'] = this.url;
	        info['ad.us_privacy'] = this.usPrivacy;
	        info['ad.cust_params.d_us_privacy'] = this.usPrivacy;
	        info['ad.rdp'] = this.rdp !== null ? this.rdp : this.usPrivacy === '1YYY' ? '1' : null;
	        info.authp = this.authenticationProvider;
	        info.bundleId = this.bundleId;
	        info.devOS = this.deviceOS;
	        info.devType = this.deviceType;
	        info.fcap = this.fcap;
	        info.isAutoplay = optionalInt(this.isAutoplay);
	        info.isMute = optionalInt(this.isMute);
	        info.nlsnAppID = this.nielsenAppId;
	        info.plt = this.platform;
	        info.swid = this.swid;
	        info.unid = this.unid;
	        info.vps = this.videoPlayerSize;
	        if (this.adEnvironment !== AdEnvironment.standard) {
	            info.adEnv = this.adEnvironment;
	        }
	        if (this.adProvider !== AdProvider$1.standard) {
	            info.adProvider = this.adProvider;
	        }
	        Object.assign(info, this.userInfo);
	        Object.keys(info).forEach(function (key) { return info[key] === null && delete info[key]; });
	        return info;
	    };
	    AdvertisingInfo.prototype.dictionaryForBrightcove = function () {
	        var customParams = {};
	        customParams.bundleId = this.bundleId;
	        customParams.devOS = this.deviceOS;
	        customParams.devType = this.deviceType;
	        customParams.isAutoplay = optionalInt(this.isAutoplay);
	        customParams.isMute = optionalInt(this.isMute);
	        customParams.plt = this.platform;
	        customParams.swid = this.swid;
	        customParams.vps = this.videoPlayerSize;
	        customParams.d_id = this.rdid;
	        customParams.vdm = this.videoDeliveryMethod || 'vod';
	        customParams.stp = this.stitchingProvider || 'brightcove';
	        var customParamsString = Object.keys(customParams)
	            .filter(function (key) { return customParams[key] !== null; })
	            .map(function (key) { return key + "=" + customParams[key]; })
	            .join('&');
	        var info = {};
	        info.UMADPARAMiu = this.iu;
	        info.UMADPARAMis_lat = optionalInt(this.isLat);
	        info.UMADPARAMidtype = this.idType;
	        info.UMADPARAMrdid = this.rdid;
	        info.UMADPARAMppid = this.ppid || this.swid;
	        info.UMADPARAMdescription_url = this.descriptionUrl;
	        info.UMADPARAMhl = this.hl;
	        info.UMADPARAMnpa = optionalInt(this.npa);
	        info.UMADPARAMltd = optionalInt(this.ltd);
	        info.UMADPARAMmsid = this.msid;
	        info.UMADPARAMan = this.an;
	        info.UMADPARAMurl = this.url;
	        info.UMADPARAMvpa = optionalInt(this.vpa);
	        info.UMADPARAMvpmute = optionalInt(this.vpmute);
	        info.UMPTPARAMcust_params = customParamsString;
	        Object.assign(info, this.userInfo);
	        Object.keys(info).forEach(function (key) { return info[key] === null && delete info[key]; });
	        return info;
	    };
	    AdvertisingInfo.prototype.dictionaryForAdEngine = function () {
	        var info = {};
	        info.sect = this.iu;
	        info.npa = optionalInt(this.npa);
	        info.ltd = optionalInt(this.ltd);
	        info.lat = optionalInt(this.isLat);
	        info.idtype = this.idType;
	        info.devId = this.rdid;
	        info.ppid = this.ppid || this.swid;
	        info.app = this.an;
	        info.tfcd = optionalInt(this.tfcd);
	        info.devOS = this.deviceOS;
	        info.devType = this.deviceType;
	        info.isAutoplay = optionalInt(this.isAutoplay);
	        info.isMute = optionalInt(this.isMute);
	        info.plt = this.platform;
	        info.swid = this.swid;
	        info.unid = this.unid;
	        info.vps = this.videoPlayerSize;
	        info.bundle = this.msid;
	        info.hl = this.hl;
	        info.UID = this.swid;
	        info.vdm = this.videoDeliveryMethod;
	        info.url = this.url;
	        switch (this.adEnvironment) {
	            case AdEnvironment.development:
	                info.env = 'qa';
	                break;
	            case AdEnvironment.prod:
	                info.env = 'prod';
	                break;
	            case AdEnvironment.standard:
	        }
	        switch (this.adProvider) {
	            case AdProvider$1.googleAdManager:
	                info.ads = 'google';
	                break;
	            case AdProvider$1.standard:
	        }
	        Object.assign(info, this.userInfo);
	        Object.keys(info).forEach(function (key) { return info[key] === null && delete info[key]; });
	        return info;
	    };
	    AdvertisingInfo.prototype.dictionaryForImaSdk = function () {
	        var customParams = {};
	        customParams.authp = this.authenticationProvider;
	        customParams.d_us_privacy = this.usPrivacy;
	        customParams.devOS = this.deviceOS;
	        customParams.devType = this.deviceType;
	        customParams.ed = this.edition;
	        customParams.hip = this.hashedIp;
	        customParams.isAutoplay = optionalInt(this.isAutoplay);
	        customParams.isDnt = optionalInt(this.isDoNotTrackEnabled);
	        customParams.isMute = optionalInt(this.isMute);
	        customParams.lang = this.language;
	        customParams.nlsnAppID = this.nielsenAppId;
	        customParams.nlsnDevGrp = this.nielsenDeviceGroup;
	        customParams.noad = this.noAds;
	        customParams.objid = this.objectId;
	        customParams.plt = this.platform;
	        customParams.swid = this.swid;
	        customParams.tag = this.tags;
	        customParams.tstAdTar = this.testAdTargeting;
	        customParams.unid = this.unid;
	        customParams.vdm = this.videoDeliveryMethod || 'vod';
	        customParams.vps = this.videoPlayerSize;
	        var customParamsString = Object.keys(customParams)
	            .filter(function (key) { return customParams[key] !== null; })
	            .map(function (key) { return key + "=" + customParams[key]; })
	            .join('&');
	        var info = {};
	        info.ad_rule = this.adRule;
	        info.cmsid = this.cmsid;
	        info.description_url = this.descriptionUrl;
	        info.hl = this.hl;
	        info.iu = this.iu;
	        info.npa = optionalInt(this.npa);
	        info.output = this.output;
	        info.ltd = optionalInt(this.ltd);
	        info.pp = this.pp;
	        info.ppid = this.ppid;
	        info.rdp = this.rdp;
	        info.tfcd = optionalInt(this.tfcd);
	        info.us_privacy = this.usPrivacy;
	        info.addtl_consent = this.additionalConsent;
	        info.vid = this.vid;
	        info.vpa = optionalInt(this.vpa);
	        info.cust_params = customParamsString;
	        info.gdfp_req = '1';
	        info.env = 'vp';
	        info.sz = '640x480';
	        if (this.adEnvironment !== AdEnvironment.standard) {
	            info.adEnv = this.adEnvironment;
	        }
	        Object.keys(info).forEach(function (key) { return info[key] === null && delete info[key]; });
	        return info;
	    };
	    AdvertisingInfo.prototype.dictionaryForEntertainment = function () {
	        var customParams = {};
	        customParams.ed = this.edition;
	        customParams.devOS = this.deviceOS;
	        customParams.devType = this.deviceType;
	        customParams.hip = this.hashedIp;
	        customParams.isAutoplay = optionalInt(this.isAutoplay);
	        customParams.isDnt = optionalInt(this.isDoNotTrackEnabled);
	        customParams.isMute = optionalInt(this.isMute);
	        customParams.lang = this.language;
	        customParams.nlsnAppID = this.nielsenAppId;
	        customParams.nlsnDevGrp = this.nielsenDeviceGroup;
	        customParams.nlsnPlat = this.nlsnPlat;
	        customParams.noad = this.noAds;
	        customParams.objid = this.objectId;
	        customParams.plt = this.platform;
	        customParams.swid = this.swid || this.ppid;
	        customParams.tag = this.tags;
	        customParams.tstAdTar = this.testAdTargeting;
	        customParams.unid = this.unid;
	        customParams.vdm = this.videoDeliveryMethod || 'vod';
	        customParams.vps = this.videoPlayerSize;
	        customParams.alt = this.alt;
	        customParams.beacType = this.beacType;
	        customParams.transId = this.transId;
	        customParams.accesslevel = this.accessLevel;
	        customParams.isAuth = this.isAuth;
	        customParams.fcap = this.fcap;
	        customParams.var = this.varResolution;
	        customParams.tag = this.tag;
	        customParams.aff = this.aff;
	        customParams.authp = this.authenticationProvider;
	        customParams.playlist = this.playlist;
	        customParams.cbp = this.cbp;
	        customParams.collection = this.collection;
	        customParams.impl = this.impl;
	        var customParamsString = Object.keys(customParams)
	            .filter(function (key) { return customParams[key] !== null; })
	            .map(function (key) { return key + "=" + customParams[key]; })
	            .join('&');
	        var info = {};
	        info.addtl_consent = this.additionalConsent;
	        info.ad_rule = this.adRule;
	        info.cmsid = this.cmsid;
	        info.description_url = this.descriptionUrl;
	        info.hl = this.hl;
	        info.iu = this.iu;
	        info.npa = optionalInt(this.npa);
	        info.output = this.output;
	        info.ltd = optionalInt(this.ltd);
	        info.pp = this.pp;
	        info.ppid = this.ppid;
	        info.tfcd = optionalInt(this.tfcd);
	        info.vid = this.vid;
	        info.vpa = optionalInt(this.vpa);
	        info.cust_params = customParamsString;
	        info.output = this.output;
	        info.vad_format = this.vadFormat;
	        info.vpi = this.vpi;
	        info.url = this.url;
	        info.us_privacy = this.usPrivacy;
	        info.gdfp_req = '1';
	        info.env = 'vp';
	        info.sz = '640x480';
	        Object.keys(info).forEach(function (key) { return info[key] === null && delete info[key]; });
	        return info;
	    };
	    AdvertisingInfo.ppidForSwid = function (swid) {
	        return swid;
	    };
	    AdvertisingInfo.getGooglePalNonce = generateNonce;
	    return AdvertisingInfo;
	}());

	// `IsArray` abstract operation
	// https://tc39.es/ecma262/#sec-isarray
	// eslint-disable-next-line es/no-array-isarray -- safe
	var isArray$4 = Array.isArray || function isArray(arg) {
	  return classofRaw(arg) == 'Array';
	};

	var SPECIES$2 = wellKnownSymbol('species');

	// `ArraySpeciesCreate` abstract operation
	// https://tc39.es/ecma262/#sec-arrayspeciescreate
	var arraySpeciesCreate = function (originalArray, length) {
	  var C;
	  if (isArray$4(originalArray)) {
	    C = originalArray.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray$4(C.prototype))) C = undefined;
	    else if (isObject(C)) {
	      C = C[SPECIES$2];
	      if (C === null) C = undefined;
	    }
	  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
	};

	var push = [].push;

	// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation
	var createMethod$2 = function (TYPE) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var IS_FILTER_OUT = TYPE == 7;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  return function ($this, callbackfn, that, specificCreate) {
	    var O = toObject($this);
	    var self = indexedObject(O);
	    var boundFunction = functionBindContext(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var create = specificCreate || arraySpeciesCreate;
	    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;
	    var value, result;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      value = self[index];
	      result = boundFunction(value, index, O);
	      if (TYPE) {
	        if (IS_MAP) target[index] = result; // map
	        else if (result) switch (TYPE) {
	          case 3: return true;              // some
	          case 5: return value;             // find
	          case 6: return index;             // findIndex
	          case 2: push.call(target, value); // filter
	        } else switch (TYPE) {
	          case 4: return false;             // every
	          case 7: push.call(target, value); // filterOut
	        }
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
	  };
	};

	var arrayIteration = {
	  // `Array.prototype.forEach` method
	  // https://tc39.es/ecma262/#sec-array.prototype.foreach
	  forEach: createMethod$2(0),
	  // `Array.prototype.map` method
	  // https://tc39.es/ecma262/#sec-array.prototype.map
	  map: createMethod$2(1),
	  // `Array.prototype.filter` method
	  // https://tc39.es/ecma262/#sec-array.prototype.filter
	  filter: createMethod$2(2),
	  // `Array.prototype.some` method
	  // https://tc39.es/ecma262/#sec-array.prototype.some
	  some: createMethod$2(3),
	  // `Array.prototype.every` method
	  // https://tc39.es/ecma262/#sec-array.prototype.every
	  every: createMethod$2(4),
	  // `Array.prototype.find` method
	  // https://tc39.es/ecma262/#sec-array.prototype.find
	  find: createMethod$2(5),
	  // `Array.prototype.findIndex` method
	  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
	  findIndex: createMethod$2(6),
	  // `Array.prototype.filterOut` method
	  // https://github.com/tc39/proposal-array-filtering
	  filterOut: createMethod$2(7)
	};

	var SPECIES$1 = wellKnownSymbol('species');

	var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
	  // We can't use this feature detection in V8 since it causes
	  // deoptimization and serious performance degradation
	  // https://github.com/zloirock/core-js/issues/677
	  return engineV8Version >= 51 || !fails(function () {
	    var array = [];
	    var constructor = array.constructor = {};
	    constructor[SPECIES$1] = function () {
	      return { foo: 1 };
	    };
	    return array[METHOD_NAME](Boolean).foo !== 1;
	  });
	};

	var $map = arrayIteration.map;


	var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('map');

	// `Array.prototype.map` method
	// https://tc39.es/ecma262/#sec-array.prototype.map
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$3 }, {
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var entryVirtual = function (CONSTRUCTOR) {
	  return path[CONSTRUCTOR + 'Prototype'];
	};

	var map$2 = entryVirtual('Array').map;

	var ArrayPrototype$7 = Array.prototype;

	var map_1 = function (it) {
	  var own = it.map;
	  return it === ArrayPrototype$7 || (it instanceof Array && own === ArrayPrototype$7.map) ? map$2 : own;
	};

	var map$1 = map_1;

	var map = map$1;

	/* jshint strict: false */
	const loadScript = {
	  url: url => {
	    return new promise((resolve, reject) => {
	      const script = document.createElement('script');
	      script.type = 'text/javascript';
	      script.src = url;
	      script.addEventListener('load', () => resolve(script), false);
	      script.addEventListener('error', () => reject(script), false);
	      document.body.appendChild(script);
	    });
	  },
	  urls: urls => {
	    return promise.allSettled(map(urls).call(urls, loadScript.url));
	  }
	};

	var slice$4 = [].slice;
	var factories = {};

	var construct = function (C, argsLength, args) {
	  if (!(argsLength in factories)) {
	    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
	    // eslint-disable-next-line no-new-func -- we have no proper alternatives, IE8- only
	    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
	  } return factories[argsLength](C, args);
	};

	// `Function.prototype.bind` method implementation
	// https://tc39.es/ecma262/#sec-function.prototype.bind
	var functionBind = Function.bind || function bind(that /* , ...args */) {
	  var fn = aFunction$1(this);
	  var partArgs = slice$4.call(arguments, 1);
	  var boundFunction = function bound(/* args... */) {
	    var args = partArgs.concat(slice$4.call(arguments));
	    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
	  };
	  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
	  return boundFunction;
	};

	// `Function.prototype.bind` method
	// https://tc39.es/ecma262/#sec-function.prototype.bind
	_export({ target: 'Function', proto: true }, {
	  bind: functionBind
	});

	var bind$2 = entryVirtual('Function').bind;

	var FunctionPrototype = Function.prototype;

	var bind_1 = function (it) {
	  var own = it.bind;
	  return it === FunctionPrototype || (it instanceof Function && own === FunctionPrototype.bind) ? bind$2 : own;
	};

	var bind$1 = bind_1;

	var bind = bind$1;

	// `Array.isArray` method
	// https://tc39.es/ecma262/#sec-array.isarray
	_export({ target: 'Array', stat: true }, {
	  isArray: isArray$4
	});

	var isArray$3 = path.Array.isArray;

	var isArray$2 = isArray$3;

	var isArray$1 = isArray$2;

	var arrayMethodIsStrict = function (METHOD_NAME, argument) {
	  var method = [][METHOD_NAME];
	  return !!method && fails(function () {
	    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
	    method.call(null, argument || function () { throw 1; }, 1);
	  });
	};

	var test = [];
	var nativeSort = test.sort;

	// IE8-
	var FAILS_ON_UNDEFINED = fails(function () {
	  test.sort(undefined);
	});
	// V8 bug
	var FAILS_ON_NULL = fails(function () {
	  test.sort(null);
	});
	// Old WebKit
	var STRICT_METHOD$2 = arrayMethodIsStrict('sort');

	var FORCED$4 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$2;

	// `Array.prototype.sort` method
	// https://tc39.es/ecma262/#sec-array.prototype.sort
	_export({ target: 'Array', proto: true, forced: FORCED$4 }, {
	  sort: function sort(comparefn) {
	    return comparefn === undefined
	      ? nativeSort.call(toObject(this))
	      : nativeSort.call(toObject(this), aFunction$1(comparefn));
	  }
	});

	var sort$2 = entryVirtual('Array').sort;

	var ArrayPrototype$6 = Array.prototype;

	var sort_1 = function (it) {
	  var own = it.sort;
	  return it === ArrayPrototype$6 || (it instanceof Array && own === ArrayPrototype$6.sort) ? sort$2 : own;
	};

	var sort$1 = sort_1;

	var sort = sort$1;

	var slice$3 = [].slice;
	var MSIE = /MSIE .\./.test(engineUserAgent); // <- dirty ie9- check

	var wrap = function (scheduler) {
	  return function (handler, timeout /* , ...arguments */) {
	    var boundArgs = arguments.length > 2;
	    var args = boundArgs ? slice$3.call(arguments, 2) : undefined;
	    return scheduler(boundArgs ? function () {
	      // eslint-disable-next-line no-new-func -- spec requirement
	      (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);
	    } : handler, timeout);
	  };
	};

	// ie9- setTimeout & setInterval additional parameters fix
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
	_export({ global: true, bind: true, forced: MSIE }, {
	  // `setTimeout` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
	  setTimeout: wrap(global_1.setTimeout),
	  // `setInterval` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
	  setInterval: wrap(global_1.setInterval)
	});

	var setTimeout$2 = path.setTimeout;

	var setTimeout$1 = setTimeout$2;

	// `Date.now` method
	// https://tc39.es/ecma262/#sec-date.now
	_export({ target: 'Date', stat: true }, {
	  now: function now() {
	    return new Date().getTime();
	  }
	});

	var now$2 = path.Date.now;

	var now$1 = now$2;

	var now = now$1;

	/* eslint-disable es/no-array-prototype-indexof -- required for testing */

	var $indexOf = arrayIncludes.indexOf;


	var nativeIndexOf = [].indexOf;

	var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
	var STRICT_METHOD$1 = arrayMethodIsStrict('indexOf');

	// `Array.prototype.indexOf` method
	// https://tc39.es/ecma262/#sec-array.prototype.indexof
	_export({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD$1 }, {
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? nativeIndexOf.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var indexOf$2 = entryVirtual('Array').indexOf;

	var ArrayPrototype$5 = Array.prototype;

	var indexOf_1 = function (it) {
	  var own = it.indexOf;
	  return it === ArrayPrototype$5 || (it instanceof Array && own === ArrayPrototype$5.indexOf) ? indexOf$2 : own;
	};

	var indexOf$1 = indexOf_1;

	var indexOf = indexOf$1;

	// a string of all valid unicode whitespaces
	var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
	  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var whitespace = '[' + whitespaces + ']';
	var ltrim = RegExp('^' + whitespace + whitespace + '*');
	var rtrim = RegExp(whitespace + whitespace + '*$');

	// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
	var createMethod$1 = function (TYPE) {
	  return function ($this) {
	    var string = String(requireObjectCoercible($this));
	    if (TYPE & 1) string = string.replace(ltrim, '');
	    if (TYPE & 2) string = string.replace(rtrim, '');
	    return string;
	  };
	};

	var stringTrim = {
	  // `String.prototype.{ trimLeft, trimStart }` methods
	  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
	  start: createMethod$1(1),
	  // `String.prototype.{ trimRight, trimEnd }` methods
	  // https://tc39.es/ecma262/#sec-string.prototype.trimend
	  end: createMethod$1(2),
	  // `String.prototype.trim` method
	  // https://tc39.es/ecma262/#sec-string.prototype.trim
	  trim: createMethod$1(3)
	};

	var trim$4 = stringTrim.trim;


	var $parseFloat = global_1.parseFloat;
	var FORCED$3 = 1 / $parseFloat(whitespaces + '-0') !== -Infinity;

	// `parseFloat` method
	// https://tc39.es/ecma262/#sec-parsefloat-string
	var numberParseFloat = FORCED$3 ? function parseFloat(string) {
	  var trimmedString = trim$4(String(string));
	  var result = $parseFloat(trimmedString);
	  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

	// `parseFloat` method
	// https://tc39.es/ecma262/#sec-parsefloat-string
	_export({ global: true, forced: parseFloat != numberParseFloat }, {
	  parseFloat: numberParseFloat
	});

	var _parseFloat$2 = path.parseFloat;

	var _parseFloat$1 = _parseFloat$2;

	var _parseFloat = _parseFloat$1;

	var $forEach = arrayIteration.forEach;


	var STRICT_METHOD = arrayMethodIsStrict('forEach');

	// `Array.prototype.forEach` method implementation
	// https://tc39.es/ecma262/#sec-array.prototype.foreach
	var arrayForEach = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
	  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	// eslint-disable-next-line es/no-array-prototype-foreach -- safe
	} : [].forEach;

	// `Array.prototype.forEach` method
	// https://tc39.es/ecma262/#sec-array.prototype.foreach
	// eslint-disable-next-line es/no-array-prototype-foreach -- safe
	_export({ target: 'Array', proto: true, forced: [].forEach != arrayForEach }, {
	  forEach: arrayForEach
	});

	var forEach$2 = entryVirtual('Array').forEach;

	var forEach$1 = forEach$2;

	var ArrayPrototype$4 = Array.prototype;

	var DOMIterables = {
	  DOMTokenList: true,
	  NodeList: true
	};

	var forEach_1 = function (it) {
	  var own = it.forEach;
	  return it === ArrayPrototype$4 || (it instanceof Array && own === ArrayPrototype$4.forEach)
	    // eslint-disable-next-line no-prototype-builtins -- safe
	    || DOMIterables.hasOwnProperty(classof(it)) ? forEach$1 : own;
	};

	var forEach = forEach_1;

	function debounce(fn, delay = 0) {
	  let timeoutId;
	  return (...args) => {
	    clearTimeout(timeoutId);
	    timeoutId = setTimeout$1(() => fn.apply(this, ...args), delay);
	  };
	}

	var createProperty = function (object, key, value) {
	  var propertyKey = toPrimitive(key);
	  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
	  else object[propertyKey] = value;
	};

	var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('slice');

	var SPECIES = wellKnownSymbol('species');
	var nativeSlice = [].slice;
	var max$1 = Math.max;

	// `Array.prototype.slice` method
	// https://tc39.es/ecma262/#sec-array.prototype.slice
	// fallback for not array-like ES3 strings and DOM objects
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 }, {
	  slice: function slice(start, end) {
	    var O = toIndexedObject(this);
	    var length = toLength(O.length);
	    var k = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
	    var Constructor, result, n;
	    if (isArray$4(O)) {
	      Constructor = O.constructor;
	      // cross-realm fallback
	      if (typeof Constructor == 'function' && (Constructor === Array || isArray$4(Constructor.prototype))) {
	        Constructor = undefined;
	      } else if (isObject(Constructor)) {
	        Constructor = Constructor[SPECIES];
	        if (Constructor === null) Constructor = undefined;
	      }
	      if (Constructor === Array || Constructor === undefined) {
	        return nativeSlice.call(O, k, fin);
	      }
	    }
	    result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));
	    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
	    result.length = n;
	    return result;
	  }
	});

	var slice$2 = entryVirtual('Array').slice;

	var ArrayPrototype$3 = Array.prototype;

	var slice_1 = function (it) {
	  var own = it.slice;
	  return it === ArrayPrototype$3 || (it instanceof Array && own === ArrayPrototype$3.slice) ? slice$2 : own;
	};

	var slice$1 = slice_1;

	var slice = slice$1;

	var MediaItemMediaCommand;
	(function (MediaItemMediaCommand) {
	    MediaItemMediaCommand[MediaItemMediaCommand["all"] = 0] = "all";
	    MediaItemMediaCommand[MediaItemMediaCommand["linearPlayback"] = 1] = "linearPlayback";
	})(MediaItemMediaCommand || (MediaItemMediaCommand = {}));
	var MediaItemMediaCommand$1 = MediaItemMediaCommand;

	var MediaItemNetworkType;
	(function (MediaItemNetworkType) {
	    MediaItemNetworkType["linear"] = "linear";
	    MediaItemNetworkType["event"] = "event";
	})(MediaItemNetworkType || (MediaItemNetworkType = {}));
	var MediaItemNetworkType$1 = MediaItemNetworkType;

	var MediaItemSourceVariant;
	(function (MediaItemSourceVariant) {
	    MediaItemSourceVariant["stitchedPreroll"] = "stitchedPreroll";
	})(MediaItemSourceVariant || (MediaItemSourceVariant = {}));
	var MediaItemSourceVariant$1 = MediaItemSourceVariant;

	var MediaItemStreamType;
	(function (MediaItemStreamType) {
	    MediaItemStreamType["live"] = "live";
	    MediaItemStreamType["onDemand"] = "onDemand";
	})(MediaItemStreamType || (MediaItemStreamType = {}));
	var MediaItemStreamType$1 = MediaItemStreamType;

	var MediaItemTrackingType;
	(function (MediaItemTrackingType) {
	    MediaItemTrackingType["nielsen"] = "nielsen";
	    MediaItemTrackingType["comscore"] = "comscore";
	    MediaItemTrackingType["conviva"] = "conviva";
	    MediaItemTrackingType["heartbeats"] = "heartbeats";
	})(MediaItemTrackingType || (MediaItemTrackingType = {}));
	var MediaItemTrackingType$1 = MediaItemTrackingType;

	var MediaItemEntityType;
	(function (MediaItemEntityType) {
	    MediaItemEntityType["shortform"] = "shortform";
	    MediaItemEntityType["longform"] = "longform";
	})(MediaItemEntityType || (MediaItemEntityType = {}));
	var MediaItemEntityType$1 = MediaItemEntityType;

	var MediaItemType;
	(function (MediaItemType) {
	    MediaItemType["audio"] = "audio";
	    MediaItemType["video"] = "video";
	})(MediaItemType || (MediaItemType = {}));
	var MediaItemType$1 = MediaItemType;

	var ApiSource;
	(function (ApiSource) {
	    ApiSource["pluto"] = "pluto";
	    ApiSource["graphQL"] = "graphQL";
	    ApiSource["cfa"] = "cfa";
	})(ApiSource || (ApiSource = {}));
	var ApiSource$1 = ApiSource;

	var MediaItemAuthenticationType;
	(function (MediaItemAuthenticationType) {
	    MediaItemAuthenticationType["open"] = "OPEN";
	    MediaItemAuthenticationType["direct"] = "DIRECT";
	    MediaItemAuthenticationType["mvpd"] = "MVPD";
	    MediaItemAuthenticationType["isp"] = "ISP";
	    MediaItemAuthenticationType["none"] = "NONE";
	})(MediaItemAuthenticationType || (MediaItemAuthenticationType = {}));
	var MediaItemAuthenticationType$1 = MediaItemAuthenticationType;

	var MediaItemSourceType;
	(function (MediaItemSourceType) {
	    MediaItemSourceType["none"] = "none";
	    MediaItemSourceType["startSession"] = "startSession";
	    MediaItemSourceType["bam"] = "bam";
	    MediaItemSourceType["shield"] = "shield";
	    MediaItemSourceType["entitlement"] = "entitlement";
	})(MediaItemSourceType || (MediaItemSourceType = {}));
	var MediaItemSourceType$1 = MediaItemSourceType;

	var MediaItemSource = (function () {
	    function MediaItemSource(url, type, hasEspnId3Heartbeats, hasNielsenWatermarks, hasPassThroughAds, commercialReplacement, startSessionUrl, variant) {
	        this.url = url;
	        this.type = type;
	        this.hasEspnId3Heartbeats = hasEspnId3Heartbeats;
	        this.hasNielsenWatermarks = hasNielsenWatermarks;
	        this.hasPassThroughAds = hasPassThroughAds;
	        this.commercialReplacement = commercialReplacement;
	        this.startSessionUrl = startSessionUrl;
	        this.variant = variant;
	    }
	    MediaItemSource.fromObject = function (object) {
	        if (!object) {
	            return null;
	        }
	        var url = object.url, type = object.type, hasEspnId3Heartbeats = object.hasEspnId3Heartbeats, hasNielsenWatermarks = object.hasNielsenWatermarks, hasPassThroughAds = object.hasPassThroughAds, commercialReplacement = object.commercialReplacement, startSessionUrl = object.startSessionUrl, variant = object.variant;
	        var sourceType = MediaItemSourceType$1[type];
	        return new MediaItemSource(url, sourceType, hasEspnId3Heartbeats, hasNielsenWatermarks, hasPassThroughAds, commercialReplacement, startSessionUrl, variant);
	    };
	    return MediaItemSource;
	}());

	var MediaItemNetwork = (function () {
	    function MediaItemNetwork(id, type, name, resource) {
	        this.id = id;
	        this.type = type;
	        this.name = name;
	        this.resource = resource;
	    }
	    MediaItemNetwork.fromObject = function (object) {
	        if (!object) {
	            return null;
	        }
	        var type = MediaItemNetworkType$1[object.type];
	        return new MediaItemNetwork(object.id, type, object.name, object.resource);
	    };
	    return MediaItemNetwork;
	}());

	var MediaItemImage = (function () {
	    function MediaItemImage(url) {
	        this.url = url;
	    }
	    MediaItemImage.fromObject = function (object) {
	        if (object && object.url) {
	            return new MediaItemImage(object.url);
	        }
	        return null;
	    };
	    return MediaItemImage;
	}());

	var MediaItemPackage = (function () {
	    function MediaItemPackage(name) {
	        this.name = name;
	    }
	    Object.defineProperty(MediaItemPackage.prototype, "logoUrl", {
	        get: function () {
	            return "https://secure.espncdn.com/watchespn/images/espnplus/packages/" + this.name + ".png";
	        },
	        enumerable: false,
	        configurable: true
	    });
	    MediaItemPackage.fromObject = function (object) {
	        if (!object) {
	            return null;
	        }
	        return new MediaItemPackage(object.name);
	    };
	    return MediaItemPackage;
	}());

	var MediaItem = (function () {
	    function MediaItem(id, title, duration, language, source) {
	        this.id = id;
	        this.title = title;
	        this.duration = duration;
	        this.language = language || 'en';
	        this.source = source;
	        this.description = null;
	        this.authenticationTypes = [];
	        this.mrss = null;
	        this.seekInSeconds = null;
	        this.tracking = {};
	        this.references = {};
	        this.network = null;
	        this.streamType = null;
	        this.supportedMediaCommands = MediaItemMediaCommand$1.all;
	        this.images = [];
	        this.type = MediaItemType$1.video;
	        this.packages = [];
	        this.tier = null;
	        this.entityType = null;
	        this.isSyndicatable = null;
	        this.brand = null;
	        this.apiSource = null;
	        this.adUnitId = null;
	        this.cues = null;
	        this.adTarget = null;
	        this.show = null;
	    }
	    Object.defineProperty(MediaItem.prototype, "isLinear", {
	        get: function () {
	            return !!this.network && this.network.type === MediaItemNetworkType$1.linear;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(MediaItem.prototype, "isLive", {
	        get: function () {
	            return this.streamType === MediaItemStreamType$1.live;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    MediaItem.fromObject = function (json) {
	        var source = MediaItemSource.fromObject(json.source);
	        var mediaItem = new MediaItem(json.id, json.title, json.duration, json.language, source);
	        mediaItem.authenticationTypes = json.authenticationTypes;
	        mediaItem.description = json.description;
	        mediaItem.images = (json.images || []).map(function (img) { return MediaItemImage.fromObject(img); });
	        mediaItem.mrss = json.mrss;
	        mediaItem.network = MediaItemNetwork.fromObject(json.network);
	        mediaItem.seekInSeconds = json.seekInSeconds;
	        mediaItem.streamType = MediaItemStreamType$1[json.streamType];
	        mediaItem.supportedMediaCommands = json.supportedMediaCommands;
	        mediaItem.tracking = json.tracking;
	        mediaItem.references = json.references;
	        mediaItem.packages = (json.packages || []).map(function (pkg) { return MediaItemPackage.fromObject(pkg); });
	        mediaItem.type = MediaItemType$1[json.type];
	        mediaItem.entityType = MediaItemEntityType$1[json.entityType];
	        mediaItem.isSyndicatable = json.isSyndicatable;
	        mediaItem.brand = json.brand;
	        mediaItem.adUnitId = json.adUnitId;
	        mediaItem.cues = json.cues;
	        mediaItem.show = json.show;
	        mediaItem.adTarget = json.adTarget;
	        return mediaItem;
	    };
	    MediaItem.prototype.toString = function () {
	        return "<MediaItem id:" + this.id + ", title:" + this.title + ", streamType:" + this.streamType + ">";
	    };
	    return MediaItem;
	}());

	function QueryStringParser(identifier) {
	    var query = identifier.split('?')[1];
	    var result = {};
	    if (query) {
	        var vars = query.split('&');
	        for (var i = 0; i < vars.length; i += 1) {
	            var pair = vars[i].split('=');
	            result[pair[0]] = pair[1];
	        }
	    }
	    return result;
	}

	var MediaItemIdentifier = (function () {
	    function MediaItemIdentifier(identifier) {
	        var query = QueryStringParser(identifier);
	        this.original = identifier;
	        this.id = (query.videoID || query.playID || query.clip || query.externalId);
	        if (identifier.match('sportscenter')) {
	            this.gameId = query.playGameID;
	            this.channel = query.playChannel;
	            this.simulcastAiringId = query.simulcastAiringId;
	            var resumeTime = parseInt(query.resumeTime, 10);
	            if (!isNaN(resumeTime)) {
	                this.resumeTime = resumeTime;
	            }
	            this.eventId = query.eventId;
	        }
	        this.source = query['x-source'];
	        if (query.videoID) {
	            this.entityType = MediaItemEntityType$1.shortform;
	        }
	        else {
	            this.entityType = MediaItemEntityType$1.longform;
	        }
	        this.type = MediaItemType$1.video;
	    }
	    MediaItemIdentifier.prototype.toString = function (source) {
	        if (source == ApiSource$1.graphQL) {
	            return "<MediaItemIdentifier id:" + this.id + ", gameId:" + this.gameId + ", channel:" + this.channel + ", source:" + this.source + ">";
	        }
	        else {
	            return "<MediaItemIdentifier id:" + this.id + ", source:" + this.source + ">";
	        }
	    };
	    MediaItemIdentifier.identifierStringForNetwork = function (id, source) {
	        var finalSource = source ? source : ApiSource$1.graphQL;
	        if (finalSource == ApiSource$1.graphQL) {
	            return "sportscenter://x-callback-url/showWatchStream?playChannel=" + id;
	        }
	        else {
	            return "natgeo://playVideo?videoID=" + id;
	        }
	    };
	    return MediaItemIdentifier;
	}());

	var loglevel = createCommonjsModule(function (module) {
	/*
	* loglevel - https://github.com/pimterry/loglevel
	*
	* Copyright (c) 2013 Tim Perry
	* Licensed under the MIT license.
	*/
	(function (root, definition) {
	    if (module.exports) {
	        module.exports = definition();
	    } else {
	        root.log = definition();
	    }
	}(commonjsGlobal, function () {

	    // Slightly dubious tricks to cut down minimized file size
	    var noop = function() {};
	    var undefinedType = "undefined";
	    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
	        /Trident\/|MSIE /.test(window.navigator.userAgent)
	    );

	    var logMethods = [
	        "trace",
	        "debug",
	        "info",
	        "warn",
	        "error"
	    ];

	    // Cross-browser bind equivalent that works at least back to IE6
	    function bindMethod(obj, methodName) {
	        var method = obj[methodName];
	        if (typeof method.bind === 'function') {
	            return method.bind(obj);
	        } else {
	            try {
	                return Function.prototype.bind.call(method, obj);
	            } catch (e) {
	                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
	                return function() {
	                    return Function.prototype.apply.apply(method, [obj, arguments]);
	                };
	            }
	        }
	    }

	    // Trace() doesn't print the message in IE, so for that case we need to wrap it
	    function traceForIE() {
	        if (console.log) {
	            if (console.log.apply) {
	                console.log.apply(console, arguments);
	            } else {
	                // In old IE, native console methods themselves don't have apply().
	                Function.prototype.apply.apply(console.log, [console, arguments]);
	            }
	        }
	        if (console.trace) console.trace();
	    }

	    // Build the best logging method possible for this env
	    // Wherever possible we want to bind, not wrap, to preserve stack traces
	    function realMethod(methodName) {
	        if (methodName === 'debug') {
	            methodName = 'log';
	        }

	        if (typeof console === undefinedType) {
	            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
	        } else if (methodName === 'trace' && isIE) {
	            return traceForIE;
	        } else if (console[methodName] !== undefined) {
	            return bindMethod(console, methodName);
	        } else if (console.log !== undefined) {
	            return bindMethod(console, 'log');
	        } else {
	            return noop;
	        }
	    }

	    // These private functions always need `this` to be set properly

	    function replaceLoggingMethods(level, loggerName) {
	        /*jshint validthis:true */
	        for (var i = 0; i < logMethods.length; i++) {
	            var methodName = logMethods[i];
	            this[methodName] = (i < level) ?
	                noop :
	                this.methodFactory(methodName, level, loggerName);
	        }

	        // Define log.log as an alias for log.debug
	        this.log = this.debug;
	    }

	    // In old IE versions, the console isn't present until you first open it.
	    // We build realMethod() replacements here that regenerate logging methods
	    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
	        return function () {
	            if (typeof console !== undefinedType) {
	                replaceLoggingMethods.call(this, level, loggerName);
	                this[methodName].apply(this, arguments);
	            }
	        };
	    }

	    // By default, we use closely bound real methods wherever possible, and
	    // otherwise we wait for a console to appear, and then try again.
	    function defaultMethodFactory(methodName, level, loggerName) {
	        /*jshint validthis:true */
	        return realMethod(methodName) ||
	               enableLoggingWhenConsoleArrives.apply(this, arguments);
	    }

	    function Logger(name, defaultLevel, factory) {
	      var self = this;
	      var currentLevel;

	      var storageKey = "loglevel";
	      if (typeof name === "string") {
	        storageKey += ":" + name;
	      } else if (typeof name === "symbol") {
	        storageKey = undefined;
	      }

	      function persistLevelIfPossible(levelNum) {
	          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

	          if (typeof window === undefinedType || !storageKey) return;

	          // Use localStorage if available
	          try {
	              window.localStorage[storageKey] = levelName;
	              return;
	          } catch (ignore) {}

	          // Use session cookie as fallback
	          try {
	              window.document.cookie =
	                encodeURIComponent(storageKey) + "=" + levelName + ";";
	          } catch (ignore) {}
	      }

	      function getPersistedLevel() {
	          var storedLevel;

	          if (typeof window === undefinedType || !storageKey) return;

	          try {
	              storedLevel = window.localStorage[storageKey];
	          } catch (ignore) {}

	          // Fallback to cookies if local storage gives us nothing
	          if (typeof storedLevel === undefinedType) {
	              try {
	                  var cookie = window.document.cookie;
	                  var location = cookie.indexOf(
	                      encodeURIComponent(storageKey) + "=");
	                  if (location !== -1) {
	                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
	                  }
	              } catch (ignore) {}
	          }

	          // If the stored level is not valid, treat it as if nothing was stored.
	          if (self.levels[storedLevel] === undefined) {
	              storedLevel = undefined;
	          }

	          return storedLevel;
	      }

	      /*
	       *
	       * Public logger API - see https://github.com/pimterry/loglevel for details
	       *
	       */

	      self.name = name;

	      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
	          "ERROR": 4, "SILENT": 5};

	      self.methodFactory = factory || defaultMethodFactory;

	      self.getLevel = function () {
	          return currentLevel;
	      };

	      self.setLevel = function (level, persist) {
	          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
	              level = self.levels[level.toUpperCase()];
	          }
	          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
	              currentLevel = level;
	              if (persist !== false) {  // defaults to true
	                  persistLevelIfPossible(level);
	              }
	              replaceLoggingMethods.call(self, level, name);
	              if (typeof console === undefinedType && level < self.levels.SILENT) {
	                  return "No console available for logging";
	              }
	          } else {
	              throw "log.setLevel() called with invalid level: " + level;
	          }
	      };

	      self.setDefaultLevel = function (level) {
	          if (!getPersistedLevel()) {
	              self.setLevel(level, false);
	          }
	      };

	      self.enableAll = function(persist) {
	          self.setLevel(self.levels.TRACE, persist);
	      };

	      self.disableAll = function(persist) {
	          self.setLevel(self.levels.SILENT, persist);
	      };

	      // Initialize with the right level
	      var initialLevel = getPersistedLevel();
	      if (initialLevel == null) {
	          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
	      }
	      self.setLevel(initialLevel, false);
	    }

	    /*
	     *
	     * Top-level API
	     *
	     */

	    var defaultLogger = new Logger();

	    var _loggersByName = {};
	    defaultLogger.getLogger = function getLogger(name) {
	        if ((typeof name !== "symbol" && typeof name !== "string") || name === "") {
	          throw new TypeError("You must supply a name when creating a logger.");
	        }

	        var logger = _loggersByName[name];
	        if (!logger) {
	          logger = _loggersByName[name] = new Logger(
	            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
	        }
	        return logger;
	    };

	    // Grab the current global log variable in case of overwrite
	    var _log = (typeof window !== undefinedType) ? window.log : undefined;
	    defaultLogger.noConflict = function() {
	        if (typeof window !== undefinedType &&
	               window.log === defaultLogger) {
	            window.log = _log;
	        }

	        return defaultLogger;
	    };

	    defaultLogger.getLoggers = function getLoggers() {
	        return _loggersByName;
	    };

	    // ES6 default export, for compatibility
	    defaultLogger['default'] = defaultLogger;

	    return defaultLogger;
	}));
	});

	function buildNielsenMetadata(graphQLResponse, entityType, source) {
	    if (!graphQLResponse) {
	        return {};
	    }
	    var duration = graphQLResponse.duration, id = graphQLResponse.id, league = graphQLResponse.league, name = graphQLResponse.name, network = graphQLResponse.network, program = graphQLResponse.program, sport = graphQLResponse.sport, startDateTime = graphQLResponse.startDateTime, tracking = graphQLResponse.tracking;
	    var adLoadType = '1';
	    if (source &&
	        source.hasEspnId3Heartbeats === true &&
	        source.hasPassThroughAds === false &&
	        source.commercialReplacement !== 'SHARED INV') {
	        adLoadType = '2';
	    }
	    var metadata = {};
	    metadata.type = 'content';
	    metadata.assetid = (tracking && tracking.trackingId) || id;
	    metadata.program = name;
	    metadata.title = name;
	    metadata.clientid = 'us-600140';
	    if (entityType === MediaItemEntityType$1.longform) {
	        metadata.length = "" + duration;
	        metadata.segB = (league && league.name) || 'No League';
	        metadata.segC = "" + ((program && program.code) || '') + ((sport && sport.code) || '');
	        if (startDateTime) {
	            var airDate = new Date(startDateTime);
	            metadata.airdate = airDate.getUTCFullYear().toString() +
	                ("0" + airDate.getUTCMonth()).slice(-2) +
	                ("0" + airDate.getUTCDate()).slice(-2) + " " + ("0" + airDate.getUTCHours()).slice(-2) + ":" + ("0" + airDate.getUTCMinutes()).slice(-2) + ":" + ("0" + airDate.getUTCSeconds()).slice(-2);
	        }
	        metadata.isfullepisode = 'y';
	        metadata.crossId1 = (tracking && tracking.nielsenCrossId1) || '';
	        metadata.crossId2 = (network && network.name) || '';
	        metadata.adloadtype = adLoadType;
	        metadata.hasAds = '1';
	        metadata.progen = 'SE';
	        metadata.vcid = 'b01';
	    }
	    if (entityType === MediaItemEntityType$1.shortform) {
	        metadata.accmethod = '1';
	        metadata.length = "" + duration;
	        metadata.segA = name;
	        metadata.segB = 'No League';
	        metadata.segC = 'VOD';
	        metadata.isfullepisode = 'n';
	        metadata.crossId1 = '';
	        metadata.adloadtype = '1';
	        metadata.vcid = 'c17';
	        metadata.adloadtype = '2';
	    }
	    return metadata;
	}

	function buildComscoreMetadata(graphQLResponse, entityType) {
	    if (!graphQLResponse) {
	        return {};
	    }
	    var id = graphQLResponse.id, duration = graphQLResponse.duration, name = graphQLResponse.name, league = graphQLResponse.league, startDateTime = graphQLResponse.startDateTime, network = graphQLResponse.network, sport = graphQLResponse.sport, status = graphQLResponse.status, tracking = graphQLResponse.tracking;
	    var metadata = {};
	    if (entityType === MediaItemEntityType$1.longform) {
	        metadata.ns_st_cl = 0;
	        metadata.ns_st_ct = 'vc';
	        if (status && (status.toLowerCase() === 'live' || status.toLowerCase() === 'over')) {
	            metadata.ns_st_cl = 0;
	            metadata.ns_st_ct = 'vc13';
	            metadata.ns_st_pr = name;
	            metadata.ns_st_ep = '*null';
	        }
	        else {
	            metadata.ns_st_cl = duration;
	            metadata.ns_st_ct = 'vc12';
	            metadata.ns_st_pr = 'VOD';
	            metadata.ns_st_ep = name;
	        }
	        metadata.c3 = 'WATCHESPNLIVE';
	        metadata.c6 = league && league.name ? league || 'No league' : (sport && sport.code) || 'No Sport';
	    }
	    else {
	        metadata.ns_st_cl = duration;
	        metadata.ns_st_ct = 'vc11';
	        metadata.ns_st_pr = 'VOD';
	        metadata.ns_st_ep = name;
	        var _a = tracking || {}, sportName = _a.sportName, leagueName = _a.leagueName;
	        metadata.c3 = 'vod';
	        metadata.c6 = "" + (leagueName && leagueName.toLowerCase() !== 'no league' ? leagueName : sportName || 'No Sport');
	    }
	    metadata.ns_st_ti = '*null';
	    metadata.ns_st_ia = '*null';
	    metadata.ns_st_ce = '*null';
	    metadata.ns_st_ci = id;
	    if (startDateTime) {
	        var date = new Date(startDateTime);
	        metadata.ns_st_ddt = date.toDateString();
	        metadata.ns_st_tdt = date.toDateString();
	    }
	    metadata.ns_st_st = network ? network.id : '*null';
	    metadata.ns_st_en = '*null';
	    metadata.ns_st_cn = '1';
	    metadata.ns_st_pn = '1';
	    metadata.ns_st_tp = '1';
	    metadata.ns_st_pu = 'ESPN';
	    metadata.ns_st_cu = 'none';
	    metadata.ns_st_ad = '0';
	    metadata.ns_st_ge = 'Sports';
	    return metadata;
	}

	function buildConvivaMetadata(graphQLResponse, entityType, source) {
	    if (!graphQLResponse) {
	        return {};
	    }
	    var name = graphQLResponse.name, id = graphQLResponse.id, airingId = graphQLResponse.airingId, eventId = graphQLResponse.eventId, duration = graphQLResponse.duration, network = graphQLResponse.network, status = graphQLResponse.status, sport = graphQLResponse.sport, league = graphQLResponse.league;
	    var custom = {};
	    custom.contentId = id;
	    if (airingId) {
	        custom.airingId = airingId;
	    }
	    if (eventId) {
	        custom.eventId = "" + eventId;
	        custom.eventName = name;
	    }
	    if (network) {
	        custom.network = network.id;
	    }
	    if (entityType === MediaItemEntityType$1.shortform) {
	        custom.assetType = 'clip';
	    }
	    else if (status && (status.toLowerCase() === 'live' || status.toLowerCase() === 'over')) {
	        custom.assetType = 'live';
	    }
	    else {
	        custom.assetType = 'vod';
	    }
	    var assetName = name + " - " + id;
	    if (network && network.type === MediaItemNetworkType$1.linear && custom.assetType === 'live') {
	        assetName = network.id;
	    }
	    custom.sport = (sport && sport.name) || 'Not Applicable';
	    custom.league = (league && league.name) || 'Not Applicable';
	    custom.appBrand = Brand.espn;
	    return {
	        assetName: assetName,
	        duration: duration,
	        streamUrl: source && source.url,
	        custom: custom,
	    };
	}

	function buildHeartbeatMetadata(graphQLResponse, entityType) {
	    if (!graphQLResponse) {
	        return {};
	    }
	    var duration = graphQLResponse.duration, airingId = graphQLResponse.airingId, network = graphQLResponse.network, status = graphQLResponse.status, sport = graphQLResponse.sport, league = graphQLResponse.league, name = graphQLResponse.name, program = graphQLResponse.program, startDateTime = graphQLResponse.startDateTime, tracking = graphQLResponse.tracking, originalPublishDate = graphQLResponse.originalPublishDate, expirationDate = graphQLResponse.expirationDate, lastModifiedDate = graphQLResponse.lastModifiedDate, ad = graphQLResponse.ad, coverageType = graphQLResponse.coverageType, brands = graphQLResponse.brands;
	    var info = {};
	    info.ContentDuration = duration;
	    if (entityType === MediaItemEntityType$1.longform) {
	        info.CMSID = (tracking && tracking.name) || name;
	        info.isFullEpisode = 'y';
	        if (airingId) {
	            info.AiringID = airingId;
	        }
	        if (network) {
	            info.NetworkName = network.id;
	            info.Channel = network.id;
	        }
	        if (status) {
	            info.VideoType = status === 'REPLAY' ? 'replay' : 'live';
	        }
	        info.Sport = (sport && sport.name) || 'Not Applicable';
	        info.SportCode = (sport && sport.code) || 'Not Applicable';
	        info.League = (league && league.name) || 'Not Applicable';
	        if (program && program.code && program.categoryCode) {
	            info.ProgramCode = program.categoryCode + program.code;
	        }
	        else {
	            info.ProgramCode = 'Not Applicable';
	        }
	        info.IsStudio = (program && program.isStudio) || 'Not Applicable';
	        if (startDateTime) {
	            var date = new Date(startDateTime);
	            info.AirDate = date.toDateString();
	            info.AirTime = date.toTimeString();
	        }
	        if (Array.isArray(brands) && brands.length) {
	            var _a = brands[0], id = _a.id, name_1 = _a.name, type = _a.type;
	            info['a.media.asset'] = id;
	            info['a.media.show'] = name_1;
	            info['a.media.genre'] = type;
	        }
	    }
	    else if (entityType === MediaItemEntityType$1.shortform) {
	        info.isFullEpisode = 'n';
	        info.VideoType = 'vod';
	        info.Sport = (tracking && tracking.sportName) || 'Not Applicable';
	        info.League = (tracking && tracking.leagueName) || 'Not Applicable';
	        info.ShowCode = (ad && ad.bundle) || 'Not Applicable';
	        if (tracking && tracking.name) {
	            info.CMSID = tracking.name;
	        }
	        if (originalPublishDate) {
	            var date = new Date(originalPublishDate);
	            info.PublishDate = date.toISOString().substring(0, 10);
	            info.PublishTime = date.toISOString().substring(11);
	        }
	        if (expirationDate) {
	            var date = new Date(expirationDate);
	            info.ExpirationDate = date.toISOString();
	        }
	        if (lastModifiedDate) {
	            var date = new Date(lastModifiedDate);
	            info.DateLastModified = date.toISOString();
	        }
	        if (coverageType) {
	            info.VideoTypeDetail = coverageType;
	        }
	    }
	    return info;
	}

	function buildNatGeoHeartbeatMetadata(response) {
	    if (!response) {
	        return {};
	    }
	    var info = {};
	    var id = response.id, title = response.title, duration = response.duration;
	    info.c_video_id_code = id;
	    info.c_a_media_airdate = 'unknown';
	    info.c_a_media_daypart = 'daytime';
	    info.c_a_media_digitaldate = 'unknown';
	    info.c_a_media_episode = 'none';
	    info.c_a_media_feed = 'natgeo live';
	    info.c_a_media_format = 'vod';
	    info.c_a_media_genre = 'none';
	    info.c_a_media_network = 'natgeo';
	    info.c_a_media_originator = 'natgeo';
	    info.c_a_media_pass_auth = 'none';
	    info.c_a_media_pass_mvpd = 'none';
	    info.c_a_media_rating = 'none';
	    info.c_a_media_season = 'none';
	    info.c_a_media_show = title;
	    info.c_a_media_streamtype = MediaItemType.video;
	    info.c_a_media_length = duration;
	    return info;
	}

	function buildMediaItemTracking(brand, response, entityType, source) {
	    if (!response) {
	        return {};
	    }
	    var nielsen, comscore, conviva, heartbeats = null;
	    if (brand === Brand.natGeo) {
	        heartbeats = buildNatGeoHeartbeatMetadata(response);
	    }
	    else {
	        nielsen = buildNielsenMetadata(response, entityType, source);
	        comscore = buildComscoreMetadata(response, entityType);
	        conviva = buildConvivaMetadata(response, entityType, source);
	        heartbeats = buildHeartbeatMetadata(response, entityType);
	    }
	    var tracking = {};
	    tracking[MediaItemTrackingType$1.nielsen] = nielsen;
	    tracking[MediaItemTrackingType$1.comscore] = comscore;
	    tracking[MediaItemTrackingType$1.conviva] = conviva;
	    tracking[MediaItemTrackingType$1.heartbeats] = heartbeats;
	    return tracking;
	}

	function mediaItemFromGraphQL(response, entityType, options) {
	    var id = response.id, name = response.name, description = response.description, duration = response.duration, image = response.image, eventId = response.eventId, requiresLinearPlayback = response.requiresLinearPlayback, authTypes = response.authTypes, src = response.source, prerollSource = response.prerollSource, packages = response.packages, language = response.language, mrss = response.mrss, seekInSeconds = response.seekInSeconds, tracking = response.tracking, simulcastAiringId = response.simulcastAiringId, network = response.network, status = response.status, cerebroId = response.cerebroId, syndicatable = response.syndicatable;
	    var isLive = status && (status.toUpperCase() === 'LIVE' || status.toUpperCase() === 'OVER');
	    var streamType = isLive ? MediaItemStreamType$1.live : MediaItemStreamType$1.onDemand;
	    var sourceType = (function (authorizationType) {
	        switch (authorizationType) {
	            case 'NONE':
	                return MediaItemSourceType$1.none;
	            case 'START_SESSION':
	                return MediaItemSourceType$1.startSession;
	            case 'BAM':
	                return MediaItemSourceType$1.bam;
	            case 'SHIELD':
	                return MediaItemSourceType$1.shield;
	        }
	    })(src.authorizationType);
	    var source = new MediaItemSource(src.url, sourceType, src.hasEspnId3Heartbeats, src.hasNielsenWatermarks, src.hasPassThroughAds, src.commercialReplacement, src.startSessionUrl);
	    if (options && options.sourceVariant === MediaItemSourceVariant$1.stitchedPreroll && prerollSource) {
	        source = new MediaItemSource(prerollSource.url, MediaItemSourceType$1.none);
	        source.variant = MediaItemSourceVariant$1.stitchedPreroll;
	    }
	    var supportedMediaCommands = requiresLinearPlayback ? MediaItemMediaCommand$1.linearPlayback : MediaItemMediaCommand$1.all;
	    var trackingId = (tracking && tracking.trackingId) || id;
	    var mediaItem = new MediaItem(id, name, duration, language, source);
	    mediaItem.authenticationTypes = authTypes.map(function (item) {
	        switch (item) {
	            case 'DIRECT':
	                return MediaItemAuthenticationType$1.direct;
	            case 'OPEN':
	                return MediaItemAuthenticationType$1.open;
	            case 'MVPD':
	                return MediaItemAuthenticationType$1.mvpd;
	            case 'ISP':
	                return MediaItemAuthenticationType$1.isp;
	            default:
	                return MediaItemAuthenticationType$1.none;
	        }
	    });
	    mediaItem.description = description;
	    mediaItem.isSyndicatable = syndicatable;
	    if (image && image.url) {
	        mediaItem.images.push(new MediaItemImage(image.url));
	    }
	    mediaItem.mrss = mrss;
	    if (network) {
	        var networkType = network.type === 'linear' ? MediaItemNetworkType$1.linear : MediaItemNetworkType$1.event;
	        mediaItem.network = new MediaItemNetwork(network.id, networkType, network.name, network.adobeResource);
	    }
	    mediaItem.seekInSeconds = seekInSeconds;
	    mediaItem.streamType = streamType;
	    mediaItem.supportedMediaCommands = supportedMediaCommands;
	    mediaItem.brand = mediaItem.brand ? mediaItem.brand : 'espn';
	    mediaItem.tracking = buildMediaItemTracking(mediaItem.brand, response, entityType, source);
	    mediaItem.references = {
	        eventId: eventId,
	        simulcastAiringId: simulcastAiringId,
	        trackingId: trackingId,
	        cerebroId: cerebroId,
	    };
	    mediaItem.type = MediaItemType$1.video;
	    mediaItem.entityType = entityType;
	    mediaItem.apiSource = ApiSource$1.graphQL;
	    mediaItem.packages = (packages || []).map(function (pkg) { return new MediaItemPackage(pkg.name); });
	    return mediaItem;
	}

	function sortMediaItems(mediaItems, networkSortOrder, lang) {
	    return mediaItems
	        .sort(function (first, second) {
	        var firstTier = first.tier === 'PRIMARY' ? 0 : first.tier === 'SECONDARY' ? 1 : 2;
	        var secondTier = second.tier === 'PRIMARY' ? 0 : second.tier === 'SECONDARY' ? 1 : 2;
	        if (firstTier < secondTier) {
	            return -1;
	        }
	        if (firstTier > secondTier) {
	            return 1;
	        }
	        return 0;
	    })
	        .sort(function (first, second) {
	        var firstNetwork = (first.network && first.network.id.toLowerCase()) || 'unknown';
	        var secondNetwork = (second.network && second.network.id.toLowerCase()) || 'unknown';
	        var firstNetworkIndex = networkSortOrder.indexOf(firstNetwork);
	        var secondNetworkIndex = networkSortOrder.indexOf(secondNetwork);
	        if (firstNetworkIndex === -1) {
	            firstNetworkIndex = 999;
	        }
	        if (secondNetworkIndex === -1) {
	            secondNetworkIndex = 999;
	        }
	        if (firstNetworkIndex < secondNetworkIndex) {
	            return -1;
	        }
	        if (firstNetworkIndex > secondNetworkIndex) {
	            return 1;
	        }
	        return 0;
	    })
	        .sort(function (first, second) {
	        var firstLanguage = first.language === lang ? 0 : 1;
	        var secondLanguage = second.language === lang ? 0 : 1;
	        if (firstLanguage < secondLanguage) {
	            return -1;
	        }
	        if (firstLanguage < secondLanguage) {
	            return 1;
	        }
	        return 0;
	    });
	}

	var graphQLAiringProps = '{ ' +
	    'id name description mrss:adobeRSS authTypes ' +
	    'requiresLinearPlayback status:type startDateTime endDateTime duration ' +
	    'source(authorization: SHIELD) { url authorizationType hasEspnId3Heartbeats hasNielsenWatermarks hasPassThroughAds commercialReplacement startSessionUrl } ' +
	    'network { id type name adobeResource } ' +
	    'image { url } ' +
	    'sport { name code uid } ' +
	    'league { name uid } ' +
	    'program { code categoryCode isStudio } ' +
	    'seekInSeconds simulcastAiringId airingId ' +
	    'tracking { nielsenCrossId1 trackingId } ' +
	    'eventId ' +
	    'packages { name } ' +
	    'language tier feedName ' +
	    'brands { id name type } ' +
	    '}';
	var graphQLVODProps = '{' +
	    'id name description authTypes language ' +
	    'duration originalPublishDate expirationDate ' +
	    'requiresLinearPlayback lastModifiedDate ' +
	    'source { url authorizationType } ' +
	    'image { url } ' +
	    'tracking { name sportName leagueName } ' +
	    'coverageType ' +
	    'prerollSource:source(variant:PREROLL) { url authorizationType }' +
	    'ad { sport bundle } ' +
	    'links { web } ' +
	    'cerebroId syndicatable' +
	    '}';
	function identifierToUrl(identifier, serviceUrl, apiKey, countryCode) {
	    var queryType = '';
	    var identifierParams = '';
	    var props = '';
	    var country = countryCode || 'US';
	    if (identifier.entityType === MediaItemEntityType$1.shortform) {
	        queryType = 'VOD';
	        props = graphQLVODProps;
	        identifierParams = "id:\"" + identifier.id + "\"";
	    }
	    else {
	        queryType = 'airing';
	        props = graphQLAiringProps;
	        if (identifier.id) {
	            identifierParams = "id:\"" + identifier.id + "\"";
	        }
	        else if (identifier.channel) {
	            queryType = 'airings';
	            identifierParams = "networks:[\"" + identifier.channel + "\"],type:LIVE";
	        }
	        else if (identifier.gameId) {
	            queryType = 'airings';
	            identifierParams = "eventId:\"" + (identifier.eventId || identifier.gameId) + "\"";
	        }
	    }
	    var query = encodeURIComponent("{ " + queryType + "(" + identifierParams + ",countryCode:\"" + country + "\",deviceType:SETTOP,tz:\"Z\") " + props + " }");
	    return serviceUrl + "?apiKey=" + apiKey + "&query=" + query;
	}

	var defaultGraphQLServiceUrl = 'https://watch.graph.api.espn.com/api';
	var defaultGraphQLApiKey = 'd15c5790-7cb0-4fe1-8782-25f4698d0739';
	var defaultGraphQLNetworkSortOrder = [
	    'espn_ppv',
	    'espn_dtc',
	    'espn1',
	    'espn2',
	    'espn3',
	    'espnu',
	    'sec',
	    'espnews',
	    'espndeportes',
	    'longhorn',
	    'goalline',
	    'buzzerbeater',
	    'secplus',
	    'acc',
	    'accextra',
	    'espn_free',
	    'bam_dtc',
	];
	var defaultCfaServiceUrl = 'https://natgeo.entertainment.client.dtci.technology/v1/playback/video/id/mock';
	var Configuration$2 = (function () {
	    function Configuration(apiSource, serviceUrl, apiKey, networkSortOrder) {
	        if (apiSource == ApiSource$1.graphQL) {
	            this.serviceUrl = serviceUrl || defaultGraphQLServiceUrl;
	            this.apiKey = apiKey || defaultGraphQLApiKey;
	            this.networkSortOrder = networkSortOrder || defaultGraphQLNetworkSortOrder;
	        }
	        else if (apiSource == ApiSource$1.cfa) {
	            this.serviceUrl = serviceUrl || defaultCfaServiceUrl;
	        }
	    }
	    return Configuration;
	}());

	var GraphQLMediaItemAPI = (function () {
	    function GraphQLMediaItemAPI() {
	        this.configuration_ = GraphQLMediaItemAPI.defaultConfiguration;
	    }
	    Object.defineProperty(GraphQLMediaItemAPI.prototype, "configuration", {
	        get: function () {
	            return this.configuration_;
	        },
	        set: function (configuration) {
	            this.configuration_ = configuration;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    GraphQLMediaItemAPI.prototype.getMediaItems = function (identifiers, options) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4, GraphQLMediaItemAPI.fetchMediaItems(identifiers, options, this.configuration)];
	                    case 1: return [2, _a.sent()];
	                }
	            });
	        });
	    };
	    GraphQLMediaItemAPI.fetchMediaItems = function (identifiers, options, configuration) {
	        return __awaiter(this, void 0, void 0, function () {
	            var ids, serviceUrl, apiKey, networkSortOrder, promiseMediaItems, mediaItems;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        ids = identifiers.map(function (string) { return new MediaItemIdentifier(string); });
	                        serviceUrl = configuration.serviceUrl, apiKey = configuration.apiKey, networkSortOrder = configuration.networkSortOrder;
	                        return [4, Promise.all(ids.map(function (id) { return GraphQLMediaItemAPI.getPromiseMediaItems(id, serviceUrl, apiKey, options); }))];
	                    case 1:
	                        promiseMediaItems = _a.sent();
	                        mediaItems = promiseMediaItems.filter(function (result) { return !(result instanceof Error) && result instanceof MediaItem; });
	                        if (mediaItems.length) {
	                            return [2, sortMediaItems(mediaItems, networkSortOrder, navigator.language)];
	                        }
	                        return [2, null];
	                }
	            });
	        });
	    };
	    GraphQLMediaItemAPI.getPromiseMediaItems = function (identifier, serviceUrl, apiKey, options) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, response, json, airing, airings, filter, vod, obj, mediaItem, isOver, isLinear, networkId, error_1;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = identifierToUrl(identifier, serviceUrl, apiKey, options.countryCode);
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 4, , 5]);
	                        return [4, fetch(url)];
	                    case 2:
	                        response = _a.sent();
	                        return [4, response.json()];
	                    case 3:
	                        json = _a.sent();
	                        airing = json.data.airing;
	                        airings = json.data.airings;
	                        if (airings) {
	                            filter = identifier.simulcastAiringId
	                                ? function (airing) { return airing.simulcastAiringId === identifier.simulcastAiringId; }
	                                : function () { return true; };
	                            airing = airings.filter(filter)[0];
	                        }
	                        vod = json.data.VOD;
	                        obj = airing || vod;
	                        if (!obj) {
	                            throw new Error('No results found.');
	                        }
	                        mediaItem = mediaItemFromGraphQL(obj, identifier.entityType, options);
	                        if (identifier.resumeTime) {
	                            mediaItem.seekInSeconds = identifier.resumeTime;
	                        }
	                        if (!mediaItem.source.url) {
	                            isOver = obj.status.toUpperCase() === 'OVER';
	                            isLinear = obj.network && obj.network.type === MediaItemNetworkType$1.linear;
	                            networkId = obj.network && obj.network.id;
	                            if (isOver && isLinear && networkId) {
	                                return [2, GraphQLMediaItemAPI.retryGetMediaItems(networkId, serviceUrl, apiKey, options)];
	                            }
	                            throw new Error('No playable url');
	                        }
	                        return [2, mediaItem];
	                    case 4:
	                        error_1 = _a.sent();
	                        loglevel.warn("Failed to retrieve MediaItem from GraphQL: " + error_1);
	                        return [2, null];
	                    case 5: return [2];
	                }
	            });
	        });
	    };
	    GraphQLMediaItemAPI.retryGetMediaItems = function (networkId, serviceUrl, apiKey, options) {
	        return __awaiter(this, void 0, void 0, function () {
	            var identifierString, identifier, mediaItem, error_2;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        _a.trys.push([0, 2, , 3]);
	                        identifierString = MediaItemIdentifier.identifierStringForNetwork(networkId, ApiSource$1.graphQL);
	                        identifier = new MediaItemIdentifier(identifierString);
	                        return [4, GraphQLMediaItemAPI.getPromiseMediaItems(identifier, serviceUrl, apiKey, options)];
	                    case 1:
	                        mediaItem = _a.sent();
	                        if (mediaItem && mediaItem instanceof MediaItem === true) {
	                            return [2, mediaItem];
	                        }
	                        throw new Error("Retry fetchMediaItems failed with " + networkId);
	                    case 2:
	                        error_2 = _a.sent();
	                        loglevel.warn("MediaItem is over and retry failed: " + error_2);
	                        return [2, null];
	                    case 3: return [2];
	                }
	            });
	        });
	    };
	    GraphQLMediaItemAPI.defaultConfiguration = new Configuration$2(ApiSource$1.graphQL);
	    return GraphQLMediaItemAPI;
	}());

	function mediaItemFromCFA(response) {
	    var id = response.id, title = response.title, description = response.description, duration = response.duration, src = response.source, type = response.type, entityType = response.entityType, streamType = response.streamType, authenticationTypes = response.authenticationTypes, language = response.language, network = response.network, brand = response.brand, images = response.images;
	    var entity = entityType;
	    var sourceType = src.type;
	    var source = new MediaItemSource(src.url, sourceType);
	    var mediaItem = new MediaItem(id, title, duration, language, source);
	    mediaItem.authenticationTypes = authenticationTypes.map(function (item) {
	        switch (item) {
	            case 'DIRECT':
	                return MediaItemAuthenticationType$1.direct;
	            case 'OPEN':
	                return MediaItemAuthenticationType$1.open;
	            case 'MVPD':
	                return MediaItemAuthenticationType$1.mvpd;
	            case 'ISP':
	                return MediaItemAuthenticationType$1.isp;
	            default:
	                return MediaItemAuthenticationType$1.none;
	        }
	    });
	    mediaItem.description = description;
	    if (network) {
	        mediaItem.network = new MediaItemNetwork(network.id, network.type, network.name, network.resource);
	    }
	    mediaItem.streamType = streamType;
	    mediaItem.brand = brand;
	    mediaItem.tracking = buildMediaItemTracking(mediaItem.brand, response, entity, source);
	    mediaItem.images = images;
	    mediaItem.type = type;
	    mediaItem.entityType = entity;
	    mediaItem.apiSource = ApiSource$1.cfa;
	    return mediaItem;
	}

	var CFAMediaItemAPI = (function () {
	    function CFAMediaItemAPI() {
	        this.configuration_ = CFAMediaItemAPI.defaultConfiguration;
	    }
	    Object.defineProperty(CFAMediaItemAPI.prototype, "configuration", {
	        get: function () {
	            return this.configuration_;
	        },
	        set: function (configuration) {
	            this.configuration_ = configuration;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    CFAMediaItemAPI.prototype.getMediaItems = function (identifiers, options) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4, CFAMediaItemAPI.fetchMediaItems(identifiers, options, this.configuration)];
	                    case 1: return [2, _a.sent()];
	                }
	            });
	        });
	    };
	    CFAMediaItemAPI.fetchMediaItems = function (identifiers, options, configuration) {
	        return __awaiter(this, void 0, void 0, function () {
	            var ids, serviceUrl, promiseMediaItems;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        ids = identifiers.map(function (string) { return new MediaItemIdentifier(string); });
	                        serviceUrl = configuration.serviceUrl;
	                        return [4, Promise.all(ids.map(function (id) { return CFAMediaItemAPI.getPromiseMediaItem(id, serviceUrl); }))];
	                    case 1:
	                        promiseMediaItems = _a.sent();
	                        return [2, promiseMediaItems.filter(function (result) { return !(result instanceof Error) && result instanceof MediaItem; })];
	                }
	            });
	        });
	    };
	    CFAMediaItemAPI.getPromiseMediaItem = function (identifier, serviceUrl) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, response, json, mediaItem, error_1;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = serviceUrl.replace('videoID', identifier.id);
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 4, , 5]);
	                        return [4, fetch(url)];
	                    case 2:
	                        response = _a.sent();
	                        return [4, response.json()];
	                    case 3:
	                        json = _a.sent();
	                        mediaItem = mediaItemFromCFA(json);
	                        return [2, mediaItem];
	                    case 4:
	                        error_1 = _a.sent();
	                        loglevel.warn("Failed to retrieve MediaItem from CFA: " + error_1);
	                        return [2, null];
	                    case 5: return [2];
	                }
	            });
	        });
	    };
	    CFAMediaItemAPI.defaultConfiguration = new Configuration$2(ApiSource$1.cfa);
	    return CFAMediaItemAPI;
	}());

	var UniversalMediaItemAPI = (function () {
	    function UniversalMediaItemAPI() {
	    }
	    Object.defineProperty(UniversalMediaItemAPI.prototype, "configuration", {
	        get: function () {
	            return this.configuration_;
	        },
	        set: function (configuration) {
	            this.configuration_ = configuration;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    UniversalMediaItemAPI.prototype.getMediaItems = function (identifiers, options) {
	        return __awaiter(this, void 0, void 0, function () {
	            var opts, api, api;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        opts = options || { sourceVariant: null };
	                        if (!identifiers[0].match('natgeo')) return [3, 2];
	                        api = new CFAMediaItemAPI();
	                        api.configuration = this.configuration || api.configuration;
	                        return [4, api.getMediaItems(identifiers, opts)];
	                    case 1: return [2, _a.sent()];
	                    case 2:
	                        api = new GraphQLMediaItemAPI();
	                        api.configuration = this.configuration || api.configuration;
	                        return [4, api.getMediaItems(identifiers, opts)];
	                    case 3: return [2, _a.sent()];
	                }
	            });
	        });
	    };
	    return UniversalMediaItemAPI;
	}());

	var Configuration$1 = (function () {
	    function Configuration(serviceUrl, appVersion) {
	        this.serviceUrl = serviceUrl;
	        this.appVersion = appVersion;
	    }
	    return Configuration;
	}());
	var defaultServiceUrl$2 = 'https://prod.gatekeeper.us-abc.symphony.edgedatg.com/api/ws/pluto/v1/layout';
	var defaultAppVersion$1 = '1.0.0';
	var defaultConfiguration$1 = new Configuration$1(defaultServiceUrl$2, defaultAppVersion$1);

	var PlutoAPI = (function () {
	    function PlutoAPI(configuration) {
	        if (configuration === void 0) { configuration = defaultConfiguration$1; }
	        this.configuration_ = configuration;
	    }
	    PlutoAPI.prototype.getMediaItems = function (identifiers, options) {
	        return __awaiter(this, void 0, void 0, function () {
	            var _this = this;
	            return __generator(this, function (_a) {
	                return [2, Promise.all(identifiers.map(function (id) { return _this.getMediaItem(id, options); }))];
	            });
	        });
	    };
	    PlutoAPI.prototype.getMediaItem = function (identifier, options) {
	        return __awaiter(this, void 0, void 0, function () {
	            var layoutURL, layoutResponse, videoPlayerModuleResource, videoPlayer, mediaItem;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        layoutURL = this.getLayoutURLFromParams(__assign(__assign({}, options), { identifier: identifier }));
	                        return [4, this.getLayout(layoutURL)];
	                    case 1:
	                        layoutResponse = _a.sent();
	                        videoPlayerModuleResource = layoutResponse.modules.filter(function (module) {
	                            return module.type == 'videoplayer';
	                        })[0];
	                        if (!videoPlayerModuleResource) {
	                            throw new Error('Layout is missing Video Player module');
	                        }
	                        if (options.type === 'live_player') {
	                            videoPlayerModuleResource.resource = videoPlayerModuleResource.resource.replace('{affiliate}', identifier);
	                        }
	                        return [4, this.getVideoPlayerModule(videoPlayerModuleResource.resource)];
	                    case 2:
	                        videoPlayer = _a.sent();
	                        mediaItem = this.getMediaItemFromVideoPlayer(videoPlayer);
	                        return [2, mediaItem];
	                }
	            });
	        });
	    };
	    PlutoAPI.prototype.getLayoutURLFromParams = function (params) {
	        if (!params.brand || !params.device || !params.type) {
	            throw new Error('Cannot create layout url, missing parameters');
	        }
	        var queryParameters = {
	            brand: params.brand,
	            device: params.device,
	        };
	        if (params.type == 'vod_player') {
	            if (!params.identifier) {
	                throw new Error('Cannot create layout url, missing video id');
	            }
	            queryParameters['type'] = 'vod_player';
	            queryParameters['video'] = params.identifier;
	        }
	        if (params.type == 'live_player') {
	            queryParameters['type'] = 'live_player';
	            queryParameters['authlevel'] = '1';
	            queryParameters['affiliate'] = params.identifier || '';
	            params.channel ? (queryParameters['channel'] = params.channel) : null;
	            params.video ? (queryParameters['video'] = params.video) : null;
	        }
	        var query = Object.keys(queryParameters)
	            .map(function (key) { return key + '=' + (queryParameters[key] || ''); })
	            .join('&');
	        var sep = this.configuration_.serviceUrl.indexOf('?') === -1 ? '?' : '&';
	        return "" + this.configuration_.serviceUrl + sep + query;
	    };
	    PlutoAPI.prototype.getMediaItemFromVideoPlayer = function (videoPlayerResponse) {
	        if (videoPlayerResponse.video) {
	            return this.getMediaItemForVOD(videoPlayerResponse);
	        }
	        else if (videoPlayerResponse.channels) {
	            return this.getMediaItemForChannel(videoPlayerResponse);
	        }
	    };
	    PlutoAPI.prototype.getMediaItemForChannel = function (videoPlayerResponse) {
	        var _a;
	        if (videoPlayerResponse.channels.length == 0) {
	            throw new Error('Live video player module has no channels');
	        }
	        var channel = videoPlayerResponse.channels[0];
	        var mediaItem = new MediaItem(channel.id, channel.title, 0, 'en', null);
	        mediaItem.description = channel.description;
	        mediaItem.authenticationTypes =
	            channel.accesslevel == '0' ? [MediaItemAuthenticationType$1.none] : [MediaItemAuthenticationType$1.mvpd];
	        var brand = getBrandFromString(channel.brand);
	        mediaItem.brand = brand;
	        mediaItem.mrss = this.getAdobeMRSS(mediaItem.id, mediaItem.title, brandResourceId(brand), channel.tvrating);
	        mediaItem.streamType = MediaItemStreamType$1.live;
	        mediaItem.type = MediaItemType$1.video;
	        mediaItem.apiSource = ApiSource$1.pluto;
	        mediaItem.availableDate = channel.availdate;
	        mediaItem.network = new MediaItemNetwork(channel.aff, MediaItemNetworkType$1.linear, channel.title, brandResourceId(brand));
	        mediaItem.images = (_a = channel.previews) === null || _a === void 0 ? void 0 : _a.map(function (image) {
	            return new MediaItemImage(image.value);
	        });
	        return mediaItem;
	    };
	    PlutoAPI.prototype.getMediaItemForVOD = function (videoPlayerResponse) {
	        var mediaItem = new MediaItem(videoPlayerResponse.video.id, videoPlayerResponse.video.title, videoPlayerResponse.video.duration, videoPlayerResponse.video.show.language, null);
	        mediaItem.description = videoPlayerResponse.video.description;
	        mediaItem.authenticationTypes =
	            videoPlayerResponse.video.accesslevel == '0' ? [MediaItemAuthenticationType$1.none] : [MediaItemAuthenticationType$1.mvpd];
	        var brand = getBrandFromString(videoPlayerResponse.video.brand);
	        mediaItem.brand = brand;
	        mediaItem.mrss = this.getAdobeMRSS(mediaItem.id, mediaItem.title, brandResourceId(brand), videoPlayerResponse.video.rating.value);
	        mediaItem.show = videoPlayerResponse.video.show;
	        mediaItem.cues = videoPlayerResponse.video.cues;
	        mediaItem.adTarget = videoPlayerResponse.video.adTarget;
	        mediaItem.adUnitId = videoPlayerResponse.adUnitId;
	        mediaItem.streamType = MediaItemStreamType$1.onDemand;
	        mediaItem.type = MediaItemType$1.video;
	        mediaItem.apiSource = ApiSource$1.pluto;
	        mediaItem.entityType = videoPlayerResponse.video.type == 'lf' ? MediaItemEntityType$1.longform : MediaItemEntityType$1.shortform;
	        mediaItem.seasonNumber = videoPlayerResponse.video.seasonnumber;
	        mediaItem.episodeNumber = videoPlayerResponse.video.episodenumber;
	        mediaItem.videoShowGenre = videoPlayerResponse.video.show.genre;
	        mediaItem.tmsid = videoPlayerResponse.video.tmsid;
	        mediaItem.availableDate = videoPlayerResponse.video.availableDate;
	        mediaItem.airDate = videoPlayerResponse.video.displayAirtime;
	        mediaItem.images = videoPlayerResponse.images.map(function (image) {
	            return new MediaItemImage(image.value);
	        });
	        return mediaItem;
	    };
	    PlutoAPI.prototype.getLayout = function (url) {
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, options;
	            return __generator(this, function (_a) {
	                headers = {
	                    appversion: this.configuration_.appVersion,
	                };
	                options = {
	                    headers: headers,
	                };
	                return [2, fetch(url, options)
	                        .then(function (response) {
	                        if (!response.ok) {
	                            throw response;
	                        }
	                        return response.json();
	                    })
	                        .then(function (json) {
	                        return json;
	                    })];
	            });
	        });
	    };
	    PlutoAPI.prototype.getVideoPlayerModule = function (url) {
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, options;
	            return __generator(this, function (_a) {
	                headers = {
	                    appversion: this.configuration_.appVersion,
	                };
	                options = {
	                    headers: headers,
	                };
	                return [2, fetch(url, options)
	                        .then(function (response) {
	                        if (!response.ok) {
	                            throw response;
	                        }
	                        return response.json();
	                    })
	                        .then(function (json) {
	                        return json;
	                    })];
	            });
	        });
	    };
	    PlutoAPI.prototype.getAdobeMRSS = function (mediaId, mediaTitle, resourceId, mediaRating) {
	        var urn = 'urn:mpaa';
	        if (!mediaRating || mediaRating.length === 0) {
	            mediaRating = 'TV-Y';
	        }
	        if (mediaRating.indexOf('TV-') === 0) {
	            urn = 'urn:v-chip';
	        }
	        var sanitizedMediaId = this.xmlSanitize(mediaId);
	        var sanitizedMediaTitle = this.xmlSanitize(mediaTitle);
	        var sanitizedResourceId = this.xmlSanitize(resourceId);
	        var sanitizedUrn = this.xmlSanitize(urn);
	        var sanitizedMediaRating = this.xmlSanitize(mediaRating);
	        var resource = '<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel>';
	        resource += '<title>' + sanitizedResourceId + '</title>';
	        resource += '<item>';
	        resource += '<title><![CDATA[' + sanitizedMediaTitle + ']]></title>';
	        resource += '<guid>' + sanitizedMediaId + '</guid>';
	        resource += '<media:rating scheme="' + sanitizedUrn + '">' + sanitizedMediaRating + '</media:rating>';
	        resource += '</item></channel></rss>';
	        return resource;
	    };
	    PlutoAPI.prototype.xmlSanitize = function (string) {
	        var xmlString = string.replace('&', '&amp;');
	        xmlString = xmlString.replace('<', '&lt;');
	        xmlString = xmlString.replace('>', '&gt;');
	        xmlString = xmlString.replace('"', '&quot;');
	        xmlString = xmlString.replace("'", '&apos;');
	        return xmlString;
	    };
	    return PlutoAPI;
	}());

	var PlaybackConfig = (function () {
	    function PlaybackConfig(contentType, keySystem, licenseUrl) {
	        this.contentType = contentType;
	        this.keySystem = keySystem;
	        this.licenseUrl = licenseUrl;
	    }
	    return PlaybackConfig;
	}());

	var PlaybackSession = (function () {
	    function PlaybackSession(playbackUrl) {
	        this.playbackUrl = playbackUrl;
	        this.textTracks = [];
	    }
	    Object.defineProperty(PlaybackSession.prototype, "convivaContentMetadata", {
	        get: function () {
	            var custom = {
	                accessType: null,
	                mvpd: null,
	            };
	            if (this.authenticationType) {
	                custom.accessType = (this.authenticationType && this.authenticationType.toLowerCase()) || 'free';
	                if (this.authenticatedProvider && this.authenticationType === MediaItemAuthenticationType$1.mvpd) {
	                    custom.mvpd = this.authenticatedProvider.id;
	                }
	            }
	            var mediaItemMetadata = (this.mediaItem && this.mediaItem.tracking[MediaItemTrackingType$1.conviva]) || {};
	            var metadata = {
	                streamUrl: this.playbackUrl,
	                custom: Object.assign(mediaItemMetadata.custom || {}, custom),
	            };
	            return Object.assign(mediaItemMetadata, metadata);
	        },
	        enumerable: false,
	        configurable: true
	    });
	    PlaybackSession.prototype.toString = function () {
	        return ("<PlaybackSession playbackUrl:" + this.playbackUrl + ", " +
	            ("authenticationType:" + this.authenticationType + ", ") +
	            ("authenticatedProvider:" + this.authenticatedProvider + ">"));
	    };
	    return PlaybackSession;
	}());

	var DRMKeySystem;
	(function (DRMKeySystem) {
	    DRMKeySystem["none"] = "none";
	    DRMKeySystem["fairPlay"] = "fairplay";
	    DRMKeySystem["playReady"] = "playready";
	    DRMKeySystem["widevine"] = "widevine";
	})(DRMKeySystem || (DRMKeySystem = {}));
	var DRMKeySystem$1 = DRMKeySystem;

	var DRMSupport;
	(function (DRMSupport) {
	    DRMSupport["none"] = "HLS";
	    DRMSupport["hlsFairplay"] = "HLS_FAIRPLAY";
	    DRMSupport["dashPlayReady"] = "DASH_PLAYREADY";
	    DRMSupport["dashWidevine"] = "DASH_WIDEVINE";
	})(DRMSupport || (DRMSupport = {}));
	var DRMSupport$1 = DRMSupport;

	var appendKeyValueToUrl = function appendParamToUrl(key, value, url) {
	    var sep = url.indexOf('?') === -1 ? '?' : '&';
	    return url + sep + key + "=" + encodeURIComponent(value);
	};
	var ClipPlaybackSessionFactory = (function () {
	    function ClipPlaybackSessionFactory() {
	    }
	    ClipPlaybackSessionFactory.prototype.initPlaybackSession = function (mediaItem, advertisingInfo, authorizationPayload) {
	        var playbackUrl = mediaItem.source.url;
	        if (mediaItem.source.variant === MediaItemSourceVariant$1.stitchedPreroll) {
	            var adInfoDictionary_1 = advertisingInfo.dictionaryForBrightcove();
	            Object.keys(adInfoDictionary_1).forEach(function (key) {
	                playbackUrl = appendKeyValueToUrl(key, adInfoDictionary_1[key].toString(), playbackUrl);
	            });
	        }
	        loglevel.debug(playbackUrl, mediaItem);
	        var session = new PlaybackSession(playbackUrl);
	        session.mediaItem = mediaItem;
	        session.seekToTime = mediaItem.seekInSeconds;
	        session.authenticationType = authorizationPayload.authenticationType;
	        session.authenticatedProvider = authorizationPayload.authenticatedProvider;
	        session.authenticatedIdentity = authorizationPayload.authenticatedIdentity;
	        return Promise.resolve(session);
	    };
	    return ClipPlaybackSessionFactory;
	}());

	var core = createCommonjsModule(function (module, exports) {
	(function (root, factory) {
		{
			// CommonJS
			module.exports = factory();
		}
	}(commonjsGlobal, function () {

		/**
		 * CryptoJS core components.
		 */
		var CryptoJS = CryptoJS || (function (Math, undefined$1) {
		    /*
		     * Local polyfil of Object.create
		     */
		    var create = Object.create || (function () {
		        function F() {}
		        return function (obj) {
		            var subtype;

		            F.prototype = obj;

		            subtype = new F();

		            F.prototype = null;

		            return subtype;
		        };
		    }());

		    /**
		     * CryptoJS namespace.
		     */
		    var C = {};

		    /**
		     * Library namespace.
		     */
		    var C_lib = C.lib = {};

		    /**
		     * Base object for prototypal inheritance.
		     */
		    var Base = C_lib.Base = (function () {


		        return {
		            /**
		             * Creates a new object that inherits from this object.
		             *
		             * @param {Object} overrides Properties to copy into the new object.
		             *
		             * @return {Object} The new object.
		             *
		             * @static
		             *
		             * @example
		             *
		             *     var MyType = CryptoJS.lib.Base.extend({
		             *         field: 'value',
		             *
		             *         method: function () {
		             *         }
		             *     });
		             */
		            extend: function (overrides) {
		                // Spawn
		                var subtype = create(this);

		                // Augment
		                if (overrides) {
		                    subtype.mixIn(overrides);
		                }

		                // Create default initializer
		                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
		                    subtype.init = function () {
		                        subtype.$super.init.apply(this, arguments);
		                    };
		                }

		                // Initializer's prototype is the subtype object
		                subtype.init.prototype = subtype;

		                // Reference supertype
		                subtype.$super = this;

		                return subtype;
		            },

		            /**
		             * Extends this object and runs the init method.
		             * Arguments to create() will be passed to init().
		             *
		             * @return {Object} The new object.
		             *
		             * @static
		             *
		             * @example
		             *
		             *     var instance = MyType.create();
		             */
		            create: function () {
		                var instance = this.extend();
		                instance.init.apply(instance, arguments);

		                return instance;
		            },

		            /**
		             * Initializes a newly created object.
		             * Override this method to add some logic when your objects are created.
		             *
		             * @example
		             *
		             *     var MyType = CryptoJS.lib.Base.extend({
		             *         init: function () {
		             *             // ...
		             *         }
		             *     });
		             */
		            init: function () {
		            },

		            /**
		             * Copies properties into this object.
		             *
		             * @param {Object} properties The properties to mix in.
		             *
		             * @example
		             *
		             *     MyType.mixIn({
		             *         field: 'value'
		             *     });
		             */
		            mixIn: function (properties) {
		                for (var propertyName in properties) {
		                    if (properties.hasOwnProperty(propertyName)) {
		                        this[propertyName] = properties[propertyName];
		                    }
		                }

		                // IE won't copy toString using the loop above
		                if (properties.hasOwnProperty('toString')) {
		                    this.toString = properties.toString;
		                }
		            },

		            /**
		             * Creates a copy of this object.
		             *
		             * @return {Object} The clone.
		             *
		             * @example
		             *
		             *     var clone = instance.clone();
		             */
		            clone: function () {
		                return this.init.prototype.extend(this);
		            }
		        };
		    }());

		    /**
		     * An array of 32-bit words.
		     *
		     * @property {Array} words The array of 32-bit words.
		     * @property {number} sigBytes The number of significant bytes in this word array.
		     */
		    var WordArray = C_lib.WordArray = Base.extend({
		        /**
		         * Initializes a newly created word array.
		         *
		         * @param {Array} words (Optional) An array of 32-bit words.
		         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
		         *
		         * @example
		         *
		         *     var wordArray = CryptoJS.lib.WordArray.create();
		         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
		         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
		         */
		        init: function (words, sigBytes) {
		            words = this.words = words || [];

		            if (sigBytes != undefined$1) {
		                this.sigBytes = sigBytes;
		            } else {
		                this.sigBytes = words.length * 4;
		            }
		        },

		        /**
		         * Converts this word array to a string.
		         *
		         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
		         *
		         * @return {string} The stringified word array.
		         *
		         * @example
		         *
		         *     var string = wordArray + '';
		         *     var string = wordArray.toString();
		         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
		         */
		        toString: function (encoder) {
		            return (encoder || Hex).stringify(this);
		        },

		        /**
		         * Concatenates a word array to this word array.
		         *
		         * @param {WordArray} wordArray The word array to append.
		         *
		         * @return {WordArray} This word array.
		         *
		         * @example
		         *
		         *     wordArray1.concat(wordArray2);
		         */
		        concat: function (wordArray) {
		            // Shortcuts
		            var thisWords = this.words;
		            var thatWords = wordArray.words;
		            var thisSigBytes = this.sigBytes;
		            var thatSigBytes = wordArray.sigBytes;

		            // Clamp excess bits
		            this.clamp();

		            // Concat
		            if (thisSigBytes % 4) {
		                // Copy one byte at a time
		                for (var i = 0; i < thatSigBytes; i++) {
		                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
		                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
		                }
		            } else {
		                // Copy one word at a time
		                for (var i = 0; i < thatSigBytes; i += 4) {
		                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
		                }
		            }
		            this.sigBytes += thatSigBytes;

		            // Chainable
		            return this;
		        },

		        /**
		         * Removes insignificant bits.
		         *
		         * @example
		         *
		         *     wordArray.clamp();
		         */
		        clamp: function () {
		            // Shortcuts
		            var words = this.words;
		            var sigBytes = this.sigBytes;

		            // Clamp
		            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
		            words.length = Math.ceil(sigBytes / 4);
		        },

		        /**
		         * Creates a copy of this word array.
		         *
		         * @return {WordArray} The clone.
		         *
		         * @example
		         *
		         *     var clone = wordArray.clone();
		         */
		        clone: function () {
		            var clone = Base.clone.call(this);
		            clone.words = this.words.slice(0);

		            return clone;
		        },

		        /**
		         * Creates a word array filled with random bytes.
		         *
		         * @param {number} nBytes The number of random bytes to generate.
		         *
		         * @return {WordArray} The random word array.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var wordArray = CryptoJS.lib.WordArray.random(16);
		         */
		        random: function (nBytes) {
		            var words = [];

		            var r = (function (m_w) {
		                var m_w = m_w;
		                var m_z = 0x3ade68b1;
		                var mask = 0xffffffff;

		                return function () {
		                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
		                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
		                    var result = ((m_z << 0x10) + m_w) & mask;
		                    result /= 0x100000000;
		                    result += 0.5;
		                    return result * (Math.random() > .5 ? 1 : -1);
		                }
		            });

		            for (var i = 0, rcache; i < nBytes; i += 4) {
		                var _r = r((rcache || Math.random()) * 0x100000000);

		                rcache = _r() * 0x3ade67b7;
		                words.push((_r() * 0x100000000) | 0);
		            }

		            return new WordArray.init(words, nBytes);
		        }
		    });

		    /**
		     * Encoder namespace.
		     */
		    var C_enc = C.enc = {};

		    /**
		     * Hex encoding strategy.
		     */
		    var Hex = C_enc.Hex = {
		        /**
		         * Converts a word array to a hex string.
		         *
		         * @param {WordArray} wordArray The word array.
		         *
		         * @return {string} The hex string.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
		         */
		        stringify: function (wordArray) {
		            // Shortcuts
		            var words = wordArray.words;
		            var sigBytes = wordArray.sigBytes;

		            // Convert
		            var hexChars = [];
		            for (var i = 0; i < sigBytes; i++) {
		                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
		                hexChars.push((bite >>> 4).toString(16));
		                hexChars.push((bite & 0x0f).toString(16));
		            }

		            return hexChars.join('');
		        },

		        /**
		         * Converts a hex string to a word array.
		         *
		         * @param {string} hexStr The hex string.
		         *
		         * @return {WordArray} The word array.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
		         */
		        parse: function (hexStr) {
		            // Shortcut
		            var hexStrLength = hexStr.length;

		            // Convert
		            var words = [];
		            for (var i = 0; i < hexStrLength; i += 2) {
		                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
		            }

		            return new WordArray.init(words, hexStrLength / 2);
		        }
		    };

		    /**
		     * Latin1 encoding strategy.
		     */
		    var Latin1 = C_enc.Latin1 = {
		        /**
		         * Converts a word array to a Latin1 string.
		         *
		         * @param {WordArray} wordArray The word array.
		         *
		         * @return {string} The Latin1 string.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
		         */
		        stringify: function (wordArray) {
		            // Shortcuts
		            var words = wordArray.words;
		            var sigBytes = wordArray.sigBytes;

		            // Convert
		            var latin1Chars = [];
		            for (var i = 0; i < sigBytes; i++) {
		                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
		                latin1Chars.push(String.fromCharCode(bite));
		            }

		            return latin1Chars.join('');
		        },

		        /**
		         * Converts a Latin1 string to a word array.
		         *
		         * @param {string} latin1Str The Latin1 string.
		         *
		         * @return {WordArray} The word array.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
		         */
		        parse: function (latin1Str) {
		            // Shortcut
		            var latin1StrLength = latin1Str.length;

		            // Convert
		            var words = [];
		            for (var i = 0; i < latin1StrLength; i++) {
		                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
		            }

		            return new WordArray.init(words, latin1StrLength);
		        }
		    };

		    /**
		     * UTF-8 encoding strategy.
		     */
		    var Utf8 = C_enc.Utf8 = {
		        /**
		         * Converts a word array to a UTF-8 string.
		         *
		         * @param {WordArray} wordArray The word array.
		         *
		         * @return {string} The UTF-8 string.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
		         */
		        stringify: function (wordArray) {
		            try {
		                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
		            } catch (e) {
		                throw new Error('Malformed UTF-8 data');
		            }
		        },

		        /**
		         * Converts a UTF-8 string to a word array.
		         *
		         * @param {string} utf8Str The UTF-8 string.
		         *
		         * @return {WordArray} The word array.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
		         */
		        parse: function (utf8Str) {
		            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
		        }
		    };

		    /**
		     * Abstract buffered block algorithm template.
		     *
		     * The property blockSize must be implemented in a concrete subtype.
		     *
		     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
		     */
		    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
		        /**
		         * Resets this block algorithm's data buffer to its initial state.
		         *
		         * @example
		         *
		         *     bufferedBlockAlgorithm.reset();
		         */
		        reset: function () {
		            // Initial values
		            this._data = new WordArray.init();
		            this._nDataBytes = 0;
		        },

		        /**
		         * Adds new data to this block algorithm's buffer.
		         *
		         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
		         *
		         * @example
		         *
		         *     bufferedBlockAlgorithm._append('data');
		         *     bufferedBlockAlgorithm._append(wordArray);
		         */
		        _append: function (data) {
		            // Convert string to WordArray, else assume WordArray already
		            if (typeof data == 'string') {
		                data = Utf8.parse(data);
		            }

		            // Append
		            this._data.concat(data);
		            this._nDataBytes += data.sigBytes;
		        },

		        /**
		         * Processes available data blocks.
		         *
		         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
		         *
		         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
		         *
		         * @return {WordArray} The processed data.
		         *
		         * @example
		         *
		         *     var processedData = bufferedBlockAlgorithm._process();
		         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
		         */
		        _process: function (doFlush) {
		            // Shortcuts
		            var data = this._data;
		            var dataWords = data.words;
		            var dataSigBytes = data.sigBytes;
		            var blockSize = this.blockSize;
		            var blockSizeBytes = blockSize * 4;

		            // Count blocks ready
		            var nBlocksReady = dataSigBytes / blockSizeBytes;
		            if (doFlush) {
		                // Round up to include partial blocks
		                nBlocksReady = Math.ceil(nBlocksReady);
		            } else {
		                // Round down to include only full blocks,
		                // less the number of blocks that must remain in the buffer
		                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
		            }

		            // Count words ready
		            var nWordsReady = nBlocksReady * blockSize;

		            // Count bytes ready
		            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

		            // Process blocks
		            if (nWordsReady) {
		                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
		                    // Perform concrete-algorithm logic
		                    this._doProcessBlock(dataWords, offset);
		                }

		                // Remove processed words
		                var processedWords = dataWords.splice(0, nWordsReady);
		                data.sigBytes -= nBytesReady;
		            }

		            // Return processed words
		            return new WordArray.init(processedWords, nBytesReady);
		        },

		        /**
		         * Creates a copy of this object.
		         *
		         * @return {Object} The clone.
		         *
		         * @example
		         *
		         *     var clone = bufferedBlockAlgorithm.clone();
		         */
		        clone: function () {
		            var clone = Base.clone.call(this);
		            clone._data = this._data.clone();

		            return clone;
		        },

		        _minBufferSize: 0
		    });

		    /**
		     * Abstract hasher template.
		     *
		     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
		     */
		    C_lib.Hasher = BufferedBlockAlgorithm.extend({
		        /**
		         * Configuration options.
		         */
		        cfg: Base.extend(),

		        /**
		         * Initializes a newly created hasher.
		         *
		         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
		         *
		         * @example
		         *
		         *     var hasher = CryptoJS.algo.SHA256.create();
		         */
		        init: function (cfg) {
		            // Apply config defaults
		            this.cfg = this.cfg.extend(cfg);

		            // Set initial values
		            this.reset();
		        },

		        /**
		         * Resets this hasher to its initial state.
		         *
		         * @example
		         *
		         *     hasher.reset();
		         */
		        reset: function () {
		            // Reset data buffer
		            BufferedBlockAlgorithm.reset.call(this);

		            // Perform concrete-hasher logic
		            this._doReset();
		        },

		        /**
		         * Updates this hasher with a message.
		         *
		         * @param {WordArray|string} messageUpdate The message to append.
		         *
		         * @return {Hasher} This hasher.
		         *
		         * @example
		         *
		         *     hasher.update('message');
		         *     hasher.update(wordArray);
		         */
		        update: function (messageUpdate) {
		            // Append
		            this._append(messageUpdate);

		            // Update the hash
		            this._process();

		            // Chainable
		            return this;
		        },

		        /**
		         * Finalizes the hash computation.
		         * Note that the finalize operation is effectively a destructive, read-once operation.
		         *
		         * @param {WordArray|string} messageUpdate (Optional) A final message update.
		         *
		         * @return {WordArray} The hash.
		         *
		         * @example
		         *
		         *     var hash = hasher.finalize();
		         *     var hash = hasher.finalize('message');
		         *     var hash = hasher.finalize(wordArray);
		         */
		        finalize: function (messageUpdate) {
		            // Final message update
		            if (messageUpdate) {
		                this._append(messageUpdate);
		            }

		            // Perform concrete-hasher logic
		            var hash = this._doFinalize();

		            return hash;
		        },

		        blockSize: 512/32,

		        /**
		         * Creates a shortcut function to a hasher's object interface.
		         *
		         * @param {Hasher} hasher The hasher to create a helper for.
		         *
		         * @return {Function} The shortcut function.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
		         */
		        _createHelper: function (hasher) {
		            return function (message, cfg) {
		                return new hasher.init(cfg).finalize(message);
		            };
		        },

		        /**
		         * Creates a shortcut function to the HMAC's object interface.
		         *
		         * @param {Hasher} hasher The hasher to use in this HMAC helper.
		         *
		         * @return {Function} The shortcut function.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
		         */
		        _createHmacHelper: function (hasher) {
		            return function (message, key) {
		                return new C_algo.HMAC.init(hasher, key).finalize(message);
		            };
		        }
		    });

		    /**
		     * Algorithm namespace.
		     */
		    var C_algo = C.algo = {};

		    return C;
		}(Math));


		return CryptoJS;

	}));
	});

	var encBase64 = createCommonjsModule(function (module, exports) {
	(function (root, factory) {
		{
			// CommonJS
			module.exports = factory(core);
		}
	}(commonjsGlobal, function (CryptoJS) {

		(function () {
		    // Shortcuts
		    var C = CryptoJS;
		    var C_lib = C.lib;
		    var WordArray = C_lib.WordArray;
		    var C_enc = C.enc;

		    /**
		     * Base64 encoding strategy.
		     */
		    C_enc.Base64 = {
		        /**
		         * Converts a word array to a Base64 string.
		         *
		         * @param {WordArray} wordArray The word array.
		         *
		         * @return {string} The Base64 string.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
		         */
		        stringify: function (wordArray) {
		            // Shortcuts
		            var words = wordArray.words;
		            var sigBytes = wordArray.sigBytes;
		            var map = this._map;

		            // Clamp excess bits
		            wordArray.clamp();

		            // Convert
		            var base64Chars = [];
		            for (var i = 0; i < sigBytes; i += 3) {
		                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
		                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
		                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

		                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

		                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
		                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
		                }
		            }

		            // Add padding
		            var paddingChar = map.charAt(64);
		            if (paddingChar) {
		                while (base64Chars.length % 4) {
		                    base64Chars.push(paddingChar);
		                }
		            }

		            return base64Chars.join('');
		        },

		        /**
		         * Converts a Base64 string to a word array.
		         *
		         * @param {string} base64Str The Base64 string.
		         *
		         * @return {WordArray} The word array.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
		         */
		        parse: function (base64Str) {
		            // Shortcuts
		            var base64StrLength = base64Str.length;
		            var map = this._map;
		            var reverseMap = this._reverseMap;

		            if (!reverseMap) {
		                    reverseMap = this._reverseMap = [];
		                    for (var j = 0; j < map.length; j++) {
		                        reverseMap[map.charCodeAt(j)] = j;
		                    }
		            }

		            // Ignore padding
		            var paddingChar = map.charAt(64);
		            if (paddingChar) {
		                var paddingIndex = base64Str.indexOf(paddingChar);
		                if (paddingIndex !== -1) {
		                    base64StrLength = paddingIndex;
		                }
		            }

		            // Convert
		            return parseLoop(base64Str, base64StrLength, reverseMap);

		        },

		        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
		    };

		    function parseLoop(base64Str, base64StrLength, reverseMap) {
		      var words = [];
		      var nBytes = 0;
		      for (var i = 0; i < base64StrLength; i++) {
		          if (i % 4) {
		              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
		              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
		              words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
		              nBytes++;
		          }
		      }
		      return WordArray.create(words, nBytes);
		    }
		}());


		return CryptoJS.enc.Base64;

	}));
	});

	var encUtf8 = createCommonjsModule(function (module, exports) {
	(function (root, factory) {
		{
			// CommonJS
			module.exports = factory(core);
		}
	}(commonjsGlobal, function (CryptoJS) {

		return CryptoJS.enc.Utf8;

	}));
	});

	function buildAuthorizationHeaders(appId) {
	    var credentials = appId + ":";
	    var authorizationHeader = "Basic " + encBase64.stringify(encUtf8.parse(credentials));
	    var requestHeaders = {
	        Authorization: authorizationHeader,
	        Accept: 'application/json',
	    };
	    return requestHeaders;
	}

	var CONCURRENCY_MONITOR_METADATA_STORAGE_KEY = 'AdobeCM.metadata';
	var DEFAULT_SERVICE_URL = 'https://streams.adobeprimetime.com/v2';
	var ContentType = {
	    live: 'live',
	    vod: 'vod',
	};
	var MetadataKeys = {
	    accountId: 'accountId',
	    applicationId: 'applicationId',
	    applicationPlatform: 'applicationPlatform',
	    channel: 'channel',
	    contentType: 'contentType',
	    contractType: 'contractType',
	    deviceModel: 'deviceModel',
	    hba: 'hba',
	    mobileDevice: 'mobileDevice',
	    programmerName: 'programmerName',
	    osName: 'osName',
	    ship: 'ship',
	    region: 'region',
	};

	var AdobeConcurrencyMonitor = (function () {
	    function AdobeConcurrencyMonitor(programmer, applicationId, identityProvider, subject, metadata) {
	        if (!applicationId || !identityProvider || !subject) {
	            return;
	        }
	        this.programmer = programmer;
	        this.applicationId = applicationId;
	        this.identityProvider = encodeURIComponent(identityProvider);
	        this.subject = encodeURIComponent(subject);
	        this.metadata = metadata || {};
	        this.serviceUrl = DEFAULT_SERVICE_URL;
	        this.requestHeaders = buildAuthorizationHeaders(applicationId);
	        this.heartbeatIntervalId = null;
	        this.messages = {};
	    }
	    AdobeConcurrencyMonitor.fetchMetadataKeys = function (applicationId, serviceUrl) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, headers, options, response, json, err_1;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = serviceUrl + "/metadata";
	                        headers = buildAuthorizationHeaders(applicationId);
	                        options = { method: 'GET', headers: headers };
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 5, , 6]);
	                        return [4, fetch(url, options)];
	                    case 2:
	                        response = _a.sent();
	                        if (!response) return [3, 4];
	                        return [4, response.json()];
	                    case 3:
	                        json = _a.sent();
	                        AdobeConcurrencyMonitor.setLocalStorageByAppID(json, applicationId);
	                        return [2, true];
	                    case 4: return [2, false];
	                    case 5:
	                        err_1 = _a.sent();
	                        console.log("fetchMetadataKeys error: " + err_1);
	                        return [2, false];
	                    case 6: return [2];
	                }
	            });
	        });
	    };
	    AdobeConcurrencyMonitor.setLocalStorageByAppID = function (json, applicationId) {
	        var key = CONCURRENCY_MONITOR_METADATA_STORAGE_KEY + "." + applicationId;
	        localStorage.setItem(key, JSON.stringify(json));
	    };
	    Object.defineProperty(AdobeConcurrencyMonitor.prototype, "metadataKeys", {
	        get: function () {
	            return this.getMetadataKeysFromLocalStorage_(this.applicationId);
	        },
	        enumerable: false,
	        configurable: true
	    });
	    AdobeConcurrencyMonitor.prototype.getMetadataKeysFromLocalStorage_ = function (applicationId) {
	        var key = CONCURRENCY_MONITOR_METADATA_STORAGE_KEY + "." + applicationId;
	        var metadataKeys = [];
	        try {
	            metadataKeys = JSON.parse(localStorage.getItem(key)) || [];
	        }
	        catch (err) {
	            console.error("AdobeCM getMetadataKeys error: " + err);
	        }
	        return metadataKeys;
	    };
	    AdobeConcurrencyMonitor.prototype.start = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var sessionId;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4, this.createSession()];
	                    case 1:
	                        sessionId = _a.sent();
	                        if (!sessionId) {
	                            return [2, null];
	                        }
	                        this.scheduleHeartbeat();
	                        return [2, sessionId];
	                }
	            });
	        });
	    };
	    AdobeConcurrencyMonitor.prototype.startWithSession = function (sessionId) {
	        this.sessionId = sessionId;
	        this.scheduleHeartbeat();
	    };
	    AdobeConcurrencyMonitor.prototype.stop = function () {
	        if (this.heartbeatIntervalId) {
	            clearInterval(this.heartbeatIntervalId);
	            this.heartbeatIntervalId = null;
	        }
	        this.terminateSession();
	    };
	    AdobeConcurrencyMonitor.prototype.createSession = function (sessionsToTerminate) {
	        if (sessionsToTerminate === void 0) { sessionsToTerminate = []; }
	        return __awaiter(this, void 0, void 0, function () {
	            var requestUrl, headers, parameters, body, options, res, sessionId, status_1, json, err_2;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        loglevel.debug('AdobeConcurrencyMonitorV2.createSession');
	                        requestUrl = this.serviceUrl + "/sessions/" + this.identityProvider + "/" + this.subject;
	                        headers = __assign({ 'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8' }, this.requestHeaders);
	                        if (sessionsToTerminate.length > 0) {
	                            headers['X-Terminate'] = sessionsToTerminate.join(',');
	                        }
	                        parameters = this.getMetadata();
	                        body = Object.keys(parameters)
	                            .map(function (key) { return key + "=" + encodeURIComponent(parameters[key]); })
	                            .join('&');
	                        options = { method: 'POST', headers: headers, body: body };
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 3, , 5]);
	                        return [4, this.fetchRequest(requestUrl, options, true)];
	                    case 2:
	                        res = _a.sent();
	                        if (!res) {
	                            throw 'fetchRequest failed';
	                        }
	                        sessionId = res.sessionId;
	                        if (sessionId) {
	                            this.sessionId = sessionId;
	                            loglevel.debug('AdobeConcurrencyMonitorV2.createSession sessionId:', sessionId);
	                            return [2, sessionId];
	                        }
	                        status_1 = res.status, json = res.json;
	                        throw {
	                            status: status_1,
	                            json: json,
	                        };
	                    case 3:
	                        err_2 = _a.sent();
	                        loglevel.error('AdobeConcurrencyMonitorV2.createSession error: ', err_2);
	                        return [4, this.handleError(err_2, false)];
	                    case 4: return [2, _a.sent()];
	                    case 5: return [2];
	                }
	            });
	        });
	    };
	    AdobeConcurrencyMonitor.prototype.heartbeat = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var sessionId, requestUrl, options, res, status_2, json, err_3;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        sessionId = this.sessionId;
	                        if (!sessionId) {
	                            return [2];
	                        }
	                        loglevel.debug('AdobeConcurrencyMonitorV2.heartbeat', sessionId);
	                        requestUrl = this.serviceUrl + "/sessions/" + this.identityProvider + "/" + this.subject + "/" + sessionId;
	                        options = { method: 'POST', headers: this.requestHeaders };
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 3, , 4]);
	                        return [4, this.fetchRequest(requestUrl, options, false)];
	                    case 2:
	                        res = _a.sent();
	                        if (!res) {
	                            throw 'fetchRequest failed';
	                        }
	                        if (res.error) {
	                            status_2 = res.status, json = res.json;
	                            throw {
	                                status: status_2,
	                                json: json,
	                            };
	                        }
	                        this.scheduleHeartbeat();
	                        return [3, 4];
	                    case 3:
	                        err_3 = _a.sent();
	                        loglevel.error('AdobeConcurrencyMonitorV2.heartbeat error: ', err_3);
	                        return [2, this.handleError(err_3, true)];
	                    case 4: return [2];
	                }
	            });
	        });
	    };
	    AdobeConcurrencyMonitor.prototype.scheduleHeartbeat = function () {
	        var _this = this;
	        loglevel.debug('AdobeConcurrencyMonitorV2.scheduleHeartbeat');
	        clearTimeout(this.heartbeatIntervalId);
	        this.heartbeatIntervalId = window.setTimeout(function () {
	            _this.heartbeat();
	        }, 45000);
	    };
	    AdobeConcurrencyMonitor.prototype.fetchRequest = function (requestUrl, options, isSessionRequest) {
	        return __awaiter(this, void 0, void 0, function () {
	            var response_1, status_3, json, sessionId, err_4, json;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        _a.trys.push([0, 4, , 7]);
	                        return [4, fetch(requestUrl, options)];
	                    case 1:
	                        response_1 = _a.sent();
	                        status_3 = response_1.status;
	                        if (!!(status_3 >= 200 && status_3 < 300)) return [3, 3];
	                        return [4, response_1
	                                .clone()
	                                .json()
	                                .catch(function () { return !!response_1.text() || null; })];
	                    case 2:
	                        json = _a.sent();
	                        return [2, {
	                                status: status_3,
	                                json: json,
	                                error: true,
	                            }];
	                    case 3:
	                        sessionId = void 0;
	                        if (isSessionRequest) {
	                            sessionId = response_1.headers.get('location').trim();
	                        }
	                        return [2, {
	                                sessionId: sessionId,
	                                status: status_3,
	                                error: false,
	                            }];
	                    case 4:
	                        err_4 = _a.sent();
	                        console.error("AdobeCM fetchRequest: " + err_4);
	                        if (!(err_4 && err_4.status === 409 && typeof err_4.json === 'function')) return [3, 6];
	                        return [4, err_4.json()];
	                    case 5:
	                        json = _a.sent();
	                        return [2, {
	                                status: 409,
	                                json: json,
	                                error: true,
	                            }];
	                    case 6: return [2, err_4];
	                    case 7: return [2];
	                }
	            });
	        });
	    };
	    AdobeConcurrencyMonitor.prototype.terminateSession = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var sessionId, requestUrl, response, status_4, err_5;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        sessionId = this.sessionId;
	                        if (!sessionId) {
	                            return [2];
	                        }
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 3, , 4]);
	                        requestUrl = this.serviceUrl + "/sessions/" + this.identityProvider + "/" + this.subject + "/" + sessionId;
	                        return [4, fetch(requestUrl, { method: 'DELETE', headers: this.requestHeaders })];
	                    case 2:
	                        response = _a.sent();
	                        status_4 = response.status;
	                        if (!(status_4 >= 200 && status_4 < 300)) {
	                            throw new Error("Error - url: " + requestUrl + ", status: " + status_4);
	                        }
	                        return [3, 4];
	                    case 3:
	                        err_5 = _a.sent();
	                        console.error("AdobeCM TerminateSession " + err_5);
	                        return [3, 4];
	                    case 4: return [2];
	                }
	            });
	        });
	    };
	    AdobeConcurrencyMonitor.prototype.handleError = function (response, shouldShowCustomError) {
	        loglevel.debug('AdobeConcurrencyMonitorV2.handleError', response);
	        var status = response.status, json = response.json;
	        switch (status) {
	            case 400:
	                return this.handleError400_(json);
	            case 409:
	                return this.handleError409_(json, shouldShowCustomError);
	            case 410:
	                return this.handleError410_(json, shouldShowCustomError);
	        }
	    };
	    AdobeConcurrencyMonitor.prototype.handleError400_ = function (json) {
	        return __awaiter(this, void 0, void 0, function () {
	            var obligations, hasRefreshObligation, metadata;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        obligations = (json && json.obligations) || [];
	                        hasRefreshObligation = !!obligations.find(function (obl) { return obl.action === 'logout' || obl.action === 'refresh'; });
	                        if (!hasRefreshObligation) return [3, 2];
	                        return [4, AdobeConcurrencyMonitor.fetchMetadataKeys(this.applicationId, this.serviceUrl)];
	                    case 1:
	                        _a.sent();
	                        metadata = this.metadata;
	                        if (Object.keys(metadata).length >= this.metadataKeys.length) {
	                            return [2, this.start()];
	                        }
	                        _a.label = 2;
	                    case 2: return [2, null];
	                }
	            });
	        });
	    };
	    AdobeConcurrencyMonitor.prototype.handleError409_ = function (json, shouldShowCustomError) {
	        try {
	            var associatedAdvice = (json && json.associatedAdvice) || [];
	            var advice = associatedAdvice.find(function (element) { return element.type === 'rule-violation'; });
	            if (advice) {
	                var message = advice.message;
	                var localizedMessage = this.messages[message] || message;
	                var error = new Error(localizedMessage);
	                var obligations = json.obligations || [];
	                var shouldLogout = !!obligations.find(function (obl) { return obl.action === 'logout'; });
	                loglevel.debug('AdobeConcurrencyMonitorV2.handleError', 409, error, shouldLogout);
	                if (shouldShowCustomError) {
	                    this.onError(error, shouldLogout);
	                }
	                else {
	                    throw error;
	                }
	            }
	        }
	        catch (error) {
	            loglevel.debug("AdobeConcurrencyMonitorV2.handleError409_: " + error);
	            throw error;
	        }
	        return null;
	    };
	    AdobeConcurrencyMonitor.prototype.handleError410_ = function (json, shouldShowCustomError) {
	        if (!json) {
	            return this.start();
	        }
	        try {
	            var associatedAdvice = (json && json.associatedAdvice) || [];
	            var advice = associatedAdvice.find(function (element) { return element.type === 'remote-termination'; });
	            if (advice) {
	                var message = advice.message;
	                var localizedMessage = this.messages[message] || message;
	                var error = new Error(localizedMessage);
	                var shouldLogout = !!json.obligations.find(function (obl) { return obl.action === 'logout'; });
	                loglevel.debug('AdobeConcurrencyMonitorV2.handleError', 410, error, shouldLogout);
	                if (shouldShowCustomError) {
	                    this.onError(error, shouldLogout);
	                }
	                else {
	                    throw error;
	                }
	            }
	        }
	        catch (error) {
	            loglevel.debug("AdobeConcurrencyMonitorV2.handleError410_: " + error);
	            throw error;
	        }
	        return null;
	    };
	    AdobeConcurrencyMonitor.prototype.getMetadata = function () {
	        var _this = this;
	        var metadataKeys = this.metadataKeys;
	        var metadata = metadataKeys.reduce(function (md, key) {
	            md[key] = _this.metadata[key];
	            return md;
	        }, {});
	        return metadata;
	    };
	    AdobeConcurrencyMonitor.prototype.onError = function (error, shouldLogout) {
	        loglevel.debug('AdobeConcurrencyMonitor.onError');
	        loglevel.debug("error: " + error);
	        loglevel.debug("shouldLogout: " + shouldLogout);
	    };
	    return AdobeConcurrencyMonitor;
	}());

	var sha256 = createCommonjsModule(function (module, exports) {
	(function (root, factory) {
		{
			// CommonJS
			module.exports = factory(core);
		}
	}(commonjsGlobal, function (CryptoJS) {

		(function (Math) {
		    // Shortcuts
		    var C = CryptoJS;
		    var C_lib = C.lib;
		    var WordArray = C_lib.WordArray;
		    var Hasher = C_lib.Hasher;
		    var C_algo = C.algo;

		    // Initialization and round constants tables
		    var H = [];
		    var K = [];

		    // Compute constants
		    (function () {
		        function isPrime(n) {
		            var sqrtN = Math.sqrt(n);
		            for (var factor = 2; factor <= sqrtN; factor++) {
		                if (!(n % factor)) {
		                    return false;
		                }
		            }

		            return true;
		        }

		        function getFractionalBits(n) {
		            return ((n - (n | 0)) * 0x100000000) | 0;
		        }

		        var n = 2;
		        var nPrime = 0;
		        while (nPrime < 64) {
		            if (isPrime(n)) {
		                if (nPrime < 8) {
		                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
		                }
		                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

		                nPrime++;
		            }

		            n++;
		        }
		    }());

		    // Reusable object
		    var W = [];

		    /**
		     * SHA-256 hash algorithm.
		     */
		    var SHA256 = C_algo.SHA256 = Hasher.extend({
		        _doReset: function () {
		            this._hash = new WordArray.init(H.slice(0));
		        },

		        _doProcessBlock: function (M, offset) {
		            // Shortcut
		            var H = this._hash.words;

		            // Working variables
		            var a = H[0];
		            var b = H[1];
		            var c = H[2];
		            var d = H[3];
		            var e = H[4];
		            var f = H[5];
		            var g = H[6];
		            var h = H[7];

		            // Computation
		            for (var i = 0; i < 64; i++) {
		                if (i < 16) {
		                    W[i] = M[offset + i] | 0;
		                } else {
		                    var gamma0x = W[i - 15];
		                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
		                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
		                                   (gamma0x >>> 3);

		                    var gamma1x = W[i - 2];
		                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
		                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
		                                   (gamma1x >>> 10);

		                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
		                }

		                var ch  = (e & f) ^ (~e & g);
		                var maj = (a & b) ^ (a & c) ^ (b & c);

		                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
		                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

		                var t1 = h + sigma1 + ch + K[i] + W[i];
		                var t2 = sigma0 + maj;

		                h = g;
		                g = f;
		                f = e;
		                e = (d + t1) | 0;
		                d = c;
		                c = b;
		                b = a;
		                a = (t1 + t2) | 0;
		            }

		            // Intermediate hash value
		            H[0] = (H[0] + a) | 0;
		            H[1] = (H[1] + b) | 0;
		            H[2] = (H[2] + c) | 0;
		            H[3] = (H[3] + d) | 0;
		            H[4] = (H[4] + e) | 0;
		            H[5] = (H[5] + f) | 0;
		            H[6] = (H[6] + g) | 0;
		            H[7] = (H[7] + h) | 0;
		        },

		        _doFinalize: function () {
		            // Shortcuts
		            var data = this._data;
		            var dataWords = data.words;

		            var nBitsTotal = this._nDataBytes * 8;
		            var nBitsLeft = data.sigBytes * 8;

		            // Add padding
		            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
		            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
		            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
		            data.sigBytes = dataWords.length * 4;

		            // Hash final blocks
		            this._process();

		            // Return final computed hash
		            return this._hash;
		        },

		        clone: function () {
		            var clone = Hasher.clone.call(this);
		            clone._hash = this._hash.clone();

		            return clone;
		        }
		    });

		    /**
		     * Shortcut function to the hasher's object interface.
		     *
		     * @param {WordArray|string} message The message to hash.
		     *
		     * @return {WordArray} The hash.
		     *
		     * @static
		     *
		     * @example
		     *
		     *     var hash = CryptoJS.SHA256('message');
		     *     var hash = CryptoJS.SHA256(wordArray);
		     */
		    C.SHA256 = Hasher._createHelper(SHA256);

		    /**
		     * Shortcut function to the HMAC's object interface.
		     *
		     * @param {WordArray|string} message The message to hash.
		     * @param {WordArray|string} key The secret key.
		     *
		     * @return {WordArray} The HMAC.
		     *
		     * @static
		     *
		     * @example
		     *
		     *     var hmac = CryptoJS.HmacSHA256(message, key);
		     */
		    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
		}(Math));


		return CryptoJS.SHA256;

	}));
	});

	var AdobeConcurrencyMonitorBuilder = (function () {
	    function AdobeConcurrencyMonitorBuilder(programmer, applicationId, metadata) {
	        if (metadata === void 0) { metadata = {}; }
	        this.programmer = programmer;
	        this.applicationId = applicationId;
	        this.metadata = metadata;
	    }
	    AdobeConcurrencyMonitorBuilder.prototype.withSession = function (session) {
	        var authenticationType = session.authenticationType, authenticatedIdentity = session.authenticatedIdentity, authenticatedProvider = session.authenticatedProvider, mediaItem = session.mediaItem;
	        if (authenticationType !== MediaItemAuthenticationType$1.mvpd) {
	            return this;
	        }
	        var subject = authenticatedIdentity;
	        var identityProvider = authenticatedProvider && authenticatedProvider.id;
	        this.metadata[MetadataKeys.accountId] = subject;
	        this.metadata[MetadataKeys.channel] = mediaItem.network && mediaItem.network.id;
	        this.metadata[MetadataKeys.contentType] =
	            mediaItem.streamType === MediaItemStreamType$1.live ? ContentType.live : ContentType.vod;
	        this.metadata[MetadataKeys.contractType] = '';
	        this.metadata[MetadataKeys.hba] = session.authenticatedProvider ? session.authenticatedProvider.isHomeBasedAuth : false;
	        this.subject = subject;
	        this.identityProvider = identityProvider;
	        return this;
	    };
	    AdobeConcurrencyMonitorBuilder.prototype.withLocationProvider = function (locationProvider) {
	        var salt = 'm!ck3ym0u$3';
	        var ip = locationProvider.getPublicIPAddress();
	        this.metadata[MetadataKeys.ship] = ip ? sha256("" + salt + ip) : null;
	        this.metadata[MetadataKeys.region] = locationProvider.getRegion() ? locationProvider.getRegion() : null;
	        return this;
	    };
	    AdobeConcurrencyMonitorBuilder.prototype.withServiceUrl = function (serviceUrl) {
	        this.serviceUrl = serviceUrl;
	        return this;
	    };
	    AdobeConcurrencyMonitorBuilder.prototype.withMessages = function (messages) {
	        this.messages = messages;
	        return this;
	    };
	    AdobeConcurrencyMonitorBuilder.prototype.build = function () {
	        if (!this.subject || !this.identityProvider) {
	            return null;
	        }
	        var monitor = new AdobeConcurrencyMonitor(this.programmer, this.applicationId, this.identityProvider, this.subject, this.metadata);
	        if (this.serviceUrl) {
	            monitor.serviceUrl = this.serviceUrl;
	        }
	        if (this.messages) {
	            monitor.messages = this.messages || {};
	        }
	        return monitor;
	    };
	    return AdobeConcurrencyMonitorBuilder;
	}());

	var ESPNAuthButler = (function () {
	    function ESPNAuthButler(partner, platform) {
	        this.partner = partner;
	        this.platform = platform;
	    }
	    ESPNAuthButler.prototype.startSession = function (url, swid, token, tokenType, resource, advertisingInfo) {
	        var _a = this, partner = _a.partner, platform = _a.platform;
	        var params = [
	            "partner=" + partner,
	            "platform=" + platform,
	            "token=" + encodeURIComponent(token),
	            "tokenType=" + tokenType,
	            'v=2.0.0',
	            'ttl=21600',
	        ];
	        if (resource) {
	            var base64Resource = encBase64.stringify(encUtf8.parse(resource));
	            params.push("resource=" + encodeURIComponent(base64Resource));
	        }
	        if (advertisingInfo) {
	            Object.keys(advertisingInfo).forEach(function (key) {
	                params.push(key + "=" + encodeURIComponent(advertisingInfo[key]));
	            });
	        }
	        var swidRegExp = /swid=*/g;
	        var containsSwid = params.some(function (e) { return swidRegExp.test(e); });
	        if (!containsSwid) {
	            params.push("swid=" + encodeURIComponent(swid));
	        }
	        var headers = {
	            'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8',
	        };
	        var body = params.join('&');
	        var options = { method: 'POST', headers: headers, credentials: 'include', body: body };
	        return fetch(url, options)
	            .then(function (response) { return response.json(); })
	            .then(function (json) {
	            if (!json.session) {
	                throw new Error(json.message || "An unexpected error occurred. [" + json.abbreviation + "]");
	            }
	            return json;
	        })
	            .catch(function (error) {
	            if (error.message) {
	                throw new Error(error.message);
	            }
	            return error.json().then(function (json) {
	                throw new Error(json.message || "An unexpected error occurred. [" + json.abbreviation + "]");
	            });
	        });
	    };
	    return ESPNAuthButler;
	}());

	var buildPlaybackSession = function buildPlaybackSession(json, token) {
	    var playbackUrl = json.playbackUrl;
	    var session = new PlaybackSession(playbackUrl);
	    session.token = token;
	    return session;
	};
	var StartSessionPlaybackSessionFactory = (function () {
	    function StartSessionPlaybackSessionFactory(authButler) {
	        this.authButler = authButler;
	    }
	    StartSessionPlaybackSessionFactory.prototype.initPlaybackSession = function (mediaItem, advertisingInfo, authorizationPayload) {
	        var url = mediaItem.source.url;
	        if (mediaItem.source.startSessionUrl && mediaItem.source.type === MediaItemSourceType$1.shield) {
	            url = mediaItem.source.startSessionUrl;
	        }
	        try {
	            var protocol = window && window.location.protocol;
	            if (protocol && protocol === 'https:') {
	                url = url.replace(/^http(s?):/, protocol);
	            }
	        }
	        catch (e) { }
	        var _a = authorizationPayload.customData, token = _a.token, tokenType = _a.tokenType, _b = _a.resource, resource = _b === void 0 ? mediaItem.mrss : _b;
	        var swid = advertisingInfo && advertisingInfo.swid;
	        var authButler = this.authButler;
	        if (!authButler) {
	            throw new Error('startSession support not configured');
	        }
	        return (authButler
	            .startSession(url, swid, token, tokenType, resource, advertisingInfo.dictionaryForStartSession())
	            .then(function (json) {
	            var session = buildPlaybackSession(json, token);
	            session.mediaItem = mediaItem;
	            session.seekToTime = mediaItem.seekInSeconds;
	            session.authenticationType = authorizationPayload.authenticationType;
	            session.authenticatedProvider = authorizationPayload.authenticatedProvider;
	            session.authenticatedIdentity = authorizationPayload.authenticatedIdentity;
	            return session;
	        }));
	    };
	    return StartSessionPlaybackSessionFactory;
	}());

	var NonePlaybackSessionFactory = (function () {
	    function NonePlaybackSessionFactory() {
	    }
	    NonePlaybackSessionFactory.prototype.initPlaybackSession = function (mediaItem, advertisingInfo, authorizationPayload) {
	        var playbackSession = new PlaybackSession(mediaItem.source.url);
	        playbackSession.mediaItem = mediaItem;
	        playbackSession.seekToTime = mediaItem.seekInSeconds;
	        playbackSession.authenticationType = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.authenticationType;
	        playbackSession.authenticatedProvider = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.authenticatedProvider;
	        playbackSession.authenticatedIdentity = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.authenticatedIdentity;
	        return Promise.resolve(playbackSession);
	    };
	    return NonePlaybackSessionFactory;
	}());

	var TokenType = {
	    adobePass: 'ADOBEPASS',
	    gatekeeper: 'GATEKEEPER',
	    jwt: 'JWT',
	    authToken: 'AUTHTOKEN',
	};
	var handleErrorResponse = function handleErrorResponse(response) {
	    if (response instanceof Error) {
	        throw response;
	    }
	    return (response.json &&
	        response.json().then(function (json) {
	            var message = json.message || "An unexpected error occurred. [" + json.exception + "]";
	            if (json.exception === 'com.espn.watch.api.AccessDeniedException') {
	                message = 'This content is not available for your package or region.';
	            }
	            throw new Error(message);
	        }));
	};
	var defaultServiceUrl$1 = 'https://watch.auth.api.espn.com';
	var ShieldAPI = (function () {
	    function ShieldAPI(apiKey, serviceUrl) {
	        this.drmSupport = DRMSupport$1.none;
	        this.palEnabled = true;
	        this.serviceUrl = defaultServiceUrl$1;
	        this.apiKey = apiKey;
	        this.serviceUrl = serviceUrl || defaultServiceUrl$1;
	    }
	    ShieldAPI.prototype.getAsset = function (id, token, tokenType, resource, params) {
	        var url = this.serviceUrl + "/video/auth/media/" + id + "/asset";
	        return this.getAssetForUrl(url, token, tokenType, resource, params);
	    };
	    ShieldAPI.prototype.getAssetForUrl = function (assetUrl, token, tokenType, resource, params) {
	        var parameters = params || {};
	        var headers = {
	            'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8',
	        };
	        var sep = assetUrl.indexOf('?') === -1 ? '?' : '&';
	        var url = "" + assetUrl + sep + "apikey=" + this.apiKey;
	        if (token) {
	            if (tokenType === TokenType.adobePass) {
	                parameters.adobeToken = token;
	                if (resource) {
	                    var base64Resource = encBase64.stringify(encUtf8.parse(resource));
	                    parameters.adobeResource = base64Resource;
	                }
	            }
	            else if (tokenType == TokenType.jwt) {
	                headers.Authorization = "Bearer " + token;
	            }
	            else if (tokenType == TokenType.authToken) {
	                sep = url.indexOf('?') === -1 ? '?' : '&';
	                url = "" + url + sep + "authtoken=" + token;
	            }
	            else {
	                parameters.token = token;
	            }
	        }
	        parameters.drmSupport = this.drmSupport;
	        var body = Object.keys(parameters)
	            .map(function (key) { return key + "=" + encodeURIComponent(parameters[key]); })
	            .join('&');
	        var options = {
	            method: 'POST',
	            headers: headers,
	            credentials: 'include',
	            body: body,
	        };
	        return fetch(url, options)
	            .then(function (response) {
	            if (!response.ok) {
	                throw response;
	            }
	            return response.json();
	        })
	            .then(function (json) {
	            if (!json.stream) {
	                var message = json.message || "An unexpected error occurred.";
	                throw new Error(message);
	            }
	            return json;
	        })
	            .catch(handleErrorResponse);
	    };
	    ShieldAPI.defaultServiceUrl = defaultServiceUrl$1;
	    return ShieldAPI;
	}());

	var buildPlaybackConfig = function buildPlaybackConfig(streamInfo) {
	    if (!streamInfo) {
	        return null;
	    }
	    var streamType = streamInfo.streamType, licenseUrl = streamInfo.licenseAcquisitionUrl, certificateUrl = streamInfo.certificateUrl;
	    switch (streamType) {
	        case 'DASH_PLAYREADY':
	            return new PlaybackConfig('application/dash+xml', DRMKeySystem.playReady, licenseUrl);
	        case 'DASH_WIDEVINE':
	            return new PlaybackConfig('application/dash+xml', DRMKeySystem.widevine, licenseUrl);
	        case 'HLS_FAIRPLAY':
	            return new PlaybackConfig('application/x-mpegURL', DRMKeySystem.fairPlay, certificateUrl);
	        case 'HLS':
	            return new PlaybackConfig('application/x-mpegURL', DRMKeySystem.none);
	        default:
	            return null;
	    }
	};
	var buildTextTracks = function buildTextTracks(captions) {
	    if (!captions) {
	        return [];
	    }
	    var track = {
	        source: captions,
	    };
	    if (captions.endsWith('.vtt')) {
	        track.contentType = 'text/vtt';
	    }
	    return [track];
	};
	var ShieldPlaybackSessionFactory = (function () {
	    function ShieldPlaybackSessionFactory(shieldAPI) {
	        this.shieldAPI = shieldAPI;
	    }
	    ShieldPlaybackSessionFactory.prototype.initPlaybackSession = function (mediaItem, advertisingInfo, authorizationPayload) {
	        return __awaiter(this, void 0, void 0, function () {
	            var shieldAPI, palEnabled, token, zipcode, _a, _b, tokenType, _c, resource, _d, err_1, parameters, url, json, stream, captions, streamInfo, gatekeeperToken, session;
	            return __generator(this, function (_e) {
	                switch (_e.label) {
	                    case 0:
	                        shieldAPI = this.shieldAPI;
	                        if (!shieldAPI) {
	                            throw new Error('shield support not configured');
	                        }
	                        palEnabled = shieldAPI.palEnabled;
	                        token = authorizationPayload.customData.token;
	                        zipcode = authorizationPayload.customData.zipcode;
	                        _a = authorizationPayload.customData, _b = _a === void 0 ? {} : _a, tokenType = _b.tokenType, _c = _b.resource, resource = _c === void 0 ? mediaItem.mrss : _c;
	                        if (!(palEnabled && !advertisingInfo.palNonce)) return [3, 4];
	                        _e.label = 1;
	                    case 1:
	                        _e.trys.push([1, 3, , 4]);
	                        _d = advertisingInfo;
	                        return [4, AdvertisingInfo.getGooglePalNonce(advertisingInfo)];
	                    case 2:
	                        _d.palNonce = _e.sent();
	                        return [3, 4];
	                    case 3:
	                        err_1 = _e.sent();
	                        console.warn(err_1);
	                        return [3, 4];
	                    case 4:
	                        parameters = advertisingInfo.dictionaryForStartSession();
	                        if (zipcode) {
	                            parameters.zipcode = zipcode;
	                        }
	                        url = mediaItem.source.url;
	                        return [4, shieldAPI.getAssetForUrl(url, token, tokenType, resource, parameters)];
	                    case 5:
	                        json = _e.sent();
	                        stream = json.stream, captions = json.captions, streamInfo = json.streamInfo, gatekeeperToken = json.gatekeeperToken;
	                        session = new PlaybackSession(stream);
	                        session.mediaItem = mediaItem;
	                        session.seekToTime = mediaItem.seekInSeconds;
	                        session.authenticationType = authorizationPayload.authenticationType;
	                        session.authenticatedProvider = authorizationPayload.authenticatedProvider;
	                        session.authenticatedIdentity = authorizationPayload.authenticatedIdentity;
	                        session.token = gatekeeperToken;
	                        session.playbackConfig = buildPlaybackConfig(streamInfo);
	                        session.textTracks = buildTextTracks(captions);
	                        return [2, session];
	                }
	            });
	        });
	    };
	    return ShieldPlaybackSessionFactory;
	}());

	var checkAuthorizationWithAuthorizers = function checkAuthorizationWithAuthorizers(mediaItem, advertisingInfo, authorizers, errors) {
	    if (errors === void 0) { errors = []; }
	    var authorizer = authorizers.shift();
	    return (authorizer
	        .checkAuthorization(mediaItem, advertisingInfo)
	        .then(function (result) {
	        var success = result.success;
	        if (success) {
	            return result;
	        }
	        if (authorizers.length < 1) {
	            if (errors.length > 0) {
	                return Promise.reject(null);
	            }
	            return result;
	        }
	        return checkAuthorizationWithAuthorizers(mediaItem, advertisingInfo, authorizers, errors);
	    })
	        .catch(function (error) {
	        if (authorizers.length > 0) {
	            if (error) {
	                errors.push(error);
	            }
	            return checkAuthorizationWithAuthorizers(mediaItem, advertisingInfo, authorizers, errors);
	        }
	        var throwable = errors[0] || error;
	        if (throwable) {
	            throw throwable;
	        }
	    }));
	};

	var AuthenticationManager = (function () {
	    function AuthenticationManager() {
	        this.partner = null;
	        this.platform = null;
	        this.apiKey = null;
	        this.deviceId = null;
	        this.authenticators = {};
	        this.authorizers = {};
	        this.playbackSessionFactories = {};
	        this.playbackSessionFactories[MediaItemSourceType$1.none] = new NonePlaybackSessionFactory();
	    }
	    AuthenticationManager.prototype.getAuthenticator = function (type) {
	        return this.authenticators[type];
	    };
	    AuthenticationManager.prototype.setAuthenticator = function (authenticator, authenticationType) {
	        var _this = this;
	        var array = this.convertToArray(authenticationType);
	        array.forEach(function (value) {
	            _this.authenticators[value.toString()] = authenticator;
	        });
	    };
	    AuthenticationManager.prototype.getAuthorizer = function (type) {
	        return this.authorizers[type];
	    };
	    AuthenticationManager.prototype.setAuthorizer = function (authorizer, authenticationType) {
	        var _this = this;
	        var array = this.convertToArray(authenticationType);
	        array.forEach(function (value) {
	            _this.authorizers[value.toString()] = authorizer;
	        });
	    };
	    AuthenticationManager.prototype.getPlaybackSessionFactory = function (type) {
	        return this.playbackSessionFactories[type];
	    };
	    AuthenticationManager.prototype.setPlaybackSessionFactory = function (factory, type) {
	        this.playbackSessionFactories[type] = factory;
	    };
	    AuthenticationManager.prototype.checkAuthentication = function () {
	        var _this = this;
	        var promises = Object.keys(this.authenticators).map(function (key) {
	            var authenticator = _this.authenticators[key];
	            return authenticator
	                .checkAuthentication()
	                .then(function (result) {
	                loglevel.debug(key + " authenticator", "isAuthenticated: " + result, "authenticatedProvider: " + authenticator.authenticatedProvider);
	                return result;
	            })
	                .catch(function () {
	                return false;
	            });
	        });
	        return Promise.all(promises).then(function (results) {
	            return results.every(function (result) { return result === true; });
	        });
	    };
	    AuthenticationManager.prototype.isAuthenticatedForMediaItem = function (mediaItem) {
	        var _this = this;
	        if (mediaItem.authenticationTypes.length < 1 ||
	            mediaItem.authenticationTypes.indexOf(MediaItemAuthenticationType$1.none) !== -1) {
	            return true;
	        }
	        var authenticators = mediaItem.authenticationTypes
	            .map(function (authType) { return _this.authenticators[authType]; })
	            .filter(function (authenticator) { return authenticator; });
	        return authenticators.some(function (authenticator) { return authenticator.isAuthenticated; });
	    };
	    AuthenticationManager.prototype.isAuthenticatedWithAuthType = function (authenticationType) {
	        var authenticator = this.authenticators[authenticationType];
	        if (!authenticator) {
	            return false;
	        }
	        return authenticator.isAuthenticated;
	    };
	    AuthenticationManager.prototype.authenticateWithAuthType = function (authType, options) {
	        var authenticator = this.authenticators[authType];
	        if (!authenticator) {
	            return;
	        }
	        return authenticator.authenticate(options);
	    };
	    AuthenticationManager.prototype.checkAuthorization = function (mediaItem, advertisingInfo) {
	        var _this = this;
	        if ((mediaItem.authenticationTypes && mediaItem.authenticationTypes.length < 1) ||
	            mediaItem.authenticationTypes.indexOf(MediaItemAuthenticationType$1.none) !== -1) {
	            var provider = new AuthenticatedProvider(mediaItem.id, mediaItem.title, mediaItem.images[0].url, mediaItem.source.url);
	            var payload = new AuthorizationPayload(MediaItemAuthenticationType$1.none, provider, mediaItem.id, {});
	            var result = new AuthorizationResult(true, payload);
	            return Promise.resolve(result);
	        }
	        var authTypes = [
	            MediaItemAuthenticationType$1.open,
	            MediaItemAuthenticationType$1.mvpd,
	            MediaItemAuthenticationType$1.direct,
	            MediaItemAuthenticationType$1.isp,
	        ].filter(function (authType) { return mediaItem.authenticationTypes.indexOf(authType) !== -1; });
	        var authorizers = authTypes
	            .map(function (authType) { return _this.authorizers[authType]; })
	            .filter(function (authorizer) { return authorizer && authorizer.checkAuthorization; });
	        loglevel.debug('mediaItem.authTypes:', authTypes);
	        if (authorizers.length === 0) {
	            return Promise.reject(new Error("no authorizer configured to support authTypes: " + mediaItem.authenticationTypes));
	        }
	        return checkAuthorizationWithAuthorizers(mediaItem, advertisingInfo, authorizers);
	    };
	    AuthenticationManager.prototype.initPlaybackSession = function (mediaItem, advertisingInfo) {
	        var _this = this;
	        if (!mediaItem.source.type && mediaItem.authenticationTypes.length > 0) {
	            return Promise.reject(new Error('This event is not currently available.'));
	        }
	        return this.checkAuthorization(mediaItem, advertisingInfo).then(function (result) {
	            var _a, _b, _c;
	            loglevel.debug('AuthenticationManager.initPlaybackSession.checkAuthorization result:', result.success);
	            var success = result.success, payload = result.payload;
	            if (!success) {
	                throw new Error('Not authorized.');
	            }
	            if (!((_a = mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.source) === null || _a === void 0 ? void 0 : _a.type)) {
	                throw new Error('Media Item source type is missing.');
	            }
	            var playbackSessionFactory = _this.playbackSessionFactories[(_b = mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.source) === null || _b === void 0 ? void 0 : _b.type];
	            if (!playbackSessionFactory) {
	                throw new Error("SessionFactory for source type '" + ((_c = mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.source) === null || _c === void 0 ? void 0 : _c.type) + "' is missing.");
	            }
	            var adInfo = new AdvertisingInfo();
	            adInfo.authenticationProvider = result.payload.authenticatedProvider && result.payload.authenticatedProvider.id;
	            adInfo.merge(advertisingInfo);
	            return playbackSessionFactory.initPlaybackSession(mediaItem, adInfo, payload).then(function (playbackSession) {
	                loglevel.debug('AuthenticationManager.initPlaybackSession', playbackSession);
	                var monitor = _this.concurrencyMonitorBuilder && _this.concurrencyMonitorBuilder.withSession(playbackSession).build();
	                if (!monitor) {
	                    return playbackSession;
	                }
	                return monitor.createSession().then(function (concurrencySessionId) {
	                    playbackSession.concurrencyMonitorSessionId = concurrencySessionId;
	                    return playbackSession;
	                });
	            });
	        });
	    };
	    Object.defineProperty(AuthenticationManager.prototype, "authStates", {
	        get: function () {
	            var mvpdAuthenticator = this.authenticators[MediaItemAuthenticationType$1.mvpd];
	            var ispAuthenticator = this.authenticators[MediaItemAuthenticationType$1.isp];
	            var states = [];
	            if (ispAuthenticator.isAuthenticated) {
	                states.push('isp');
	            }
	            if (mvpdAuthenticator.isAuthenticated === true) {
	                states.push('mvpd_login');
	            }
	            else if (mvpdAuthenticator.wasPreviouslyAuthenticated === true) {
	                states.push('mvpd_previous');
	            }
	            return states;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(AuthenticationManager.prototype, "preauthorizedResources", {
	        get: function () {
	            var _this = this;
	            return Object.keys(this.authenticators)
	                .map(function (key) { return _this.authenticators[key].preauthorizedResources; })
	                .reduce(function (array, values) {
	                return array.concat(values);
	            }, [])
	                .filter(function (value, index, array) { return array.indexOf(value) === index; });
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(AuthenticationManager.prototype, "primaryAuthenticatedProvider", {
	        get: function () {
	            var _this = this;
	            return [MediaItemAuthenticationType$1.mvpd, MediaItemAuthenticationType$1.isp]
	                .map(function (authType) { return _this.getAuthenticator(authType); })
	                .filter(function (authenticator) { return authenticator.isAuthenticated; })
	                .map(function (authenticator) { return authenticator.authenticatedProvider; })[0];
	        },
	        enumerable: false,
	        configurable: true
	    });
	    AuthenticationManager.prototype.convertToArray = function (value) {
	        if (!value)
	            return [];
	        var array = [];
	        if (Array.isArray(value)) {
	            array = value;
	        }
	        else if (typeof value == 'string') {
	            array.push(value);
	        }
	        return array;
	    };
	    return AuthenticationManager;
	}());
	AuthenticationManager.AuthenticateOptionsKey = {
	    redirectUrl: 'redirectUrl',
	};

	var PayloadAuthenticator = (function () {
	    function PayloadAuthenticator() {
	        this.isAuthenticated = !!this.authorizationPayload;
	        this.authenticatedIdentity = this.authorizationPayload && this.authorizationPayload.authenticatedIdentity;
	        this.authenticatedProvider = this.authorizationPayload && this.authorizationPayload.authenticatedProvider;
	        this.preauthorizedResources = [];
	    }
	    PayloadAuthenticator.prototype.checkAuthentication = function () {
	        return Promise.resolve(this.isAuthenticated);
	    };
	    PayloadAuthenticator.prototype.authenticate = function () {
	        return this.checkAuthentication();
	    };
	    PayloadAuthenticator.prototype.deauthenticate = function () {
	        this.authorizationPayload = null;
	        return Promise.resolve(true);
	    };
	    PayloadAuthenticator.prototype.checkAuthorization = function (mediaItem) {
	        var result = new AuthorizationResult(true, this.authorizationPayload);
	        if (mediaItem &&
	            (mediaItem.authenticationTypes.length == 0 ||
	                mediaItem.authenticationTypes.indexOf(MediaItemAuthenticationType$1.none) !== -1)) {
	            return Promise.resolve(result);
	        }
	        else if (!this.authorizationPayload ||
	            !this.mediaItem ||
	            this.mediaItem.id !== mediaItem.id ||
	            mediaItem.authenticationTypes.indexOf(this.authorizationPayload.authenticationType) === -1) {
	            return Promise.resolve(new AuthorizationResult(false, this.authorizationPayload));
	        }
	        else {
	            return Promise.resolve(result);
	        }
	    };
	    return PayloadAuthenticator;
	}());

	var Configuration = (function () {
	    function Configuration(serviceUrl, appVersion, appName, deviceID) {
	        this.serviceUrl = serviceUrl;
	        this.appVersion = appVersion;
	        this.appName = appName;
	        this.deviceID = deviceID;
	    }
	    return Configuration;
	}());
	var defaultServiceUrl = 'https://prod.gatekeeper.us-abc.symphony.edgedatg.go.com/vp2/ws-secure/entitlement/2020/playmanifest_secure.json';
	var defaultAppVersion = '1.0.0';
	var defaultAppName = '';
	var defaultDeviceID = '001';
	var defaultConfiguration = new Configuration(defaultServiceUrl, defaultAppVersion, defaultAppName, defaultDeviceID);

	var EntitlementPlaybackSessionFactory = (function () {
	    function EntitlementPlaybackSessionFactory(configuration) {
	        if (configuration === void 0) { configuration = defaultConfiguration; }
	        this.configuration_ = configuration;
	    }
	    EntitlementPlaybackSessionFactory.prototype.initPlaybackSession = function (mediaItem, advertisingInfo, authorizationPayload) {
	        var _this = this;
	        var _a;
	        var queryParameters = {
	            brand: brandLegacyId(getBrandFromString(mediaItem.brand)),
	            device: this.configuration_.deviceID,
	        };
	        var videoType = this.videoTypeFromMedia_(mediaItem);
	        queryParameters['app_name'] = this.configuration_.appName;
	        queryParameters['video_type'] = videoType;
	        queryParameters['video_id'] = mediaItem.id;
	        if (mediaItem.brand === 'abc' && videoType == 'live')
	            queryParameters['affiliate'] = mediaItem.network.id;
	        if (authorizationPayload.authenticationType == MediaItemAuthenticationType$1.mvpd) {
	            queryParameters['resource_id'] = mediaItem.mrss;
	            queryParameters['adobe_requestor_id'] =
	                (authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.customData[AuthorizationPayload.CustomDataKey.requestor]) || ((_a = mediaItem.brand) === null || _a === void 0 ? void 0 : _a.toUpperCase());
	            var tokenType = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.customData[AuthorizationPayload.CustomDataKey.tokenType];
	            queryParameters['token_type'] = tokenType == 'ADOBEPASS' ? 'ap' : tokenType;
	            queryParameters['token'] = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.customData[AuthorizationPayload.CustomDataKey.token];
	            queryParameters['zipcode'] = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.customData[AuthorizationPayload.CustomDataKey.zipcode];
	            queryParameters['mvpd'] =
	                (authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.authenticatedProvider.id) || (authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.customData[AuthorizationPayload.CustomDataKey.mvpd]);
	            queryParameters['locale'] = mediaItem.locale;
	        }
	        var headers = {
	            appversion: this.configuration_.appVersion,
	            Accept: 'application/json',
	            'Content-Type': 'application/x-www-form-urlencoded',
	        };
	        var formData = new URLSearchParams();
	        Object.keys(queryParameters).forEach(function (key) {
	            if (queryParameters[key] != undefined) {
	                formData.append(key, queryParameters[key]);
	            }
	        });
	        var options = {
	            method: 'POST',
	            headers: headers,
	            body: formData,
	        };
	        return fetch(this.configuration_.serviceUrl, options)
	            .then(function (response) {
	            if (!response.ok) {
	                throw response;
	            }
	            return response.json();
	        })
	            .then(function (json) {
	            var playbackSession = _this.entitlementPlaybackSessionFromResponse_(json);
	            playbackSession.mediaItem = mediaItem;
	            playbackSession.authenticationType = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.authenticationType;
	            playbackSession.authenticatedProvider = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.authenticatedProvider;
	            playbackSession.authenticatedIdentity = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.authenticatedIdentity;
	            return playbackSession;
	        });
	    };
	    EntitlementPlaybackSessionFactory.prototype.entitlementPlaybackSessionFromResponse_ = function (json) {
	        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
	        var playbackUrl = ((_c = (_b = (_a = json.video) === null || _a === void 0 ? void 0 : _a.assets) === null || _b === void 0 ? void 0 : _b.asset[0]) === null || _c === void 0 ? void 0 : _c.value) || ((_g = (_f = (_e = (_d = json.channels) === null || _d === void 0 ? void 0 : _d.channel[0]) === null || _e === void 0 ? void 0 : _e.assets) === null || _f === void 0 ? void 0 : _f.asset[0]) === null || _g === void 0 ? void 0 : _g.value);
	        var playbackSession = new PlaybackSession(playbackUrl);
	        var playbackConfig;
	        if ((_h = json.entitlement) === null || _h === void 0 ? void 0 : _h.drmData) {
	            var drmData = (_j = json.entitlement) === null || _j === void 0 ? void 0 : _j.drmData;
	            switch (drmData.drmEncoding) {
	                case 'WIDEVINE':
	                    playbackConfig = new PlaybackConfig('application/dash+xml', DRMKeySystem$1.widevine, drmData.licenseUrl);
	                    break;
	                case 'FAIRPLAY':
	                    playbackConfig = new PlaybackConfig('application/x-mpegURL', DRMKeySystem$1.fairPlay, drmData.licenseUrl);
	                    break;
	                case 'PLAY_READY':
	                    playbackConfig = new PlaybackConfig('application/dash+xml', DRMKeySystem$1.playReady, drmData.licenseUrl);
	                    break;
	            }
	        }
	        else {
	            playbackConfig = new PlaybackConfig('application/x-mpegURL', DRMKeySystem$1.none, null);
	        }
	        playbackSession.playbackConfig = playbackConfig;
	        return playbackSession;
	    };
	    EntitlementPlaybackSessionFactory.prototype.videoTypeFromMedia_ = function (mediaItem) {
	        if (mediaItem.streamType == MediaItemStreamType$1.live) {
	            return 'live';
	        }
	        else if (mediaItem.streamType == MediaItemStreamType$1.onDemand && mediaItem.entityType == MediaItemEntityType$1.shortform) {
	            return 'sf';
	        }
	        else if (mediaItem.streamType == MediaItemStreamType$1.onDemand && mediaItem.entityType == MediaItemEntityType$1.longform) {
	            return 'lf';
	        }
	    };
	    return EntitlementPlaybackSessionFactory;
	}());

	var ProgramChangeMonitor = (function () {
	    function ProgramChangeMonitor(mediaItem, mediaItemDataSource) {
	        this.mediaItem = mediaItem;
	        this.mediaItemDataSource = mediaItemDataSource;
	    }
	    ProgramChangeMonitor.prototype.start = function () {
	        var _this = this;
	        if (!(this.mediaItem.isLinear && this.mediaItem.isLive)) {
	            return;
	        }
	        this.intervalId = setInterval(function () {
	            _this.checkProgramChange();
	        }, 60000);
	    };
	    ProgramChangeMonitor.prototype.stop = function () {
	        if (this.intervalId) {
	            clearInterval(this.intervalId);
	        }
	    };
	    ProgramChangeMonitor.prototype.checkProgramChange = function () {
	        var _this = this;
	        if (!this.mediaItem || !this.mediaItemDataSource) {
	            return;
	        }
	        var networkId = this.mediaItem.network && this.mediaItem.network.id;
	        if (!networkId) {
	            return;
	        }
	        var source = this.mediaItem.apiSource
	            ? this.mediaItem.apiSource == ApiSource$1.graphQL
	                ? ApiSource$1.graphQL
	                : ApiSource$1.cfa
	            : ApiSource$1.graphQL;
	        var identifier = MediaItemIdentifier.identifierStringForNetwork(networkId, source);
	        this.mediaItemDataSource.getMediaItems([identifier], {}).then(function (mediaItems) {
	            var mediaItem = Array.isArray(mediaItems) && mediaItems[0];
	            if (!mediaItem) {
	                return;
	            }
	            var programDidChange = _this.mediaItem.id !== mediaItem.id &&
	                _this.mediaItem.references.simulcastAiringId !== mediaItem.references.simulcastAiringId;
	            if (programDidChange) {
	                _this.mediaItem = mediaItem;
	                _this.onProgramChange(mediaItem);
	            }
	        });
	    };
	    ProgramChangeMonitor.prototype.onProgramChange = function (mediaItem) { };
	    return ProgramChangeMonitor;
	}());

	function E () {
	  // Keep this empty so it's easier to inherit from
	  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
	}

	E.prototype = {
	  on: function (name, callback, ctx) {
	    var e = this.e || (this.e = {});

	    (e[name] || (e[name] = [])).push({
	      fn: callback,
	      ctx: ctx
	    });

	    return this;
	  },

	  once: function (name, callback, ctx) {
	    var self = this;
	    function listener () {
	      self.off(name, listener);
	      callback.apply(ctx, arguments);
	    }
	    listener._ = callback;
	    return this.on(name, listener, ctx);
	  },

	  emit: function (name) {
	    var data = [].slice.call(arguments, 1);
	    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
	    var i = 0;
	    var len = evtArr.length;

	    for (i; i < len; i++) {
	      evtArr[i].fn.apply(evtArr[i].ctx, data);
	    }

	    return this;
	  },

	  off: function (name, callback) {
	    var e = this.e || (this.e = {});
	    var evts = e[name];
	    var liveEvents = [];

	    if (evts && callback) {
	      for (var i = 0, len = evts.length; i < len; i++) {
	        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
	          liveEvents.push(evts[i]);
	      }
	    }

	    // Remove event from queue to prevent memory leak
	    // Suggested by https://github.com/lazd
	    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

	    (liveEvents.length)
	      ? e[name] = liveEvents
	      : delete e[name];

	    return this;
	  }
	};

	var tinyEmitter = E;
	var TinyEmitter = E;
	tinyEmitter.TinyEmitter = TinyEmitter;

	var AtvlPlayerEvent;
	(function (AtvlPlayerEvent) {
	    AtvlPlayerEvent["willStartPlaying"] = "atv.player.willStartPlaying";
	    AtvlPlayerEvent["didStopPlaying"] = "atv.player.didStopPlaying";
	    AtvlPlayerEvent["onTimedMetadataChanged"] = "atv.player.onTimedMetadataChanged";
	    AtvlPlayerEvent["playerStateChanged"] = "atv.player.playerStateChanged";
	    AtvlPlayerEvent["playerTimeDidChange"] = "atv.player.playerTimeDidChange";
	})(AtvlPlayerEvent || (AtvlPlayerEvent = {}));
	var AtvlPlayerEvent$1 = AtvlPlayerEvent;

	var ID3MetadataTag;
	(function (ID3MetadataTag) {
	    ID3MetadataTag["priv"] = "PRIV";
	    ID3MetadataTag["txxx"] = "TXXX";
	})(ID3MetadataTag || (ID3MetadataTag = {}));
	var ID3HeartbeatType;
	(function (ID3HeartbeatType) {
	    ID3HeartbeatType["program"] = "PROGRAM";
	    ID3HeartbeatType["commercial"] = "COMMERCIAL";
	    ID3HeartbeatType["slate"] = "SLATE";
	})(ID3HeartbeatType || (ID3HeartbeatType = {}));
	var ID3MetadataOwner = (function () {
	    function ID3MetadataOwner(heartbeat, transition, nielsenWatermark) {
	        if (heartbeat === void 0) { heartbeat = 'com.espn.authnet.heartbeat'; }
	        if (transition === void 0) { transition = 'com.espn.authnet.transition'; }
	        if (nielsenWatermark === void 0) { nielsenWatermark = 'www.nielsen.com'; }
	        this.heartbeat = heartbeat;
	        this.transition = transition;
	        this.nielsenWatermark = nielsenWatermark;
	    }
	    return ID3MetadataOwner;
	}());
	var ID3Metadata = (function () {
	    function ID3Metadata(tag, owner, dataValue) {
	        this.tag = tag;
	        this.owner = owner;
	        this.dataValue = dataValue;
	    }
	    return ID3Metadata;
	}());

	var PlayerAdaptorEvent;
	(function (PlayerAdaptorEvent) {
	    PlayerAdaptorEvent["start"] = "start";
	    PlayerAdaptorEvent["playing"] = "playing";
	    PlayerAdaptorEvent["pause"] = "pause";
	    PlayerAdaptorEvent["seeking"] = "seeking";
	    PlayerAdaptorEvent["stalled"] = "stalled";
	    PlayerAdaptorEvent["stop"] = "stop";
	    PlayerAdaptorEvent["timedMetadata"] = "timedMetadata";
	    PlayerAdaptorEvent["currentTime"] = "currentTime";
	})(PlayerAdaptorEvent || (PlayerAdaptorEvent = {}));
	var PlayerAdaptorEvent$1 = PlayerAdaptorEvent;

	var AtvlVdmsSecureKeyDelivery = (function () {
	    function AtvlVdmsSecureKeyDelivery(secureKeyDelivery, certificateUrl) {
	        this.certificateUrl = certificateUrl;
	        this.requests = [];
	        this.bindSecureKeyDelivery(secureKeyDelivery || atv.secureKeyDelivery || {});
	    }
	    AtvlVdmsSecureKeyDelivery.prototype.bindSecureKeyDelivery = function (secureKeyDelivery) {
	        secureKeyDelivery.fetchCertificate = this.fetchCertificate.bind(this);
	        secureKeyDelivery.fetchAssetID = this.fetchAssetID.bind(this);
	        secureKeyDelivery.fetchKeys = this.fetchKeys.bind(this);
	        secureKeyDelivery.cancelAllRequests = this.cancelAllRequests.bind(this);
	    };
	    AtvlVdmsSecureKeyDelivery.prototype.fetchCertificate = function (uri, callback) {
	        var _this = this;
	        loglevel.debug('AtvlVdmsSecureKeyDelivery.fetchCertificate', uri);
	        var url = this.certificateUrl;
	        if (!url) {
	            callback.failure('invalid certificate url');
	            return;
	        }
	        var request = new XMLHttpRequest();
	        request.open('GET', url);
	        request.onreadystatechange = function () {
	            if (request.readyState !== 4) {
	                return;
	            }
	            if (request.status === 200) {
	                var data = request.responseDataAsBase64;
	                loglevel.debug('AtvlVdmsSecureKeyDelivery.fetchCertificate responseDataAsBase64:', data);
	                callback.success(data);
	            }
	            else {
	                callback.failure(request.status);
	            }
	            _this.requests.splice(_this.requests.indexOf(request), 1);
	        };
	        this.requests.push(request);
	        request.send(null);
	    };
	    AtvlVdmsSecureKeyDelivery.prototype.fetchAssetID = function (uri, callback) {
	        var regex = /[?&]c=([^&]+)&*/;
	        var match = regex.exec(uri);
	        if (!match || match.length < 2) {
	            callback.failure("Error parsing assetId " + uri);
	            return;
	        }
	        var assetId = match[1];
	        loglevel.debug('AtvlVdmsSecureKeyDelivery.fetchAssetID', uri, assetId);
	        callback.success(assetId, false);
	    };
	    AtvlVdmsSecureKeyDelivery.prototype.fetchKeys = function (uri, requestData, callback) {
	        var _this = this;
	        var url = uri.replace('skd://', 'https://');
	        var body = JSON.stringify({ spc: requestData });
	        loglevel.debug('AtvlVdmsSecureKeyDelivery.fetchKeys', url);
	        var request = new XMLHttpRequest();
	        request.open('POST', url);
	        request.setRequestHeader('Content-Type', 'application/json');
	        request.onreadystatechange = function () {
	            if (request.readyState !== 4) {
	                return;
	            }
	            if (request.status === 200) {
	                try {
	                    var json = JSON.parse(request.responseText);
	                    var ckc = json.ckc;
	                    callback.success(ckc);
	                }
	                catch (e) {
	                    callback.failure('invalid JSON');
	                }
	            }
	            else {
	                callback.failure(request.status);
	            }
	            _this.requests.splice(_this.requests.indexOf(request), 1);
	        };
	        this.requests.push(request);
	        request.send(body);
	    };
	    AtvlVdmsSecureKeyDelivery.prototype.cancelAllRequests = function () {
	        loglevel.debug('AtvlVdmsSecureKeyDelivery.cancelAllRequests', this.requests.length);
	        this.requests.forEach(function (request) {
	            if (request.abort) {
	                request.abort();
	            }
	        });
	        this.requests = [];
	    };
	    return AtvlVdmsSecureKeyDelivery;
	}());

	((function (_super) {
	    __extends(AtvlPlayerAdaptor, _super);
	    function AtvlPlayerAdaptor(nativePlayer, bus, secureKeyDelivery) {
	        var _this = _super.call(this) || this;
	        if (!bus) {
	            throw new Error('bus must be supplied');
	        }
	        _this.bus = bus;
	        _this.secureKeyDelivery = new AtvlVdmsSecureKeyDelivery(secureKeyDelivery);
	        _this.bindEventListeners();
	        return _this;
	    }
	    AtvlPlayerAdaptor.prototype.bindEventListeners = function () {
	        var _this = this;
	        this.bus.on(AtvlPlayerEvent$1.willStartPlaying, function () {
	            atv.player.observeTimedMetadataKeys();
	            _this.emit(PlayerAdaptorEvent$1.start);
	        });
	        this.bus.on(AtvlPlayerEvent$1.playerStateChanged, function (state, time) {
	            loglevel.debug('AtvlPlayerAdaptor AtvlPlayerEvent.playerStateChanged', state, time);
	            switch (state) {
	                case atv.player.states.FastForwarding:
	                    _this.emit(PlayerAdaptorEvent$1.seeking, time);
	                    break;
	                case atv.player.states.Loading:
	                    _this.emit(PlayerAdaptorEvent$1.stalled, time);
	                    break;
	                case atv.player.states.Paused:
	                    _this.emit(PlayerAdaptorEvent$1.pause, time);
	                    break;
	                case atv.player.states.Playing:
	                    _this.emit(PlayerAdaptorEvent$1.playing, time);
	                    break;
	                case atv.player.states.Rewinding:
	                    _this.emit(PlayerAdaptorEvent$1.seeking, time);
	                    break;
	            }
	        });
	        this.bus.on(AtvlPlayerEvent$1.onTimedMetadataChanged, function (metadata) {
	            var tag = metadata.key;
	            var owner = metadata.extraAttributes.info;
	            var dataValue = metadata.dataValue;
	            var metadataString = (dataValue && encUtf8.stringify(encBase64.parse(dataValue))) || '';
	            metadataString.replace('\0', '');
	            _this.emit(PlayerAdaptorEvent$1.timedMetadata, new ID3Metadata(tag, owner, metadataString));
	        });
	        this.bus.on(AtvlPlayerEvent$1.didStopPlaying, function () {
	            _this.emit(PlayerAdaptorEvent$1.stop);
	            _this.cleanup();
	        });
	        this.bus.on(AtvlPlayerEvent$1.playerTimeDidChange, function (timeIntervalSeconds) {
	            _this.emit(PlayerAdaptorEvent$1.currentTime, timeIntervalSeconds);
	        });
	    };
	    Object.defineProperty(AtvlPlayerAdaptor.prototype, "playbackConfig", {
	        set: function (playbackConfig) {
	            if (!playbackConfig) {
	                return;
	            }
	            var licenseUrl = playbackConfig.licenseUrl;
	            loglevel.debug('AtvlPlayerAdaptor setPlaybackConfig', licenseUrl, playbackConfig.protectionSystem);
	            if (licenseUrl) {
	                this.secureKeyDelivery.certificateUrl = licenseUrl;
	            }
	        },
	        enumerable: false,
	        configurable: true
	    });
	    AtvlPlayerAdaptor.prototype.stop = function (error) {
	        var reason = 'Video Playback Has Stopped';
	        var message = error.message;
	        atv.player.stopWithReason(reason, message);
	    };
	    AtvlPlayerAdaptor.prototype.cleanup = function () {
	        this.bus.off(AtvlPlayerEvent$1.willStartPlaying);
	        this.bus.off(AtvlPlayerEvent$1.onTimedMetadataChanged);
	        this.bus.off(AtvlPlayerEvent$1.didStopPlaying);
	    };
	    return AtvlPlayerAdaptor;
	})(TinyEmitter));

	((function (_super) {
	    __extends(BAMTizenPlayerAdaptor, _super);
	    function BAMTizenPlayerAdaptor(nativePlayer, constants) {
	        var _this = _super.call(this) || this;
	        if (!nativePlayer) {
	            return _this;
	        }
	        _this.nativePlayer = nativePlayer;
	        _this.bus = nativePlayer.getEventBus();
	        _this.constants = constants;
	        _this.id3MetadataOwner = new ID3MetadataOwner();
	        _this.bindEventListeners();
	        return _this;
	    }
	    BAMTizenPlayerAdaptor.prototype.bindEventListeners = function () {
	        var _this = this;
	        this.bus.subscribe(this.constants.Events.Player.ID3, function (metadata) {
	            if (metadata === void 0) { metadata = {}; }
	            var sampleData = metadata.sample ? metadata.sample.data : metadata;
	            var segment = sampleData instanceof Uint8Array ? String.fromCharCode.apply(String, __spread(sampleData)) : sampleData;
	            var tag = ['PRIV', 'TXXX'].find(function (t) { return segment.includes(t); }) || null;
	            var owners = Object.keys(_this.id3MetadataOwner).map(function (key) { return _this.id3MetadataOwner[key]; });
	            var owner = owners.find(function (o) { return segment.includes(o); }) || null;
	            var dataValue = owner
	                ? segment
	                    .substring(segment.lastIndexOf(owner) + owner.length)
	                    .trim()
	                    .replace(/\0/g, '')
	                : null;
	            var id3Metadata = new ID3Metadata(tag, owner, dataValue);
	            _this.emit(PlayerAdaptorEvent$1.timedMetadata, id3Metadata);
	        });
	        this.alreadyStarted = false;
	        this.bus.subscribe(this.constants.Events.Player.PLAYING, function () {
	            loglevel.trace('BAMTizenPlayerAdaptor Events.Player.PLAYING');
	            if (!_this.alreadyStarted) {
	                _this.emit(PlayerAdaptorEvent$1.start);
	                _this.emit(PlayerAdaptorEvent$1.playing);
	                _this.alreadyStarted = true;
	            }
	            else {
	                _this.emit(PlayerAdaptorEvent$1.playing);
	            }
	        });
	        this.bus.subscribe(this.constants.Events.Player.TIME_UPDATE, function (time) {
	            var currentTime = time / 1000;
	            _this.emit(PlayerAdaptorEvent$1.currentTime, currentTime);
	        });
	        this.bus.subscribe(this.constants.Events.Player.PAUSE, function () {
	            loglevel.trace('BAMTizenPlayerAdaptor Events.Player.PAUSE');
	            _this.emit(PlayerAdaptorEvent$1.pause);
	        });
	        this.bus.subscribe(this.constants.Events.Player.SEEKING, function () {
	            loglevel.trace('BAMTizenPlayerAdaptor Events.Player.SEEKING');
	            _this.emit(PlayerAdaptorEvent$1.seeking);
	        });
	        this.bus.subscribe(this.constants.Events.Player.BUFFERING_START, function () {
	            loglevel.trace('BAMTizenPlayerAdaptor Events.Player.BUFFERING_START');
	            _this.emit(PlayerAdaptorEvent$1.stalled);
	        });
	        this.bus.subscribe(this.constants.Events.Player.BUFFERING_END, function () {
	            loglevel.trace('BAMTizenPlayerAdaptor Events.Player.BUFFERING_END');
	            _this.emit(PlayerAdaptorEvent$1.playing);
	        });
	        this.bus.subscribe(this.constants.Events.Player.COMPLETE, function () {
	            loglevel.trace('BAMTizenPlayerAdaptor Events.Player.COMPLETE');
	            _this.emit(PlayerAdaptorEvent$1.stop);
	            _this.cleanup();
	        });
	    };
	    BAMTizenPlayerAdaptor.prototype.stop = function (error) {
	        if (error) {
	            loglevel.warn('BAMTizenPlayerAdaptor.stop', error.message);
	        }
	        this.nativePlayer.stop();
	        this.cleanup();
	    };
	    BAMTizenPlayerAdaptor.prototype.cleanup = function () {
	        this.alreadyStarted = false;
	        this.bus.unsubscribe(this.constants.Events.Player.ID3, this);
	        this.bus.unsubscribe(this.constants.Events.Player.PLAYING, this);
	        this.bus.unsubscribe(this.constants.Events.Player.TIME_UPDATE, this);
	        this.bus.unsubscribe(this.constants.Events.Player.PAUSE, this);
	        this.bus.unsubscribe(this.constants.Events.Player.SEEKING, this);
	        this.bus.unsubscribe(this.constants.Events.Player.BUFFERING_START, this);
	        this.bus.unsubscribe(this.constants.Events.Player.COMPLETE, this);
	    };
	    return BAMTizenPlayerAdaptor;
	})(TinyEmitter));

	((function (_super) {
	    __extends(ChromecastPlayerAdaptor, _super);
	    function ChromecastPlayerAdaptor(nativePlayer) {
	        var _this = _super.call(this) || this;
	        if (!nativePlayer) {
	            return _this;
	        }
	        _this.nativePlayer = nativePlayer;
	        _this.id3MetadataOwner = new ID3MetadataOwner();
	        _this.bindEventListeners();
	        return _this;
	    }
	    ChromecastPlayerAdaptor.prototype.bindEventListeners = function () {
	        this.loadCompleteHandler = this.loadCompleteHandler.bind(this);
	        this.nativePlayer.addEventListener(cast.framework.events.EventType.PLAYER_LOAD_COMPLETE, this.loadCompleteHandler);
	        this.id3Handler = this.id3Handler.bind(this);
	        this.nativePlayer.addEventListener(cast.framework.events.EventType.ID3, this.id3Handler);
	        this.mediaFinishedHandler = this.mediaFinishedHandler.bind(this);
	        this.nativePlayer.addEventListener(cast.framework.events.EventType.MEDIA_FINISHED, this.mediaFinishedHandler);
	        this.timeUpdateHandler = this.timeUpdateHandler.bind(this);
	        this.nativePlayer.addEventListener(cast.framework.events.EventType.TIME_UPDATE, this.timeUpdateHandler);
	        this.playingHandler = this.playingHandler.bind(this);
	        this.nativePlayer.addEventListener(cast.framework.events.EventType.PLAYING, this.playingHandler);
	        this.pauseHandler = this.pauseHandler.bind(this);
	        this.nativePlayer.addEventListener(cast.framework.events.EventType.PAUSE, this.pauseHandler);
	        this.stop = this.stop.bind(this);
	    };
	    ChromecastPlayerAdaptor.prototype.loadCompleteHandler = function (event) {
	        loglevel.debug('ChromecastPlayerAdaptor: PLAYER_LOAD_COMPLETE', event);
	        this.emit(PlayerAdaptorEvent$1.start);
	    };
	    ChromecastPlayerAdaptor.prototype.id3Handler = function (event) {
	        var _this = this;
	        loglevel.debug('ChromecastPlayerAdaptor._id3Handler', event);
	        if (event.detail)
	            event.segmentData = event.detail;
	        if (!event.segmentData) {
	            return;
	        }
	        var segment = String.fromCharCode.apply(String, __spread(event.segmentData));
	        loglevel.trace('ChromecastPlayerAdaptor._id3Handler', segment);
	        var tag = ['PRIV', 'TXXX'].find(function (t) { return segment.includes(t); }) || null;
	        var owners = Object.keys(this.id3MetadataOwner).map(function (key) { return _this.id3MetadataOwner[key]; });
	        var owner = owners.find(function (o) { return segment.includes(o); }) || null;
	        var dataValue = owner
	            ? segment
	                .substring(segment.lastIndexOf(owner) + owner.length)
	                .trim()
	                .replace(/\0/g, '')
	            : null;
	        var metadata = new ID3Metadata(tag, owner, dataValue);
	        loglevel.trace('ChromecastPlayerAdaptor._id3Handler', 'tag:', tag, 'owner:', owner, 'dataValue:', dataValue);
	        this.emit(PlayerAdaptorEvent$1.timedMetadata, metadata);
	    };
	    ChromecastPlayerAdaptor.prototype.timeUpdateHandler = function (event) {
	        var currentTime = event.currentMediaTime;
	        this.emit(PlayerAdaptorEvent$1.currentTime, currentTime);
	    };
	    ChromecastPlayerAdaptor.prototype.playingHandler = function (event) {
	        var currentTime = event.currentMediaTime;
	        this.emit(PlayerAdaptorEvent$1.playing, currentTime);
	    };
	    ChromecastPlayerAdaptor.prototype.pauseHandler = function (event) {
	        var currentTime = event.currentMediaTime;
	        this.emit(PlayerAdaptorEvent$1.pause, currentTime);
	    };
	    ChromecastPlayerAdaptor.prototype.mediaFinishedHandler = function (event) {
	        loglevel.debug('ChromecastPlayerAdaptor: MEDIA_FINISHED', event);
	        this.emit(PlayerAdaptorEvent$1.stop);
	        this.cleanup();
	    };
	    ChromecastPlayerAdaptor.prototype.stop = function (error) {
	        if (error) {
	            loglevel.warn('ChromecastPlayerAdaptor.stop', error.message);
	        }
	    };
	    ChromecastPlayerAdaptor.prototype.cleanup = function () {
	        if (!this.nativePlayer) {
	            return;
	        }
	        this.nativePlayer.removeEventListener(cast.framework.events.EventType.PLAYER_LOAD_COMPLETE, this.loadCompleteHandler);
	        this.nativePlayer.removeEventListener(cast.framework.events.EventType.ID3, this.id3Handler);
	        this.nativePlayer.removeEventListener(cast.framework.events.EventType.MEDIA_FINISHED, this.mediaFinishedHandler);
	        this.nativePlayer.removeEventListener(cast.framework.events.EventType.TIME_UPDATE, this.timeUpdateHandler);
	        this.nativePlayer.removeEventListener(cast.framework.events.EventType.PAUSE, this.pauseHandler);
	    };
	    return ChromecastPlayerAdaptor;
	})(TinyEmitter));

	((function (_super) {
	    __extends(HTML5PlayerAdaptor, _super);
	    function HTML5PlayerAdaptor(nativePlayer) {
	        var _this = _super.call(this) || this;
	        _this.nativePlayer = nativePlayer;
	        _this.bindEventListeners();
	        return _this;
	    }
	    HTML5PlayerAdaptor.prototype.bindEventListeners = function () {
	        var _this = this;
	        if (!this.nativePlayer) {
	            loglevel.error("Native Player wasn't passed to HTML5PlayerAdaptor");
	            return;
	        }
	        this.onPlay = this.onPlay.bind(this);
	        this.onPause = this.onPause.bind(this);
	        this.onSeek = this.onSeek.bind(this);
	        this.onCurrentTime = this.onCurrentTime.bind(this);
	        this.onStalled = this.onStalled.bind(this);
	        this.stop = this.stop.bind(this);
	        this.onError = this.onError.bind(this);
	        this.cleanup = this.cleanup.bind(this);
	        this.nativePlayer.addEventListener('play', this.onPlay);
	        this.nativePlayer.addEventListener('pause', this.onPause);
	        this.nativePlayer.addEventListener('seeking', this.onSeek);
	        this.nativePlayer.addEventListener('ended', this.stop);
	        this.nativePlayer.addEventListener('error', this.onError);
	        this.nativePlayer.addEventListener('timeUpdate', this.onCurrentTime);
	        this.nativePlayer.addEventListener('stalled', this.onStalled);
	        this.nativePlayer.textTracks.onaddtrack = function (event) {
	            var track = event.track;
	            if (!track || track.kind !== 'metadata') {
	                return;
	            }
	            track.addEventListener('cuechange', function (event) {
	                var track = event.target;
	                if (!track || track.kind !== 'metadata') {
	                    return;
	                }
	                var values = [];
	                for (var i = 0; i < track.activeCues.length; i++) {
	                    var activeCues = track.activeCues[i];
	                    values.push(activeCues.value);
	                }
	                values.map(function (value) {
	                    var tag = value.key;
	                    var owner = value.info;
	                    var dataValue = value.data;
	                    if (dataValue instanceof ArrayBuffer) {
	                        dataValue = String.fromCharCode.apply(null, new Uint8Array(dataValue));
	                    }
	                    var metadata = new ID3Metadata(tag, owner, dataValue);
	                    loglevel.trace('HTML5PlayerAdaptor timedMetadata', metadata);
	                    _this.emit(PlayerAdaptorEvent$1.timedMetadata, metadata);
	                });
	            });
	        };
	    };
	    HTML5PlayerAdaptor.prototype.onPlay = function (event) {
	        this.emit(PlayerAdaptorEvent$1.start, event.timeStamp);
	    };
	    HTML5PlayerAdaptor.prototype.onPause = function () {
	        this.emit(PlayerAdaptorEvent$1.pause);
	    };
	    HTML5PlayerAdaptor.prototype.onSeek = function () {
	        this.emit(PlayerAdaptorEvent$1.seeking);
	    };
	    HTML5PlayerAdaptor.prototype.onError = function () {
	        this.emit(PlayerAdaptorEvent$1.stop);
	        this.cleanup();
	    };
	    HTML5PlayerAdaptor.prototype.onCurrentTime = function (event) {
	        this.emit(PlayerAdaptorEvent$1.currentTime, event.timeStamp);
	    };
	    HTML5PlayerAdaptor.prototype.onStalled = function (event) {
	        this.emit(PlayerAdaptorEvent$1.stalled, event.timeStamp);
	    };
	    HTML5PlayerAdaptor.prototype.stop = function () {
	        this.nativePlayer.pause();
	        this.nativePlayer.setAttribute('src', '');
	        this.nativePlayer.removeAttribute('src');
	        this.nativePlayer.currentTime = 0;
	        this.emit(PlayerAdaptorEvent$1.stop);
	        this.cleanup();
	    };
	    HTML5PlayerAdaptor.prototype.cleanup = function () {
	        this.nativePlayer.removeEventListener('play', this.onPlay);
	        this.nativePlayer.removeEventListener('pause', this.onPause);
	        this.nativePlayer.removeEventListener('error', this.onError);
	        this.nativePlayer.removeEventListener('seeking', this.onSeek);
	        this.nativePlayer.removeEventListener('stalled', this.onStalled);
	        this.nativePlayer.removeEventListener('timeupdate', this.onCurrentTime);
	        this.nativePlayer.removeEventListener('ended', this.stop);
	    };
	    return HTML5PlayerAdaptor;
	})(TinyEmitter));

	var TrilithiumPlayerEvent;
	(function (TrilithiumPlayerEvent) {
	    TrilithiumPlayerEvent["opened"] = "opened";
	    TrilithiumPlayerEvent["playing"] = "playing";
	    TrilithiumPlayerEvent["ended"] = "ended";
	    TrilithiumPlayerEvent["timedMetadata"] = "timedMetadata";
	    TrilithiumPlayerEvent["error"] = "error";
	    TrilithiumPlayerEvent["timeUpdate"] = "timeUpdate";
	    TrilithiumPlayerEvent["stalled"] = "stalled";
	    TrilithiumPlayerEvent["paused"] = "paused";
	    TrilithiumPlayerEvent["seeking"] = "seeking";
	})(TrilithiumPlayerEvent || (TrilithiumPlayerEvent = {}));
	var TrilithiumPlayerEvent$1 = TrilithiumPlayerEvent;

	((function (_super) {
	    __extends(TrilithiumPlayerAdaptor, _super);
	    function TrilithiumPlayerAdaptor(nativePlayer, bus) {
	        var _this = _super.call(this) || this;
	        if (!nativePlayer) {
	            throw new Error('nativePlayer must be supplied');
	        }
	        _this.nativePlayer = nativePlayer;
	        _this.bus = bus;
	        _this.bindEventListeners();
	        return _this;
	    }
	    TrilithiumPlayerAdaptor.prototype.bindEventListeners = function () {
	        this.onSeeking = this.onSeeking.bind(this);
	        this.onStalled = this.onStalled.bind(this);
	        this.onTimeUpdate = this.onTimeUpdate.bind(this);
	        this.onPlaying = this.onPlaying.bind(this);
	        this.onPaused = this.onPaused.bind(this);
	        this.onError = this.onError.bind(this);
	        this.onEnded = this.onEnded.bind(this);
	        this.onTimedMetadata = this.onTimedMetadata.bind(this);
	        this.onOpened = this.onOpened.bind(this);
	        if (this.bus) {
	            this.bus.on(TrilithiumPlayerEvent$1.opened, this.onOpened);
	            this.bus.on(TrilithiumPlayerEvent$1.playing, this.onPlaying);
	            this.bus.on(TrilithiumPlayerEvent$1.paused, this.onPaused);
	            this.bus.on(TrilithiumPlayerEvent$1.timedMetadata, this.onTimedMetadata);
	            this.bus.on(TrilithiumPlayerEvent$1.ended, this.onEnded);
	            this.bus.on(TrilithiumPlayerEvent$1.error, this.onError);
	            this.bus.on(TrilithiumPlayerEvent$1.timeUpdate, this.onTimeUpdate);
	            this.bus.on(TrilithiumPlayerEvent$1.stalled, this.onStalled);
	            this.bus.on(TrilithiumPlayerEvent$1.seeking, this.onSeeking);
	        }
	        else {
	            this.nativePlayer.onOpened = this.onOpened;
	            this.nativePlayer.onPlaying = this.onPlaying;
	            this.nativePlayer.onTimedMetadata = this.onTimedMetadata;
	            this.nativePlayer.onEnded = this.onEnded;
	            this.nativePlayer.onError = this.onError;
	            this.nativePlayer.onTimeUpdate = this.onTimeUpdate;
	            this.nativePlayer.onStalled = this.onStalled;
	            this.nativePlayer.onSeeking = this.onSeeking;
	        }
	    };
	    TrilithiumPlayerAdaptor.prototype.onSeeking = function () {
	        var currentTime = this.nativePlayer.currentTime;
	        loglevel.debug('TrilithiumPlayerAdaptor.onSeeking', currentTime);
	        this.emit(PlayerAdaptorEvent$1.seeking, currentTime);
	    };
	    TrilithiumPlayerAdaptor.prototype.onStalled = function () {
	        var currentTime = this.nativePlayer.currentTime;
	        loglevel.debug('TrilithiumPlayerAdaptor.onStalled', currentTime);
	        this.emit(PlayerAdaptorEvent$1.stalled, currentTime);
	    };
	    TrilithiumPlayerAdaptor.prototype.onTimeUpdate = function () {
	        var currentTime = this.nativePlayer.currentTime;
	        loglevel.debug('TrilithiumPlayerAdaptor.onTimeUpdate', currentTime);
	        this.emit(PlayerAdaptorEvent$1.currentTime, currentTime);
	    };
	    TrilithiumPlayerAdaptor.prototype.onError = function (errorCode) {
	        loglevel.debug('TrilithiumPlayerAdaptor.onError', errorCode);
	        this.emit(PlayerAdaptorEvent$1.stop);
	        this.cleanup();
	    };
	    TrilithiumPlayerAdaptor.prototype.onEnded = function () {
	        this.emit(PlayerAdaptorEvent$1.stop);
	        this.cleanup();
	    };
	    TrilithiumPlayerAdaptor.prototype.onTimedMetadata = function (pts, frameId, blob) {
	        var tag = frameId;
	        var owner = blob.toString();
	        var segment = encUtf8.stringify(encBase64.parse(blob.toString('base64')));
	        var dataValue = owner
	            ? segment
	                .substring(segment.lastIndexOf(owner) + owner.length)
	                .trim()
	                .replace(/\0/g, '')
	            : segment;
	        loglevel.debug("TrilithiumPlayerAdaptor.onTimedMetadata " + tag + " " + owner + " " + dataValue);
	        var id3Metadata = new ID3Metadata(tag, owner, dataValue);
	        this.emit(PlayerAdaptorEvent$1.timedMetadata, id3Metadata);
	    };
	    TrilithiumPlayerAdaptor.prototype.onOpened = function (success) {
	        if (!success) {
	            return;
	        }
	        loglevel.debug('TrilithiumPlayerAdaptor.onOpened');
	        this.emit(PlayerAdaptorEvent$1.start);
	    };
	    TrilithiumPlayerAdaptor.prototype.onPlaying = function () {
	        var currentTime = this.nativePlayer.currentTime;
	        loglevel.debug('TrilithiumPlayerAdaptor.onPlaying', currentTime);
	        this.emit(PlayerAdaptorEvent$1.playing, currentTime);
	    };
	    TrilithiumPlayerAdaptor.prototype.onPaused = function () {
	        var currentTime = this.nativePlayer.currentTime;
	        loglevel.debug('TrilithiumPlayerAdaptor.onPaused', currentTime);
	        this.emit(PlayerAdaptorEvent$1.pause, currentTime);
	    };
	    TrilithiumPlayerAdaptor.prototype.stop = function (error) {
	        if (error) {
	            loglevel.warn('TrilithiumPlayerAdaptor.stop', error.message);
	        }
	    };
	    TrilithiumPlayerAdaptor.prototype.cleanup = function () {
	        if (this.bus) {
	            this.bus.off(TrilithiumPlayerEvent$1.opened);
	            this.bus.off(TrilithiumPlayerEvent$1.playing);
	            this.bus.off(TrilithiumPlayerEvent$1.timedMetadata);
	            this.bus.off(TrilithiumPlayerEvent$1.ended);
	            this.bus.off(TrilithiumPlayerEvent$1.error);
	            this.bus.off(TrilithiumPlayerEvent$1.timeUpdate);
	            this.bus.off(TrilithiumPlayerEvent$1.stalled);
	        }
	    };
	    return TrilithiumPlayerAdaptor;
	})(TinyEmitter));

	var PlayerState = {
	    IDLE: 0,
	    INITIALIZING: 1,
	    INITIALIZED: 2,
	    PREPARING: 3,
	    PREPARED: 4,
	    BUFFERING: 5,
	    PAUSED: 6,
	    SEEKING: 7,
	    PLAYING: 8,
	    STOPPING: 9,
	    STOPPED: 10,
	    COMPLETE: 11,
	    ERROR: 12,
	    RELEASED: 13,
	};
	((function (_super) {
	    __extends(AampUvePlayerAdapter, _super);
	    function AampUvePlayerAdapter(nativePlayer) {
	        var _this = _super.call(this) || this;
	        _this.nativePlayer = nativePlayer;
	        _this.id3MetadataOwner = new ID3MetadataOwner();
	        return _this;
	    }
	    AampUvePlayerAdapter.prototype.onTimedMetaData = function (event) {
	        var _this = this;
	        var data = event.data;
	        var segment = String.fromCharCode.apply(null, data);
	        var tag = ['PRIV', 'TXXX'].find(function (t) { return segment.includes(t); }) || null;
	        var owners = Object.keys(this.id3MetadataOwner).map(function (key) { return _this.id3MetadataOwner[key]; });
	        var owner = owners.find(function (o) { return segment.includes(o); }) || null;
	        var dataValue = owner
	            ? segment
	                .substring(segment.lastIndexOf(owner) + owner.length)
	                .trim()
	                .replace(/\0/g, '')
	            : null;
	        var id3Metadata = new ID3Metadata(tag, owner, dataValue);
	        loglevel.trace('AampUvePlayerAdapter timedMetadata', id3Metadata);
	        this.emit(PlayerAdaptorEvent$1.timedMetadata, id3Metadata);
	    };
	    AampUvePlayerAdapter.prototype.onPlaybackStateChanged = function (event) {
	        switch (event.state) {
	            case PlayerState.PAUSED:
	                this.emit(PlayerAdaptorEvent$1.pause);
	                break;
	            case PlayerState.SEEKING:
	                this.emit(PlayerAdaptorEvent$1.seeking);
	                break;
	            case PlayerState.ERROR:
	                this.emit(PlayerAdaptorEvent$1.stop);
	                this.cleanup();
	                break;
	            case PlayerState.COMPLETE:
	                this.emit(PlayerAdaptorEvent$1.stop);
	                this.cleanup();
	                break;
	        }
	    };
	    AampUvePlayerAdapter.prototype.onPlay = function () {
	        this.emit(PlayerAdaptorEvent$1.start);
	    };
	    AampUvePlayerAdapter.prototype.onCurrentTime = function (event) {
	        this.emit(PlayerAdaptorEvent$1.currentTime, event.positionMiliseconds);
	    };
	    AampUvePlayerAdapter.prototype.onError = function () {
	        this.emit(PlayerAdaptorEvent$1.stop);
	        this.cleanup();
	    };
	    AampUvePlayerAdapter.prototype.stop = function () {
	        this.emit(PlayerAdaptorEvent$1.stop);
	        this.cleanup();
	    };
	    AampUvePlayerAdapter.prototype.cleanup = function () { };
	    return AampUvePlayerAdapter;
	})(TinyEmitter));

	var NielsenEnvironment = {
	    production: 'PROD',
	    testing: 'TESTING',
	};
	var serviceUrls = {};
	serviceUrls[NielsenEnvironment.production] = 'https://cloudapi.imrworldwide.com/nmapi/v2';
	serviceUrls[NielsenEnvironment.testing] = 'https://sandbox-cloudapi.imrworldwide.com/nmapi/v2';

	async function fetchMediaItemFromApi(playLoad) {
	  try {
	    const {
	      identifier,
	      mediaItemApi = new UniversalMediaItemAPI(),
	      contentApi = {}
	    } = playLoad;
	    const {
	      env,
	      apiSource,
	      serviceUrl
	    } = contentApi;

	    if (env === 'qa' && apiSource && serviceUrl) {
	      mediaItemApi.configuration = new Configuration$2(apiSource, serviceUrl);
	    }

	    const mediaItems = await mediaItemApi.getMediaItems([identifier], {});

	    if (mediaItems && isArray$1(mediaItems)) {
	      return mediaItems.shift();
	    }

	    throw new Error('mediaItem returns null');
	  } catch (err) {
	    console.error(`Get media items error: ${err}`);
	    return null;
	  }
	}

	var lodash_mergewith = createCommonjsModule(function (module, exports) {
	/**
	 * Lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    asyncTag = '[object AsyncFunction]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    nullTag = '[object Null]',
	    objectTag = '[object Object]',
	    proxyTag = '[object Proxy]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    undefinedTag = '[object Undefined]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Detect free variable `exports`. */
	var freeExports = exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    // Use `util.types` for Node.js 10+.
	    var types = freeModule && freeModule.require && freeModule.require('util').types;

	    if (types) {
	      return types;
	    }

	    // Legacy `process.binding('util')` for Node.js < 10.
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
	    getPrototype = overArg(Object.getPrototypeOf, Object),
	    objectCreate = Object.create,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice,
	    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	    nativeMax = Math.max,
	    nativeNow = Date.now;

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map'),
	    nativeCreate = getNative(Object, 'create');

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue(object, key, value) {
	  if ((value !== undefined && !eq(object[key], value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  baseFor(source, function(srcValue, key) {
	    stack || (stack = new Stack);
	    if (isObject(srcValue)) {
	      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	    }
	    else {
	      var newValue = customizer
	        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
	        : undefined;

	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      assignMergeValue(object, key, newValue);
	    }
	  }, keysIn);
	}

	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = safeGet(object, key),
	      srcValue = safeGet(source, key),
	      stacked = stack.get(srcValue);

	  if (stacked) {
	    assignMergeValue(object, key, stacked);
	    return;
	  }
	  var newValue = customizer
	    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	    : undefined;

	  var isCommon = newValue === undefined;

	  if (isCommon) {
	    var isArr = isArray(srcValue),
	        isBuff = !isArr && isBuffer(srcValue),
	        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

	    newValue = srcValue;
	    if (isArr || isBuff || isTyped) {
	      if (isArray(objValue)) {
	        newValue = objValue;
	      }
	      else if (isArrayLikeObject(objValue)) {
	        newValue = copyArray(objValue);
	      }
	      else if (isBuff) {
	        isCommon = false;
	        newValue = cloneBuffer(srcValue, true);
	      }
	      else if (isTyped) {
	        isCommon = false;
	        newValue = cloneTypedArray(srcValue, true);
	      }
	      else {
	        newValue = [];
	      }
	    }
	    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	      newValue = objValue;
	      if (isArguments(objValue)) {
	        newValue = toPlainObject(objValue);
	      }
	      else if (!isObject(objValue) || isFunction(objValue)) {
	        newValue = initCloneObject(srcValue);
	      }
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  assignMergeValue(object, key, newValue);
	}

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	  buffer.copy(result);
	  return result;
	}

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	  return result;
	}

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype(object))
	    : {};
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	/**
	 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function safeGet(object, key) {
	  if (key === 'constructor' && typeof object[key] === 'function') {
	    return;
	  }

	  if (key == '__proto__') {
	    return;
	  }

	  return object[key];
	}

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject(value) {
	  return copyObject(value, keysIn(value));
	}

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	/**
	 * This method is like `_.merge` except that it accepts `customizer` which
	 * is invoked to produce the merged values of the destination and source
	 * properties. If `customizer` returns `undefined`, merging is handled by the
	 * method instead. The `customizer` is invoked with six arguments:
	 * (objValue, srcValue, key, object, source, stack).
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} sources The source objects.
	 * @param {Function} customizer The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * function customizer(objValue, srcValue) {
	 *   if (_.isArray(objValue)) {
	 *     return objValue.concat(srcValue);
	 *   }
	 * }
	 *
	 * var object = { 'a': [1], 'b': [2] };
	 * var other = { 'a': [3], 'b': [4] };
	 *
	 * _.mergeWith(object, other, customizer);
	 * // => { 'a': [1, 3], 'b': [2, 4] }
	 */
	var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
	  baseMerge(object, source, srcIndex, customizer);
	});

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = mergeWith;
	});

	// prettier-ignore
	var config$1 = {
	  mailToLink: 'mailto:?subject={{subject}}&body={{body}}',
	  sendMailUrl: 'http://proxy.espn.com/videohub/player/sendMail?id={{id}}&clipName={{clipName}}&youremail={{youremail}}&friendemail={{friendemail}}&message={{message}}&videoImage={{videoImage}}',
	  embedCode: '<iframe width="640" height="360" src="http://www.espn.com/core/video/iframe?id={{ID}}&endcard=false" allowfullscreen frameborder="0"></iframe>',
	  deeplinking: true,
	  services: {
	    facebook: true,
	    google: false,
	    twitter: true,
	    tumblr: false,
	    pinterest: false,
	    linkedin: false,
	    email: true,
	    directlink: true,
	    embed: true
	  }
	};

	function mergeCustomizer$2(objValue, srcValue) {
	  if (srcValue === null) {
	    return objValue;
	  }
	}
	class Social {
	  constructor(mediainfo, options, brand) {
	    this.opts = null;
	    this.opts = lodash_mergewith({}, config$1, mergeCustomizer$2);

	    if (options && typeof options === 'object') {
	      lodash_mergewith(this.opts, options, mergeCustomizer$2);
	    }

	    if (brand) {
	      this.opts.brand = brand;
	    }

	    this.opts = this.updateOptions(mediainfo, this.opts);
	  }

	  updateOptions(mediainfo, options) {
	    options.id = options.id || mediainfo.id;
	    options.brand = options.brand || mediainfo.brand;
	    options.title = mediainfo.headline || mediainfo.pageTitle;
	    options.description = mediainfo.description;
	    options.url = mediainfo.webHref ? mediainfo.webHref : options.url && options.url.replace(/{{ID}}/g, mediainfo.id) || options.url || mediainfo.web;
	    options.poster = mediainfo.poster;
	    options.syndicatable = !!mediainfo.syndicatable;
	    options.embedCode = options.embedCode && options.embedCode.replace(/{{ID}}/g, mediainfo.id);
	    options.pauseOnOpen = true;
	    options.showOffset = true;

	    if (options.services && options.services.embed) {
	      options.services.embed = options.syndicatable;
	    }

	    if (mediainfo.type === 'live') {
	      options.pauseOnOpen = false;
	      options.showOffset = false;
	    }

	    return options;
	  }

	  get options() {
	    return this.opts;
	  }

	  set options(options) {
	    this.opts = options;
	  }

	}

	var propertyIsEnumerable = objectPropertyIsEnumerable.f;

	// `Object.{ entries, values }` methods implementation
	var createMethod = function (TO_ENTRIES) {
	  return function (it) {
	    var O = toIndexedObject(it);
	    var keys = objectKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) {
	      key = keys[i++];
	      if (!descriptors || propertyIsEnumerable.call(O, key)) {
	        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
	      }
	    }
	    return result;
	  };
	};

	var objectToArray = {
	  // `Object.entries` method
	  // https://tc39.es/ecma262/#sec-object.entries
	  entries: createMethod(true),
	  // `Object.values` method
	  // https://tc39.es/ecma262/#sec-object.values
	  values: createMethod(false)
	};

	var $entries = objectToArray.entries;

	// `Object.entries` method
	// https://tc39.es/ecma262/#sec-object.entries
	_export({ target: 'Object', stat: true }, {
	  entries: function entries(O) {
	    return $entries(O);
	  }
	});

	var entries$2 = path.Object.entries;

	var entries$1 = entries$2;

	var entries = entries$1;

	var trim$3 = stringTrim.trim;


	var $parseInt = global_1.parseInt;
	var hex = /^[+-]?0[Xx]/;
	var FORCED$2 = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22;

	// `parseInt` method
	// https://tc39.es/ecma262/#sec-parseint-string-radix
	var numberParseInt = FORCED$2 ? function parseInt(string, radix) {
	  var S = trim$3(String(string));
	  return $parseInt(S, (radix >>> 0) || (hex.test(S) ? 16 : 10));
	} : $parseInt;

	// `parseInt` method
	// https://tc39.es/ecma262/#sec-parseint-string-radix
	_export({ global: true, forced: parseInt != numberParseInt }, {
	  parseInt: numberParseInt
	});

	var _parseInt$2 = path.parseInt;

	var _parseInt$1 = _parseInt$2;

	var _parseInt = _parseInt$1;

	class Cookie {
	  /**
	   * @param {boolean} hasDocumentCookie
	   * --checks if we can get/set cookies on document.cookie
	   */
	  constructor(hasDocumentCookie) {
	    this._hasDocumentCookie = false;
	    this._hasDocumentCookie = hasDocumentCookie;
	  }

	  get(key) {
	    if (this._hasDocumentCookie) {
	      const splat = document.cookie.split(/;\s*/);

	      for (let i = 0; i < splat.length; i += 1) {
	        const ps = splat[i].split('=');
	        const k = decodeURIComponent(ps[0]);

	        if (k === key) {
	          return decodeURIComponent(ps[1]);
	        }
	      }
	    }

	    return null;
	  }

	  set(key, value, opts = {}) {
	    if (this._hasDocumentCookie) {
	      const {
	        domain,
	        expires,
	        path,
	        secure
	      } = opts;
	      let s = `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;

	      if (expires) {
	        s += `; expires=${expires}`;
	      }

	      if (path) {
	        s += `; path=${encodeURIComponent(path)}`;
	      }

	      if (domain) {
	        s += `; domain=${encodeURIComponent(domain)}`;
	      }

	      if (secure) {
	        s += '; secure';
	      }

	      document.cookie = s;
	      return s;
	    }

	    return null;
	  }

	}

	function hasDocumentCookie() {
	  // Can we get/set cookies on document.cookie?
	  return typeof document === 'object' && typeof document.cookie === 'string';
	}

	var $stringify = getBuiltIn('JSON', 'stringify');
	var re = /[\uD800-\uDFFF]/g;
	var low = /^[\uD800-\uDBFF]$/;
	var hi = /^[\uDC00-\uDFFF]$/;

	var fix = function (match, offset, string) {
	  var prev = string.charAt(offset - 1);
	  var next = string.charAt(offset + 1);
	  if ((low.test(match) && !hi.test(next)) || (hi.test(match) && !low.test(prev))) {
	    return '\\u' + match.charCodeAt(0).toString(16);
	  } return match;
	};

	var FORCED$1 = fails(function () {
	  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
	    || $stringify('\uDEAD') !== '"\\udead"';
	});

	if ($stringify) {
	  // `JSON.stringify` method
	  // https://tc39.es/ecma262/#sec-json.stringify
	  // https://github.com/tc39/proposal-well-formed-stringify
	  _export({ target: 'JSON', stat: true, forced: FORCED$1 }, {
	    // eslint-disable-next-line no-unused-vars -- required for `.length`
	    stringify: function stringify(it, replacer, space) {
	      var result = $stringify.apply(null, arguments);
	      return typeof result == 'string' ? result.replace(re, fix) : result;
	    }
	  });
	}

	// eslint-disable-next-line es/no-json -- safe
	if (!path.JSON) path.JSON = { stringify: JSON.stringify };

	// eslint-disable-next-line no-unused-vars -- required for `.length`
	var stringify$2 = function stringify(it, replacer, space) {
	  return path.JSON.stringify.apply(null, arguments);
	};

	var stringify$1 = stringify$2;

	var stringify = stringify$1;

	var FAILS_ON_PRIMITIVES = fails(function () { objectKeys(1); });

	// `Object.keys` method
	// https://tc39.es/ecma262/#sec-object.keys
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
	  keys: function keys(it) {
	    return objectKeys(toObject(it));
	  }
	});

	var keys$2 = path.Object.keys;

	var keys$1 = keys$2;

	var keys = keys$1;

	class Storage {
	  constructor(storage, key) {
	    this._key = null;
	    this.storage = storage;
	    this._key = key;
	  }
	  /**
	   * @description get fan in localStorage
	   * @return {object} fan
	   */


	  getFan() {
	    const item = this.storage && this.storage.getItem(this._key);

	    if (item) {
	      return promise.resolve(JSON.parse(item));
	    }

	    return promise.reject(new Error('getFan from localstorage failed'));
	  }
	  /**
	   * @description set fan in localStorage
	   * @param {object} fan
	   */


	  setFan(fan) {
	    if (this.storage) {
	      const value = {
	        item: fan.item,
	        id: fan.id,
	        timestamp: now()
	      };
	      this.storage.setItem(this._key, stringify(value));
	    }
	  }

	}

	const FAN_PRODUCT_PROD_HOST = 'https://fan.api.espn.com';
	const FAN_CORE_PROD_HOST = 'https://fan.core.api.espn.com';
	const DEFAULT_SOURCE_HEADER = 'espn-video-player'; // watchespn-web // ESPN.com - FAM

	const FAN_API_CACHE_MINUTES = 10;
	const FAN_STORAGE_KEY = 'fanapi_fan';
	const config = {
	  sourceHeader: DEFAULT_SOURCE_HEADER,
	  cacheDuration: FAN_API_CACHE_MINUTES,
	  fanProdHost: FAN_PRODUCT_PROD_HOST,
	  fanCoreHost: FAN_CORE_PROD_HOST,
	  storageKey: FAN_STORAGE_KEY
	};

	class FanAPI {
	  get storage() {
	    return this._storage;
	  }

	  constructor(sourceHeader = config.sourceHeader, cacheDuration = config.cacheDuration, storage = new Storage(window.localStorage, config.storageKey)) {
	    this._sourceHeader = null;
	    this._cacheDuration = 0;
	    this._storage = null;
	    this._sourceHeader = sourceHeader;
	    this._cacheDuration = cacheDuration;
	    this._storage = storage;
	  }

	  async fetchFan(url) {
	    const headers = {
	      'X-Personalization-Source': this._sourceHeader
	    };
	    const payload = {
	      method: 'GET',
	      headers,
	      credentials: 'include'
	    };
	    let res = null;

	    try {
	      const response = await fetch(url, payload);
	      const fan = await response.json();

	      if (fan.id) {
	        res = fan;
	        this.storage.setFan({
	          item: fan,
	          id: fan.id,
	          timestamp: now()
	        });
	      }
	    } catch (err) {
	      console.error(`fetchFan error: ${err}`);
	    }

	    return res;
	  }

	  async getFanForId(id) {
	    let fan = null;

	    try {
	      const cache = await this.storage.getFan();
	      fan = cache && cache.item;
	      const cacheExpired = now() - cache.timestamp > this._cacheDuration * 60 * 1000;

	      if (fan === null || fan.id !== id || cacheExpired) {
	        // not a valid fan, fetchFan from user profile
	        const url = `${config.fanProdHost}/apis/v2/fans/${id}`;
	        fan = this.fetchFan(url);
	      }
	    } catch (err) {
	      console.error(`getFanForId error: ${err}`); // onError, fetchFan from user profile

	      const url = `${config.fanProdHost}/apis/v2/fans/${id}`;
	      fan = this.fetchFan(url);
	    }

	    return fan;
	  }

	  getAutoPlayOnCatch() {
	    const domestic = ['local.espn.com', 'www.espnqa.com', 'www.espn.com'];
	    let isDomestic = false;
	    const isGamepackage = window.localStorage.getItem('isGamepackageAutoPlay') === '1';

	    if (window && window.location && window.location.hostname) {
	      isDomestic = indexOf(domestic).call(domestic, window.location.hostname) > -1;
	    }

	    if (isDomestic && !isGamepackage) {
	      return false;
	    }

	    return true;
	  }

	  async getAutoStartForFanId(id, callback) {
	    let autoPlay = null;

	    try {
	      const fan = await this.getFanForId(id);

	      if (fan !== null) {
	        const {
	          profile
	        } = fan;
	        const settings = profile && profile.settings;
	        const videoAutoStartValue = settings && settings.videoAutoStart && settings.videoAutoStart.value;
	        autoPlay = videoAutoStartValue !== '2';
	      }
	    } catch (err) {
	      console.error(`getAutoStartForFanId failed: ${err}`);
	      autoPlay = this.getAutoPlayOnCatch();
	    }

	    if (autoPlay !== null && typeof callback === 'function') {
	      callback(autoPlay);
	    }
	  }

	  async updateSettingsForFanId(url, postData) {
	    const headers = {
	      'Content-Type': 'application/json',
	      'X-Personalization-Source': this._sourceHeader
	    };
	    const payload = {
	      method: 'POST',
	      headers,
	      credentials: 'include',
	      body: stringify(postData)
	    };
	    const response = await fetch(url, payload);
	    return response;
	  }

	  async updateAutoStartForFanId(id, autoStart) {
	    const videoAutoStartValue = (autoStart ? '1' : '2').toString();
	    const postData = {
	      settings: {
	        videoAutoStart: {
	          value: videoAutoStartValue,
	          lastUpdateSource: this._sourceHeader,
	          lastUpdateDate: now()
	        }
	      }
	    };

	    try {
	      const url = `${config.fanCoreHost}/apis/v2/fans/${id}/profile/`;
	      await this.updateSettingsForFanId(url, postData);
	    } catch (err) {
	      console.error(`Update autoStart settings for fan failed: ${err}`);
	    } finally {
	      // update autoStart cache regardless of the update result
	      this.updateAutoStartCache(postData.settings);
	    }
	  }

	  async updateAutoStartCache(settings) {
	    const {
	      videoAutoStart
	    } = settings;

	    try {
	      const cache = await this.storage.getFan();
	      const fan = cache && cache.item;

	      if (fan) {
	        var _context;

	        forEach(_context = keys(videoAutoStart)).call(_context, key => {
	          fan.profile.settings.videoAutoStart[key] = videoAutoStart[key];
	        });

	        this.storage.setFan({
	          item: fan,
	          id: fan.id,
	          timestamp: now()
	        });
	      }
	    } catch (err) {
	      console.error(`updateAutoStartCache failed: ${err}`);
	    }
	  }

	}

	class Fan {
	  set SWID(v) {
	    this._SWID = v;
	  }

	  get SWID() {
	    return this._SWID;
	  }

	  get UNID() {
	    return this._UNID;
	  }

	  constructor(api = new FanAPI(), c = new Cookie(hasDocumentCookie())) {
	    this._SWID = null;
	    this._UNID = null;
	    this.fanApi = api;
	    this.cookie = c;
	    this._SWID = this.cookie.get('SWID');
	    this._UNID = this.cookie.get('UNID');
	  }

	  isValidSwid(id) {
	    const swidRe = /^{[\w-]+}/;
	    return swidRe.test(id);
	  }

	  async getAutoStart() {
	    let autoPlay = true;
	    const vas = this.cookie.get('VAS');

	    if (vas) {
	      autoPlay = _parseInt(vas, 10) === 1;
	    }

	    if (this.isValidSwid(this.SWID)) {
	      await this.fanApi.getAutoStartForFanId(this.SWID, autoStart => {
	        autoPlay = autoStart === true || autoStart === false ? autoStart : autoPlay;
	        return autoPlay;
	      });
	    }

	    return autoPlay;
	  }

	  setAutoStart(value) {
	    let cbDomain;

	    if (window.location.hostname !== undefined) {
	      cbDomain = window.location.hostname.replace('www.', '');
	    } else {
	      cbDomain = 'espn.com';
	    }

	    if (value === true || value === false) {
	      this.cookie.set('VAS', value ? 1 : 2, {
	        domain: cbDomain,
	        expires: 365,
	        path: '/'
	      }); // support affinity sites

	      if (this.isValidSwid(this.SWID)) {
	        this.fanApi.updateAutoStartForFanId(this.SWID, value);
	      }
	    }
	  }

	}

	var defaultConfig = {
	  chartbeat: {
	    uid: '22222',
	    domain: 'espn.com',
	    sections: null,
	    authors: null
	  },
	  comscore: {
	    clientId: '3000005',
	    labels: {
	      c3: '"*null"',
	      c4: 'MediaInfo.site',
	      c6: 'MediaInfo.comscoreC6',
	      c8: 'MediaInfo.pageTitle',
	      ns_st_pu: 'MediaInfo.publisher',
	      // publisher brand name
	      ns_st_pr: '"*null"',
	      // program title
	      ns_st_ep: 'MediaInfo.name',
	      // episode title
	      ns_st_sn: '"*null"',
	      // episode season number
	      ns_st_en: '"*null"',
	      // episode number
	      ns_st_st: '"*null"',
	      // station title
	      ns_st_ge: '"sports"',
	      // content genre
	      ns_st_ti: '"*null"',
	      // TMS/Gracenote ID
	      ns_st_ia: '"*null"',
	      // ad load flag (Boolean, present means true) will be true for ESPN1 & ESPN2
	      ns_st_ce: '"*null"',
	      // complete episode flag
	      ns_st_ddt: '"*null"',
	      // digital airdate
	      ns_st_tdt: '"*null"',
	      // TV airdate
	      ns_st_ct: 'MediaInfo.comscoreContentType' // content type, see DTCIMMP-438

	    }
	  },
	  conviva: {
	    customerKey: '6f4780f3f1c410159773174fc103819d3763406e',
	    playerName: 'Unified Player Web',
	    DEBUG: false
	    /*
	      Plugin: Brightcove Perform Player (HTML5 1st/Flash Fallback) [c3.ESPN]
	      Documentation:	Conviva Community: Integrate: Plugins: Brightcove Perform Player
	      Production CUSTOMER_KEY:	766ee8daa5d5deaeeeab4481239072ea53f6f1cc
	      Test CUSTOMER_KEY:	4ef48c3f3b0803661e860a61b35963306389af7e
	       Plugin: Brightcove Perform Player (HTML5 1st/Flash Fallback) [c3.ESPN-com]
	      Documentation:	Conviva Community: Integrate: Plugins: Brightcove Perform Player
	      Production CUSTOMER_KEY:	fc8dbfdc5da519f576628f619306a357f31bd006
	      Test CUSTOMER_KEY:	eec329720efa1110d60c5a6d01a65baf032de653
	       Plugin: Brightcove Perform Player (HTML5 1st/Flash Fallback) [c3.ESPN-Intl]
	      Documentation:	Conviva Community: Integrate: Plugins: Brightcove Perform Player
	      Production CUSTOMER_KEY:	aff0675a75497f3e066783b2c5fd614c4e4d61cd
	      Test CUSTOMER_KEY:	e685ed240475325e03bff60be2ad80b41322ac74
	       Plugin: Brightcove Perform Player (HTML5) Prod [c3.DMED], Test [c3.DMED-Test]
	      Documentation:	https://community.conviva.com/site/one-sensor/sensors/javascript/index_one_sensor.gsp
	      Production CUSTOMER_KEY:	27f19c7c68e3eadf7756fb7efdb661dd8909acf9
	      Test CUSTOMER_KEY:	6f4780f3f1c410159773174fc103819d3763406e
	     */

	  },
	  adobeDCR: {
	    VISITOR_API: {
	      MARKETING_CLOUD_ORG_ID: 'EE0201AC512D2BE80A490D4C@AdobeOrg',
	      NAMESPACE: 'espn',
	      TRACKING_SERVER: 'sw88.espn.com',
	      TRACKING_SERVER_SECURE: 'sw88.espn.com'
	    },
	    APP_MEASUREMENT: {
	      RSID: 'wdgespredesign',
	      TRACKING_SERVER: 'sw88.espn.com',
	      TRACKING_SERVER_SECURE: 'sw88.espn.com'
	    },
	    HEARTBEAT: {
	      DISABLE: false,
	      // disable if using milestone tracking
	      TRACKING_SERVER: 'espn.hb.omtrdc.net',
	      PUBLISHER: 'EE0201AC512D2BE80A490D4C@AdobeOrg',
	      OVP: 'Brightcove',
	      SDK: '2.2.0',
	      DEBUG_LOGGING: false // sitecatalyst-specific logging - set to false for production

	    },
	    QUALITY: {
	      TIME_TO_START: 0
	    },
	    CUSTOM_EVENT: {
	      disable: true,
	      // disable if using heartbeat tracking
	      bc_data_mapping: {
	        name: 'eVar106,prop2',
	        // video name, accepts multiple eVars/props
	        segment: 'eVar203',
	        // current milestone (e.g., '1:M:0-25')
	        contentType: 'eVar201',
	        // content type (e.g., 'video' or 'ad')
	        timePlayed: 'event203',
	        // amount of time played since last tracking event, tracked with milestone events
	        view: 'event201',
	        // video start event
	        segmentView: 'event202',
	        // general milestone tracking event, tracked with milestone events
	        complete: 'event207',
	        // video complete event
	        milestones: {
	          // milestones in percent; milestones can be added/removed from list
	          25: 'event204',
	          // 25%
	          50: 'event205',
	          // 50%
	          75: 'event206' // 75%

	        }
	      },
	      // keep to track volume change events
	      bc_volumechange: {
	        event: 'event208',
	        // event tracking number
	        evar: 'prop1' // the new volume chosen by the user (from 0-1.00), only one prop/eVar supported here

	      },
	      // keep to track when user has paused an ad
	      bc_ad_pause: {
	        event: 'event209',
	        // event tracking number
	        evar: 'eVar205' // time value of pausing an ad, only one prop/eVar supported here

	      },
	      // keep to track when user enters full screen mode
	      bc_fullscreen_enter: {
	        event: 'event212' // event tracking number

	      },
	      // keep to track when user exits full screen mode
	      bc_fullscreen_exit: {
	        event: 'event213' // event tracking number

	      },
	      // keep to track when user opens social share menu
	      bc_social_opened: {
	        event: 'event214' // event tracking number

	      },
	      // keep to track when user closes social share menu
	      bc_social_closed: {
	        event: 'event215' // event tracking number

	      }
	    },
	    NIELSEN_DATA: {
	      /** ESPN TO CONFIGURE NIELSEN APPLICATION DATA * */
	      APP_INFO: {
	        clientId: 'us-600140-test',
	        vcid: 'b01',
	        apid: 'T31187EE2-AC6E-46CB-BB54-D07591BED067',
	        appName: 'BasicPlayerSample',
	        sfcode: 'dcr',
	        nol_sdkDebug: 'console',
	        nsdkv: '511'
	      },
	      CONFIG_KEY: '922e1d53d3e10abdde5cbea1b55459f5bacc65d4/55ba372b3336330017000bbf',
	      CONTENT_METADATA: {
	        type: 'content',
	        program: '',
	        segB: '',
	        segC: 'Sport/Program Code',
	        isfullepisode: '',
	        adloadtype: 2,
	        airdate: '',
	        dataSrc: 'CMS',
	        tv: false,
	        crossId2: 'ESPN',
	        assetid: '',
	        category: ''
	      },
	      AD_METADATA: []
	    },
	    ESPN_CUSTOM_METADATA: {},
	    MEDIAINFO: {},
	    DEBUG: false
	  },
	  nativeOmniture: {
	    trackingServer: 'sw88.espn.com',
	    reportSuites: 'wdgespcom,wdgespge',
	    secure: true,
	    site: 'espn'
	  }
	};

	function mergeCustomizer$1(objValue, srcValue) {
	  if (srcValue === null) {
	    return objValue;
	  }
	}

	class Analytics {
	  constructor() {
	    this.config_ = null;
	    this.convivaC3DMedAccounts_ = ['27f19c7c68e3eadf7756fb7efdb661dd8909acf9', '6f4780f3f1c410159773174fc103819d3763406e'];
	    this.defaultConfig_ = defaultConfig;
	    this.config_ = defaultConfig;
	  }

	  set config(obj) {
	    this.config_ = lodash_mergewith(defaultConfig, obj, mergeCustomizer$1);
	    return this.config_;
	  }

	  get config() {
	    return this.config_;
	  }

	  get isConvivaC3DMEDAccount() {
	    var _context;

	    const {
	      conviva: {
	        customerKey
	      } = {}
	    } = this.config;
	    return indexOf(_context = this.convivaC3DMedAccounts_).call(_context, customerKey) !== -1;
	  }

	  chartbeat(options) {
	    if (options) {
	      return lodash_mergewith(this.config.chartbeat, options, mergeCustomizer$1);
	    }

	    return this.config.chartbeat;
	  }
	  /*
	    The comScore plugin for Brightcove pulls all of it's data from the
	    `mediainfo` property. Configuration here consists of "mapping" labels to
	    respective keys of the `mediainfo` object. Most of the mapping is done
	    automatically, all we are doing here is manual overrides.
	     The plugin requires those keys be prefixed with `MediaInfo`.
	     If you need to provide a literal string, it needs to be double-quoted:
	        c3: '"*null"'
	   */


	  comscore(options) {
	    var _context2;

	    if (options) {
	      if (options.c2 || options.clientId) {
	        this.config.comscore.clientId = options.c2 || options.clientId;
	      }

	      if (options.labels) {
	        this.config.comscore.labels = lodash_mergewith(this.config.comscore.labels, options.labels);
	      }
	    }

	    const labelmap = [];
	    const ref = this.config.comscore.labels;

	    forEach(_context2 = entries(ref)).call(_context2, item => {
	      labelmap.push(`${item[0]}=${item[1]}`);
	    });

	    return {
	      c2: this.config.comscore.clientId,
	      labelmapping: labelmap.join(',')
	    };
	  }

	  conviva(options) {
	    if (options) {
	      lodash_mergewith(this.config.conviva, options, mergeCustomizer$1);
	    }

	    this.config.conviva.fanSWID = new Fan().SWID || null;
	    this.config.conviva.bundleVersion = "3.3.40";
	    return this.config.conviva;
	  }

	  adobeDCR(options) {
	    if (options) {
	      lodash_mergewith(this.config.adobeDCR, options, mergeCustomizer$1);
	    }

	    return this.config.adobeDCR;
	  } // not sure if we need this anymore


	  nativeOmniture(options) {
	    if (options) {
	      lodash_mergewith(this.config.nativeOmniture, options, mergeCustomizer$1);
	    }

	    return this.config.nativeOmniture;
	  }

	}

	/* eslint-disable consistent-return */

	/* eslint-disable no-bitwise */
	var stringUtils = (() => {
	  function leadPadding(s, padValue = '0') {
	    if (s === null || s === undefined) {
	      return;
	    }

	    return s.toString().length === 1 ? padValue + s : s;
	  }

	  function timezone2Offset() {
	    function z(n) {
	      return (n < 10 ? '0' : '') + n;
	    }

	    let offset = new Date().getTimezoneOffset();
	    const sign = offset < 0 ? '+' : '-';
	    offset = Math.abs(offset);
	    return sign + z(offset / 60 | 0) + z(offset % 60);
	  }

	  function date2String(date, format) {
	    const p = input => this.leadPadding(String(input));

	    return format.replace(/dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?/g, format => {
	      switch (format) {
	        case 'hh':
	          return p(date.getHours() < 13 ? date.getHours() : date.getHours() - 12);

	        case 'h':
	          return date.getHours() < 13 ? date.getHours() : date.getHours() - 12;

	        case 'HH':
	          return p(date.getHours());

	        case 'H':
	          return date.getHours();

	        case 'mm':
	          return p(date.getMinutes());

	        case 'm':
	          return date.getMinutes();

	        case 'ss':
	          return p(date.getSeconds());

	        case 's':
	          return date.getSeconds();

	        case 'yyyy':
	          return date.getFullYear();

	        case 'yy':
	          return date.getFullYear().toString().substring(2, 4);

	        case 'dd':
	          return p(date.getDate());

	        case 'd':
	          return date.getDate().toString();

	        case 'MM':
	          return p(date.getMonth() + 1);

	        case 'M':
	          return date.getMonth() + 1;

	        case 't':
	          return date.getHours() < 12 ? 'A' : 'P';

	        case 'tt':
	          return date.getHours() < 12 ? 'AM' : 'PM';

	        case 'zzz':
	        case 'zz':
	        case 'z':
	          return '';
	      }
	    });
	  }

	  return {
	    leadPadding,
	    date2String,
	    timezone2Offset
	  };
	});

	var $filter = arrayIteration.filter;


	var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('filter');

	// `Array.prototype.filter` method
	// https://tc39.es/ecma262/#sec-array.prototype.filter
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$1 }, {
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var filter$2 = entryVirtual('Array').filter;

	var ArrayPrototype$2 = Array.prototype;

	var filter_1 = function (it) {
	  var own = it.filter;
	  return it === ArrayPrototype$2 || (it instanceof Array && own === ArrayPrototype$2.filter) ? filter$2 : own;
	};

	var filter$1 = filter_1;

	var filter = filter$1;

	function fetchLayout(plutoApi) {
	  return fetch(plutoApi, {
	    headers: {
	      appversion: '1.2.7.40'
	    }
	  }).then(response => response.json());
	} // Load pluto layout, you have to include the parameters for layout in `customParams`
	// Default values call endcard layout


	async function fetchPluto(playLoad) {
	  try {
	    const {
	      brand,
	      playlistId = '-1',
	      id,
	      env = 'prod',
	      layout = 'endcard',
	      moduleName = 'tilegroup',
	      customParams = {}
	    } = playLoad;
	    const plutoApi = `https://${env}.gatekeeper.us-abc.symphony.edgedatg.com/api/ws/pluto/v1/layout?authlevel=1&brand=${brandLegacyId(brand.toLowerCase())}&device=001&playlist=${playlistId || '-1'}&type=${layout}&video=${id}`;
	    return fetchLayout(plutoApi).then(layout => {
	      var _context;

	      const layoutModule = filter(_context = layout.modules).call(_context, module => {
	        return module.type === moduleName;
	      })[0];

	      if (layoutModule && layoutModule.resource) {
	        let plutoEndpoint = layoutModule.resource;

	        const customParamsKeys = keys(customParams);

	        map(customParamsKeys).call(customParamsKeys, key => {
	          const paramValue = customParams[key];
	          plutoEndpoint = plutoEndpoint.replace(`{${key}}`, paramValue);
	          return key;
	        });

	        return fetchLayout(plutoEndpoint).then(tiles => {
	          const nextContent = tiles && tiles.tiles ? tiles.tiles[0] : tiles;
	          return promise.resolve(nextContent);
	        });
	      }

	      return promise.reject(new Error('NO RESOURCE FOUND'));
	    });
	  } catch (err) {
	    console.error(`Get media items error: ${err}`);
	    return null;
	  }
	}

	class LiveAnalyticsWatcher {
	  constructor(player, configs) {
	    this.player = player;
	    this.configs_ = configs;
	  }

	  async getScheduleData() {
	    const {
	      player
	    } = this;

	    if (player.mediaItem.streamType === 'live' && player.mediaItem.source.type === 'entitlement') {
	      const scheduleData = await this.getScheduleDataFromPluto(player.mediaItem);
	      return scheduleData;
	    }

	    return null;
	  }

	  trackScheduleShows(coordinator) {
	    // If is live it will reload the tracking session after show ends
	    const {
	      mediainfo = {}
	    } = this.player;

	    if (mediainfo.scheduleData) {
	      const now = new Date();
	      const currentVideo = mediainfo.scheduleData.videos[0];
	      const currentVideoStartTime = new Date(currentVideo.airtime);
	      const nextVideoAfter = currentVideoStartTime.getTime() + currentVideo.duration - now.getTime(); //  allow one second (+1000 below) padding for next program boundary

	      if (this.videoEndTimer) {
	        window.clearTimeout(this.videoEndTimer);
	      }

	      this.videoEndTimer = setTimeout$1(() => {
	        mediainfo.scheduleData.videos.shift();
	        this.player.trigger('dtci.completeShowLive');
	        coordinator.coordinate('dtci.completeShowLive');
	      }, nextVideoAfter + 1000);
	    }
	  }

	  async getScheduleDataFromPluto(mediaItem) {
	    const currentDate = new Date();
	    const starttime = stringUtils().date2String(currentDate, 'yyyyMMdd-HHmm');
	    const endDate = new Date();
	    endDate.setHours(endDate.getHours() + 12);
	    const endtime = stringUtils().date2String(endDate, 'yyyyMMdd-HHmm');
	    const offset = stringUtils().timezone2Offset();
	    return fetchPluto({
	      brand: mediaItem.brand,
	      id: this.configs_.identifier,
	      layout: 'live_player',
	      moduleName: 'schedule',
	      customParams: {
	        starttime,
	        endtime,
	        offset,
	        affiliate: mediaItem.network.id
	      }
	    }).then(data => {
	      return data;
	    }).catch(error => {
	      console.error('Error retrieving schedule data', error);
	      return error;
	    });
	  }

	}

	/* globals google */
	/*Copyright (c) 2011-2016 Moat Inc. All Rights Reserved.*/

	function initMoatTracking(b, h, d) {
	  if (!1 === h.hasOwnProperty('partnerCode')) return !1;
	  var k = document.createElement('script');
	  d = d || b && ('undefined' !== typeof b.O ? b.O.parentNode : document.body) || document.body;
	  var f = [],
	      c = {
	    adsManager: b,
	    ids: h,
	    imaSDK: !0,
	    events: [],
	    dispatchEvent: function (a) {
	      var b = this.sendEvent,
	          c = this.events;
	      b ? (c && (c.push(a), a = c), b(a)) : c.push(a);
	    }
	  },
	      p = {
	    complete: 'AdVideoComplete',
	    firstquartile: 'AdVideoFirstQuartile',
	    impression: 'AdImpression',
	    loaded: 'AdLoaded',
	    midpoint: 'AdVideoMidpoint',
	    pause: 'AdPaused',
	    skip: 'AdSkipped',
	    start: 'AdVideoStart',
	    thirdquartile: 'AdVideoThirdQuartile',
	    volumeChange: 'AdVolumeChange'
	  };

	  if (google && google.ima && b) {
	    var e = '_moatApi' + Math.floor(1e8 * Math.random()),
	        l;

	    for (l in google.ima.AdEvent.Type) {
	      var n = function (a) {
	        if (c.sendEvent) {
	          for (a = f.length - 1; 0 <= a; a--) b.removeEventListener(f[a].type, f[a].func);

	          c.sendEvent(c.events);
	        } else c.events.push({
	          type: p[a.type] || a.type,
	          adVolume: b.getVolume()
	        });
	      };

	      b.addEventListener(google.ima.AdEvent.Type[l], n);
	      f.push({
	        type: google.ima.AdEvent.Type[l],
	        func: n
	      });
	    }
	  }

	  var e = 'undefined' !== typeof e ? e : '',
	      g,
	      m;

	  try {
	    g = d.ownerDocument, m = g.defaultView || g.parentWindow;
	  } catch (a) {
	    g = document, m = window;
	  }

	  m[e] = c;
	  k.type = 'text/javascript';
	  k.src = 'https://z.moatads.com/' + h.partnerCode + '/moatvideo.js#' + e;
	  d && d.appendChild(k);
	  return c;
	}

	function getMoatTrackingConfigs(player, partnerCode, zMoatAdUnitPath) {
	  const ids = {
	    partnerCode,
	    zMoatAdUnitPath,
	    viewMode: player.isFullscreen() ? google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL,
	    slicer1: null,
	    slicer2: null
	  };
	  const {
	    ima,
	    ima3
	  } = player;
	  let adsManager;
	  let adContainer;

	  if (ima) {
	    adsManager = ima.getAdsManager();
	    adContainer = ima.controller.getAdContainerDiv();
	  } else if (ima3) {
	    adsManager = ima3.adsManager;
	    adContainer = ima3.el;
	  }

	  return {
	    adsManager,
	    ids,
	    adContainer
	  };
	}
	function getMoatConfigAndInitMoatTracking(player, partnerCode, zMoatAdUnitPath) {
	  const {
	    adsManager,
	    ids,
	    adContainer
	  } = getMoatTrackingConfigs(player, partnerCode, zMoatAdUnitPath);
	  initMoatTracking(adsManager, ids, adContainer);
	}
	let prevOnAdsAdStartedHandler = null;
	function moat(player, partnerCode, zMoatAdUnitPath) {
	  const {
	    mediaItem: {
	      cues
	    } = {}
	  } = player;

	  const onAdsAdStartedHandler = bind(getMoatConfigAndInitMoatTracking).call(getMoatConfigAndInitMoatTracking, null, player, partnerCode, zMoatAdUnitPath);

	  if (isArray$1(cues)) {
	    player.one('ads-load', onAdsAdStartedHandler);

	    if (prevOnAdsAdStartedHandler) {
	      player.off('ads-ad-started', prevOnAdsAdStartedHandler);
	    }

	    player.on('ads-ad-started', onAdsAdStartedHandler);
	    player.one('dispose', () => {
	      player.off('ads-ad-started', onAdsAdStartedHandler);

	      if (prevOnAdsAdStartedHandler) {
	        prevOnAdsAdStartedHandler = null;
	      }
	    });
	    prevOnAdsAdStartedHandler = onAdsAdStartedHandler;
	  } else {
	    player.one('ads-load', onAdsAdStartedHandler);
	  }
	}

	/*
	  UA-sniffing code borrowed from VideoJS
	  https://github.com/videojs/video.js/blob/master/src/js/utils/browser.js
	*/
	const USER_AGENT = typeof window !== 'undefined' && window.navigator && window.navigator.userAgent || '';
	const APP_VERSION = typeof window !== 'undefined' && window.navigator && window.navigator.appVersion || '';
	const IS_EDGE = /Edge/i.test(USER_AGENT);
	const IS_EDGE_CHROMIUM = /edg/i.test(USER_AGENT);
	const IS_CHROME = !IS_EDGE && /Chrome/i.test(USER_AGENT);
	const IS_ANDROID = /Android/i.test(USER_AGENT);
	const IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;
	IS_SAFARI && /Version\/11/i.test(USER_AGENT);
	const IS_IPAD = /iPad/i.test(USER_AGENT);
	const IS_WINDOWS = /Win/i.test(APP_VERSION); // The Facebook app's UIWebView identifies as both an iPhone and iPad, so
	// to identify iPhones, we need to exclude iPads.
	// http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/

	const IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
	const IS_IPOD = /iPod/i.test(USER_AGENT);
	const IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;
	const IOS_VERSION = function IOS_VERSION() {
	  const match = USER_AGENT.match(/OS (\d+)_/i);

	  if (match && match[1]) {
	    return match[1];
	  }

	  return null;
	}();
	const IS_FIREFOX = /Firefox/i.test(USER_AGENT);
	const IS_OPERA = /Opera/i.test(USER_AGENT); // Detect tablet by looking for "mobile" in UA string
	// https://webmasters.googleblog.com/2011/03/mo-better-to-also-detect-mobile-user.html
	// Note, this may not be reliable as few Android vendors follow the spec.

	const IS_TABLET = IS_IPAD || IS_ANDROID && !/mobile/i.test(USER_AGENT);
	const IS_MOBILE = !IS_TABLET && (IS_IOS || IS_ANDROID);
	const IE_VERSION = function IE_VERSION() {
	  const result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);

	  let version = result && _parseFloat(result[1]);

	  if (!version && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
	    // IE 11 has a different user agent string than other IE versions
	    version = 11.0;
	  }

	  return version;
	}();
	const SUPPORTS_EME = typeof window !== 'undefined' && ('MediaKeys' in window || 'WebKitMediaKeys' in window || 'MSMediaKeys' in window); // https://stackoverflow.com/a/37705154, WebView will not contain `Safari`
	// Should match:
	// Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148

	const IS_IOS_WEBVIEW = IS_IOS && !IS_SAFARI; // https://developer.chrome.com/multidevice/user-agent#webview_user_agent
	// Should match:
	// Mozilla/5.0 (Linux; Android 9; Pixel 2 Build/PQ1A.190105.004; wv)
	// AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/70.0.3538.64 Mobile Safari/537.36

	const IS_ANDROID_WEBVIEW = IS_ANDROID && /wv/i.test(USER_AGENT);
	const IS_WEBVIEW = /WebView/i.test(USER_AGENT) || IS_IOS_WEBVIEW || IS_ANDROID_WEBVIEW;

	// prettier-ignore

	/* eslint-disable no-bitwise */
	// https://gist.github.com/jed/982883
	function uuid(a) {
	  return a // if the placeholder was passed, return
	  ? ( // a random number from 0 to 15
	  a ^ // unless b is 8,
	  Math.random() // in which case
	  * 16 // a random number from
	  >> a / 4 // 8 to 11
	  ).toString(16) // in hexadecimal
	  : ( // or otherwise a concatenated string:
	  [1e7] + // 10000000 +
	  -1e3 + // -1000 +
	  -4e3 + // -4000 +
	  -8e3 + // -80000000 +
	  -1e11 // -100000000000,
	  ).replace( // replacing
	  /[018]/g, // zeroes, ones, and eights with
	  uuid // random hex digits
	  );
	}

	const UNDEF = undefined;
	/**
	 * check if usprivacy cookie exist
	 * @returns
	 */

	function getCookie(name) {
	  const value = `; ${document.cookie}`;
	  const parts = value.split(`; ${name}=`);
	  let cookieValue;

	  if (parts.length === 2) {
	    cookieValue = parts.pop().split(';').shift();
	  }

	  return cookieValue;
	}
	function checkUsPrivacyCookie() {
	  const usPrivacyCookie = getCookie('usprivacy');
	  return usPrivacyCookie && usPrivacyCookie.length ? usPrivacyCookie : false;
	}
	/**
	 * add usprivacy params to GAM request
	 * @param {Object} [imaSdkDictionary={}]
	 * @param {Object} [advertisingInfo={}]
	 * @returns {Object} conditionally updated imaSdkDictionary based on CCPA cookie
	 */

	function addUsPrivacyCustomParams(imaSdkDictionary = {}, advertisingInfo = {}) {
	  const usPrivacyCookie = advertisingInfo.usPrivacy || checkUsPrivacyCookie();
	  let {
	    rdp
	  } = advertisingInfo;

	  if (usPrivacyCookie) {
	    if (usPrivacyCookie === '1YYY') {
	      rdp = 1;
	    }

	    if (rdp) {
	      imaSdkDictionary.rdp = rdp;
	    }

	    imaSdkDictionary.us_privacy = usPrivacyCookie;
	    imaSdkDictionary.cust_params = `${imaSdkDictionary.cust_params}&d_us_privacy=${usPrivacyCookie}`;
	  }

	  return imaSdkDictionary;
	}

	function isDoNotTrackEnabled() {
	  const doNotTrackOption = window.doNotTrack || window.navigator.doNotTrack || window.navigator.msDoNotTrack;

	  if (!doNotTrackOption) {
	    return false;
	  }

	  if (doNotTrackOption.charAt(0) === '1' || doNotTrackOption === 'yes') {
	    return true;
	  }

	  return false;
	}
	/**
	 * client generated user identifer value, new value is generated every 30 days,
	 * affiliate partners will use fcap for frequency capping
	 */


	function fcap() {
	  const storageKey = 'fcap';
	  const ageLimit = 2592000; // 30 days

	  const now$1 = now();

	  let fcap = JSON.parse(window.localStorage.getItem(storageKey));

	  if (!fcap || fcap.ts < now$1 - ageLimit) {
	    fcap = {
	      id: uuid(),
	      ts: now$1
	    };
	    window.localStorage.setItem(storageKey, stringify(fcap));
	  }

	  return fcap.id;
	}

	function getCommonAdInfo(currentAdInfo, mediaItem, player, adapter) {
	  const advertisingInfo = new AdvertisingInfo();
	  const {
	    device,
	    webHref,
	    live: isLive,
	    id
	  } = mediaItem;
	  const {
	    SWID,
	    UNID
	  } = new Fan();
	  const {
	    height,
	    width
	  } = player.currentDimensions();
	  const isMobile = /mobile/i.test(device) || IS_MOBILE;
	  const isTablet = /tablet/i.test(device) || IS_TABLET;
	  const videoPlayerType = adapter.playerName;
	  const videoPlayerVersion = adapter.platformVersion;
	  const {
	    startType = ''
	  } = player.mediainfo || {};
	  const {
	    an,
	    cmsid = '2495342',
	    hl = player.language() || 'en',
	    iu,
	    nielsenAppId = 'P31187EE2-AC6E-46CB-BB54-D07591BED067',
	    npa = 0,
	    tfcd = 0,
	    vpa = 1
	  } = currentAdInfo;
	  const {
	    ltd
	  } = currentAdInfo;
	  let {
	    additionalConsent,
	    rdp,
	    usPrivacy
	  } = currentAdInfo;
	  let platform = 'desktop';
	  let deviceOS;
	  let pp = 'espn-clips-desktop-csai';

	  if (IS_EDGE) {
	    deviceOS = 'Edge';
	  } else if (IS_CHROME) {
	    deviceOS = 'Chrome';
	  } else if (IS_SAFARI) {
	    deviceOS = 'Safari';
	  } else if (IS_FIREFOX) {
	    deviceOS = 'Firefox';
	  } else if (IS_OPERA) {
	    deviceOS = 'Opera';
	  }

	  if (IS_IOS) {
	    platform = `ios_${isTablet ? 'tablet' : 'handset'}`;
	    pp = 'espn-mweb-clips-ios-csai';
	  } else if (IS_ANDROID) {
	    platform = `android_${isTablet ? 'tablet' : 'handset'}`;
	    pp = 'espn-mweb-clips-android-csai';
	  }

	  advertisingInfo.cmsid = cmsid;
	  advertisingInfo.descriptionUrl = webHref;
	  advertisingInfo.deviceOS = deviceOS;
	  advertisingInfo.deviceType = (device || (isTablet ? 'tablet' : isMobile ? 'mobile' : 'desktop')).toLowerCase();
	  advertisingInfo.fcap = fcap();
	  advertisingInfo.hl = hl;
	  advertisingInfo.isAutoplay = player.autoplay() || !!startType.match(/continuous/i) ? '1' : '0';
	  advertisingInfo.isDoNotTrackEnabled = isDoNotTrackEnabled();
	  advertisingInfo.isMute = player.muted();
	  advertisingInfo.iu = iu;
	  advertisingInfo.nielsenAppId = nielsenAppId;
	  advertisingInfo.nielsenDeviceGroup = `devgrp,${isTablet ? 'TAB' : isMobile ? 'PHN' : 'DSK'}`;
	  advertisingInfo.npa = npa; // non-personalized ads

	  advertisingInfo.platform = platform;
	  advertisingInfo.pp = pp;
	  advertisingInfo.ppid = SWID;
	  advertisingInfo.swid = SWID;
	  advertisingInfo.videoPlayerType = videoPlayerType;
	  advertisingInfo.videoPlayerVersion = videoPlayerVersion;

	  if (an) {
	    advertisingInfo.an = an;
	  }
	  /**
	   * tfcd: Tag for Child Directed Treatment
	   * You can mark your ad requests to be treated as child-directed.
	   * The feature is designed to help facilitate compliance
	   * with the Children's Online Privacy Protection Act (COPPA)
	   */


	  advertisingInfo.tfcd = tfcd;
	  advertisingInfo.unid = UNID;
	  advertisingInfo.vdm = isLive ? 'live' : 'vod';
	  advertisingInfo.vid = id;
	  advertisingInfo.videoPlayerSize = `${Math.round(width)}x${Math.round(height)}`; // vpa: Video play automatic, default to 1

	  advertisingInfo.vpa = vpa; // Not an actual AdvertisingInfo prop, but ad-related just the same.
	  // Setting here so it is available where ever we expose `advertisingInfo` on the bundle.

	  advertisingInfo.moatPartnerCode = 'abcimavideo618769704984'; // DCF

	  usPrivacy = usPrivacy || checkUsPrivacyCookie();

	  if (usPrivacy) {
	    if (usPrivacy === '1YYY') {
	      rdp = 1;
	    }

	    advertisingInfo.usPrivacy = usPrivacy;
	  }

	  additionalConsent = additionalConsent || getCookie('OTAdditionalConsentString');

	  if (additionalConsent) {
	    advertisingInfo.additionalConsent = additionalConsent;
	  }

	  if (rdp !== UNDEF) {
	    advertisingInfo.rdp = rdp;
	  }

	  advertisingInfo.ltd = ltd !== UNDEF ? ltd : getCookie('_dcf') === '0';
	  return advertisingInfo;
	}

	function getAdditionalAdInfoForEntertainment(currentAdInfo, mediaItem, player, adapter) {
	  const advertisingInfo = getCommonAdInfo(currentAdInfo, mediaItem, player, adapter);
	  let {
	    pp = 'abc-web-desktop'
	  } = currentAdInfo;
	  const transUniqueId = uuid();
	  const {
	    // Parameters for entertainment only
	    output,
	    vadFormat,
	    vpi,
	    adRule,
	    alt,
	    beacType = 'csai',
	    accesslevel,
	    isAuth,
	    varResolution,
	    nlsnPlat,
	    tag,
	    aff,
	    authp,
	    playlist,
	    cbp,
	    collection,
	    impl = 's',
	    transId = transUniqueId // End params for entertainment only

	  } = currentAdInfo;

	  if (IS_IOS) {
	    pp = 'abc-web-mobile';
	  } else if (IS_ANDROID) {
	    pp = 'abc-web-mobile';
	  }

	  advertisingInfo.pp = pp; // Params for entertainment only

	  advertisingInfo.output = output;
	  advertisingInfo.vadFormat = vadFormat;
	  advertisingInfo.vpi = vpi;
	  advertisingInfo.adRule = adRule;
	  advertisingInfo.alt = alt;
	  advertisingInfo.beacType = beacType;
	  advertisingInfo.accessLevel = accesslevel;
	  advertisingInfo.isAuth = isAuth;
	  advertisingInfo.varResolution = varResolution;
	  advertisingInfo.nlsnPlat = nlsnPlat;
	  advertisingInfo.tag = tag;
	  advertisingInfo.aff = aff;
	  advertisingInfo.authenticationProvider = authp;
	  advertisingInfo.playlist = playlist;
	  advertisingInfo.cbp = cbp;
	  advertisingInfo.collection = collection;
	  advertisingInfo.impl = impl;
	  advertisingInfo.transId = transId; // End params for entertainment only

	  return advertisingInfo;
	}

	function getAdvertisingInfo(currentAdInfo, player, mediaItem = {}, adapter = {}) {
	  let advertisingInfo = getCommonAdInfo(currentAdInfo, mediaItem, player, adapter);
	  const isESPN = !currentAdInfo.aff;

	  if (!isESPN) {
	    advertisingInfo = getAdditionalAdInfoForEntertainment(currentAdInfo, mediaItem, player, adapter);
	  }

	  return advertisingInfo;
	}

	const defaultBaseUrl$1 = 'https://pubads.g.doubleclick.net/gampad/ads';
	/**
	 * Listens for ad progress events and triggers `timeupdate` on player which gets relayed to `dtci.timeupdate`
	 */

	function coordinateAdProgressEvents(player) {
	  function relayTimeupdateEventOnAdStart() {
	    const {
	      ima3: {
	        adPlayer
	      } = {}
	    } = player;
	    const unbindEventNames = ['dispose', 'ads-ad-ended'];
	    const adProgressEventName = 'timeupdate';

	    if (adPlayer) {
	      const coordinateAdsTimeUpdateIMA3 = () => {
	        const currentTime = adPlayer && adPlayer.currentTime && adPlayer.currentTime() || NaN;
	        player.trigger(adProgressEventName, {
	          currentTime,
	          type: 'ad'
	        });
	      };

	      const unbindCoordinateAdsTimeUpdateIMA3 = () => {
	        player.off(unbindEventNames, unbindCoordinateAdsTimeUpdateIMA3);
	        adPlayer.off(adProgressEventName, coordinateAdsTimeUpdateIMA3);
	      };

	      adPlayer.on(adProgressEventName, coordinateAdsTimeUpdateIMA3);
	      player.on(unbindEventNames, unbindCoordinateAdsTimeUpdateIMA3);
	    }
	  }

	  player.on('ads-ad-started', relayTimeupdateEventOnAdStart);
	  player.one('dispose', () => {
	    player.off('ads-ad-started', relayTimeupdateEventOnAdStart);
	  });
	}
	/*
	 * Google is an object that gets mixed into an AdProvider instance.
	 */

	const Google = {
	  validate(player) {
	    if (player.ima3) {
	      return true;
	    }

	    console.warn('DTCIVideoPlayer: AdProvider: ima3 plugin is not available in this player');
	    return false;
	  },

	  initialize() {// no-op
	  },

	  async initAds(advertisingInfo, options, player, coordinator) {
	    if (!player.ima3) {
	      return;
	    }

	    const shouldRequestAds = await coordinator.coordinate('dtci.adProvider.shouldRequestAds', true);

	    if (typeof player.ima3 !== 'function' && !shouldRequestAds) {
	      /*
	       * If the IMA3 plugin has already been init'd, it will be an object, not
	       * a function.
	       *
	       * The plugin is sticky; once init'd it can't be stopped. However, the
	       * plugin checks for `player.mediainfo.economics === 'FREE'` and will
	       * cancel the current ad request if true. (This logic supports Brightcove
	       * VideoCloud functionality.)
	       *
	       * More info: https://code.espn.com/players/web-player-bundle/pull/1272
	       */
	      player.mediainfo.economics = 'FREE';
	    }

	    if (shouldRequestAds) {
	      var _context, _context2;

	      await coordinator.coordinate('dtci.adProvider.getAdvertisingInfo', advertisingInfo);
	      let imaSdkDictionary = indexOf(_context = advertisingInfo.pp).call(_context, 'espn') > -1 ? advertisingInfo.dictionaryForImaSdk() : advertisingInfo.dictionaryForEntertainment();
	      /**
	       * check usprivacy cookie and add us_privacy param to cust_params GAM
	       */

	      imaSdkDictionary = addUsPrivacyCustomParams(imaSdkDictionary, advertisingInfo);

	      const queryString = map(_context2 = keys(imaSdkDictionary)).call(_context2, key => {
	        if (key !== 'cust_params') {
	          return `${key}=${imaSdkDictionary[key]}`;
	        }

	        return `cust_params=${encodeURIComponent(imaSdkDictionary.cust_params)}`;
	      });

	      let baseUrl = defaultBaseUrl$1;

	      if (advertisingInfo.vdm === 'live') {
	        baseUrl = baseUrl.replace(/gampad\/ads$/, 'gampad/live/ads');
	      }

	      const {
	        debug = false,
	        disableCustomPlaybackForIOS10Plus,
	        disableMoat = false,
	        requestMode = 'onload',
	        showVpaidControls = true,
	        timeout = 4000
	      } = options;
	      const pluginConfiguration = {
	        serverUrl: `${baseUrl}?${queryString.join('&')}`,
	        debug,
	        requestMode,
	        showVpaidControls,
	        timeout: _parseInt(timeout, 10),
	        ima3SdkSettings: {
	          disableCustomPlaybackForIOS10Plus
	        }
	      };

	      if (!disableMoat) {
	        moat(player, advertisingInfo.moatPartnerCode, imaSdkDictionary.iu);
	      }

	      if (typeof player.ima3 === 'function') {
	        player.ima3(pluginConfiguration);

	        if (player.ima3.ready) {
	          player.ima3.ready(() => coordinateAdProgressEvents(player));
	        }
	      } else if (player.ima3) {
	        player.ima3.settings = pluginConfiguration;
	      }
	    }
	  }

	};

	/* global Blob */
	// This file is generated. Do not edit this file directly.
	// Command: 'npm run generate' should be used to update the content.

	/**
	 * @type {Blob}
	 */
	var AUDIO = new Blob([new Uint8Array([255, 227, 24, 196, 0, 0, 0, 3, 72, 1, 64, 0, 0, 4, 132, 16, 31, 227, 192, 225, 76, 255, 67, 12, 255, 221, 27, 255, 228, 97, 73, 63, 255, 195, 131, 69, 192, 232, 223, 255, 255, 207, 102, 239, 255, 255, 255, 101, 158, 206, 70, 20, 59, 255, 254, 95, 70, 149, 66, 4, 16, 128, 0, 2, 2, 32, 240, 138, 255, 36, 106, 183, 255, 227, 24, 196, 59, 11, 34, 62, 80, 49, 135, 40, 0, 253, 29, 191, 209, 200, 141, 71, 7, 255, 252, 152, 74, 15, 130, 33, 185, 6, 63, 255, 252, 195, 70, 203, 86, 53, 15, 255, 255, 247, 103, 76, 121, 64, 32, 47, 255, 34, 227, 194, 209, 138, 76, 65, 77, 69, 51, 46, 57, 55, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 255, 227, 24, 196, 73, 13, 153, 210, 100, 81, 135, 56, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170])], { type: 'audio/mpeg' });

	/**
	 * @type {Blob}
	 */
	var VIDEO = new Blob([new Uint8Array([0, 0, 0, 28, 102, 116, 121, 112, 105, 115, 111, 109, 0, 0, 2, 0, 105, 115, 111, 109, 105, 115, 111, 50, 109, 112, 52, 49, 0, 0, 0, 8, 102, 114, 101, 101, 0, 0, 2, 239, 109, 100, 97, 116, 33, 16, 5, 32, 164, 27, 255, 192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 167, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 33, 16, 5, 32, 164, 27, 255, 192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 167, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 0, 0, 2, 194, 109, 111, 111, 118, 0, 0, 0, 108, 109, 118, 104, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 232, 0, 0, 0, 47, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 236, 116, 114, 97, 107, 0, 0, 0, 92, 116, 107, 104, 100, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 101, 100, 116, 115, 0, 0, 0, 28, 101, 108, 115, 116, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 47, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 100, 109, 100, 105, 97, 0, 0, 0, 32, 109, 100, 104, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 172, 68, 0, 0, 8, 0, 85, 196, 0, 0, 0, 0, 0, 45, 104, 100, 108, 114, 0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0, 0, 0, 1, 15, 109, 105, 110, 102, 0, 0, 0, 16, 115, 109, 104, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 100, 105, 110, 102, 0, 0, 0, 28, 100, 114, 101, 102, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1, 0, 0, 0, 211, 115, 116, 98, 108, 0, 0, 0, 103, 115, 116, 115, 100, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 87, 109, 112, 52, 97, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 16, 0, 0, 0, 0, 172, 68, 0, 0, 0, 0, 0, 51, 101, 115, 100, 115, 0, 0, 0, 0, 3, 128, 128, 128, 34, 0, 2, 0, 4, 128, 128, 128, 20, 64, 21, 0, 0, 0, 0, 1, 244, 0, 0, 1, 243, 249, 5, 128, 128, 128, 2, 18, 16, 6, 128, 128, 128, 1, 2, 0, 0, 0, 24, 115, 116, 116, 115, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 4, 0, 0, 0, 0, 28, 115, 116, 115, 99, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 28, 115, 116, 115, 122, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 115, 0, 0, 1, 116, 0, 0, 0, 20, 115, 116, 99, 111, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 44, 0, 0, 0, 98, 117, 100, 116, 97, 0, 0, 0, 90, 109, 101, 116, 97, 0, 0, 0, 0, 0, 0, 0, 33, 104, 100, 108, 114, 0, 0, 0, 0, 0, 0, 0, 0, 109, 100, 105, 114, 97, 112, 112, 108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45, 105, 108, 115, 116, 0, 0, 0, 37, 169, 116, 111, 111, 0, 0, 0, 29, 100, 97, 116, 97, 0, 0, 0, 1, 0, 0, 0, 0, 76, 97, 118, 102, 53, 54, 46, 52, 48, 46, 49, 48, 49])], { type: 'video/mp4' });

	/* global URL */
	function setupDefaultValues(options) {
	  return Object.assign({
	    muted: false,
	    timeout: 250,
	    inline: false
	  }, options);
	}

	function startPlayback(_ref, elementCallback) {
	  var muted = _ref.muted,
	      timeout = _ref.timeout,
	      inline = _ref.inline;

	  var _elementCallback = elementCallback(),
	      element = _elementCallback.element,
	      source = _elementCallback.source;

	  var playResult = void 0;
	  var timeoutId = void 0;
	  var sendOutput = void 0;

	  element.muted = muted;
	  if (muted === true) {
	    element.setAttribute('muted', 'muted');
	  }
	  // indicates that the video is to be played "inline",
	  // that is within the element's playback area.
	  if (inline === true) {
	    element.setAttribute('playsinline', 'playsinline');
	  }

	  element.src = source;

	  return new Promise(function (resolve) {
	    playResult = element.play();
	    timeoutId = setTimeout(function () {
	      sendOutput(false, new Error('Timeout ' + timeout + ' ms has been reached'));
	    }, timeout);
	    sendOutput = function sendOutput(result) {
	      var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      clearTimeout(timeoutId);
	      resolve({ result: result, error: error });
	    };

	    if (playResult !== undefined) {
	      playResult.then(function () {
	        return sendOutput(true);
	      }).catch(function (playError) {
	        return sendOutput(false, playError);
	      });
	    } else {
	      sendOutput(true);
	    }
	  });
	}

	//
	// API
	//

	function video(options) {
	  options = setupDefaultValues(options);
	  return startPlayback(options, function () {
	    return {
	      element: document.createElement('video'),
	      source: URL.createObjectURL(VIDEO)
	    };
	  });
	}

	function audio(options) {
	  options = setupDefaultValues(options);
	  return startPlayback(options, function () {
	    return {
	      element: document.createElement('audio'),
	      source: URL.createObjectURL(AUDIO)
	    };
	  });
	}

	var index = { audio: audio, video: video };

	function adsManagerLoadedCallbackFactory(player) {
	  return function adsManagerLoadedCallback() {
	    var _context;

	    const {
	      ima
	    } = player;
	    const eventMap = {
	      'ads-ad-ended': google.ima.AdEvent.Type.COMPLETE,
	      'ads-ad-skipped': google.ima.AdEvent.Type.SKIPPED,
	      'ads-click': google.ima.AdEvent.Type.CLICK,
	      'ads-first-quartile': google.ima.AdEvent.Type.FIRST_QUARTILE,
	      'ads-midpoint': google.ima.AdEvent.Type.MIDPOINT,
	      'ads-mute': google.ima.AdEvent.Type.VOLUME_MUTED,
	      'ads-pause': google.ima.AdEvent.Type.PAUSED,
	      'ads-play': google.ima.AdEvent.Type.RESUMED,
	      'ads-third-quartile': google.ima.AdEvent.Type.THIRD_QUARTILE,
	      'ads-volumechange': google.ima.AdEvent.Type.VOLUME_CHANGED,
	      'ads-all-ads-completed': google.ima.AdEvent.Type.ALL_ADS_COMPLETED
	    };

	    forEach(_context = entries(eventMap)).call(_context, ([playerEvent, imaEvent]) => {
	      ima.addEventListener(imaEvent, () => player.trigger(playerEvent));
	    });

	    ima.addEventListener(google.ima.AdEvent.Type.AD_PROGRESS, evt => {
	      const {
	        currentTime
	      } = evt && evt.getAdData && evt.getAdData() || {};
	      player.trigger('timeupdate', {
	        currentTime,
	        type: 'ad'
	      });
	    });
	  };
	}

	const defaultBaseUrl = 'https://pubads.g.doubleclick.net/gampad/ads'; // eslint-disable-next-line no-unused-vars
	let autoplayRequiresMute = false;
	/*
	 * Google is an object that gets mixed into an AdProvider instance.
	 */

	const GoogleForVideoJS = {
	  validate(player) {
	    if (player.ima) {
	      return true;
	    }

	    console.warn('DTCIVideoPlayer: AdProvider: ima plugin is not available in this player');
	    return false;
	  },

	  initialize() {
	    // eslint-disable-next-line consistent-return
	    return new promise(resolve => {
	      const checkMutedAutoplaySupport = () => {
	        index.video({
	          timeout: 100,
	          muted: true
	        }).then(response => {
	          if (response.result === false) {
	            autoplayRequiresMute = false;
	          } else {
	            autoplayRequiresMute = true;
	          }

	          return resolve();
	        });
	      };

	      const checkUnmutedAutoplaySupport = () => {
	        index.video({
	          timeout: 100,
	          muted: false
	        }).then(response => {
	          if (response.result === false) {
	            // Unmuted autoplay is not allowed.
	            return checkMutedAutoplaySupport();
	          } // Unmuted autoplay is allowed.
	          autoplayRequiresMute = false;
	          return resolve();
	        });
	      };

	      if (window.google && window.google.ima) {
	        return resolve();
	      }

	      loadScript.url('//imasdk.googleapis.com/js/sdkloader/ima3.js').then(() => {
	        checkUnmutedAutoplaySupport();
	      });
	    });
	  },

	  async initAds(advertisingInfo, options, player, coordinator) {
	    if (!player.ima) {
	      return;
	    }

	    if (autoplayRequiresMute) {
	      player.muted(autoplayRequiresMute);
	    }

	    const shouldRequestAds = await coordinator.coordinate('dtci.adProvider.shouldRequestAds', true);

	    if (shouldRequestAds) {
	      var _context, _context2;

	      await coordinator.coordinate('dtci.adProvider.getAdvertisingInfo', advertisingInfo);
	      let imaSdkDictionary = indexOf(_context = advertisingInfo.pp).call(_context, 'espn') > -1 ? advertisingInfo.dictionaryForImaSdk() : advertisingInfo.dictionaryForEntertainment();
	      /**
	       * add us_privacy param to cust_params GAM
	       */

	      imaSdkDictionary = addUsPrivacyCustomParams(imaSdkDictionary, advertisingInfo);

	      const queryString = map(_context2 = keys(imaSdkDictionary)).call(_context2, key => {
	        if (key !== 'cust_params') {
	          return `${key}=${imaSdkDictionary[key]}`;
	        }

	        return `cust_params=${encodeURIComponent(imaSdkDictionary.cust_params)}`;
	      });

	      let baseUrl = defaultBaseUrl;

	      if (advertisingInfo.vdm === 'live') {
	        baseUrl = baseUrl.replace(/gampad\/ads$/, 'gampad/live/ads');
	      }

	      const {
	        debug = false,
	        disableCustomPlaybackForIOS10Plus,
	        disableMoat = false,
	        requestMode = 'onLoad',
	        showControlsForJSAds = true,
	        timeout = 4000
	      } = options;
	      const playerDims = player.currentDimensions();
	      const pluginConfiguration = {
	        adsRequest: {
	          linearAdSlotWidth: _parseInt(playerDims.width, 10),
	          linearAdSlotHeight: _parseInt(playerDims.height, 10),
	          nonLinearAdSlotWidth: _parseInt(playerDims.width, 10),
	          nonLinearAdSlotHeight: _parseInt(playerDims.height, 10),
	          videoPlayMuted: player.muted(),
	          videoPlayActivation: !!player.autoplay()
	        },
	        adTagUrl: `${baseUrl}?${queryString.join('&')}`,
	        debug,
	        disableCustomPlaybackForIOS10Plus,
	        requestMode,
	        showControlsForJSAds,
	        timeout: _parseInt(timeout, 10),
	        adsManagerLoadedCallback: adsManagerLoadedCallbackFactory(player)
	      };

	      if (!disableMoat) {
	        moat(player, advertisingInfo.moatPartnerCode, imaSdkDictionary.iu);
	      }

	      if (pluginConfiguration.requestMode === 'onload') {
	        pluginConfiguration.requestMode = 'onLoad';
	      }

	      if (pluginConfiguration.requestMode === 'onplay') {
	        pluginConfiguration.requestMode = 'onPlay';
	      }

	      if (typeof player.ima === 'function') {
	        player.ima(pluginConfiguration);
	      } else if (player.ima) {
	        player.ima.controller.settings = pluginConfiguration;
	        player.ima.requestAds();
	      }
	      autoplayRequiresMute = null;
	    }
	  }

	};

	const providers = {
	  Google,
	  GoogleForVideoJS
	};

	class AdProvider {
	  constructor(player, mediaItem, adProviderOptions, coordinator) {
	    this.player = player;
	    this.mediaItem = mediaItem;
	    this.coordinator = coordinator;
	    this.provider = null;
	    const {
	      options = {},
	      provider = 'Google'
	    } = adProviderOptions || {};
	    this.options = options;
	    this.setProvider(provider);
	    return new promise(resolve => {
	      this.initialize().then(() => resolve(this));
	    });
	  }

	  setProvider(preferredProvider = 'Google') {
	    if (providers[preferredProvider]) {
	      const provider = providers[preferredProvider];

	      if (provider.validate(this.player)) {
	        this.provider = provider;
	      }
	    }
	  }
	  /*
	   * `initialize` provides a hook for an Ad Provider to load additional resources or modify runtime values.
	   * For example, GoogleForVideoJS needs to load the IMA SDK library. And previously, Brightcove Once, an SSAI provider, used
	   * `initialize` to query a backend API for an ad-injected playback URL.
	   */


	  async initialize() {
	    if (this.provider) {
	      await this.provider.initialize(this);
	    }
	  }

	  initAds(advertisingInfo) {
	    if (this.provider) {
	      this.provider.initAds(advertisingInfo, this.options, this.player, this.coordinator);
	    }
	  }

	}

	var timezone = createCommonjsModule(function (module) {
	!function (definition) {
	  if (module.exports) module.exports = definition();
	  else this.tz = definition();
	} (function () {
	/*
	  function die () {
	    console.log.apply(console, __slice.call(arguments, 0));
	    return process.exit(1);
	  }

	  function say () { return console.log.apply(console, __slice.call(arguments, 0)) }
	*/
	  function actualize (entry, rule, year) {
	    var actualized, date = rule.day[1];

	    do {
	      actualized = new Date(Date.UTC(year, rule.month, Math.abs(date++)));
	    } while (rule.day[0] < 7 && actualized.getUTCDay() != rule.day[0])

	    actualized = {
	      clock: rule.clock,
	      sort: actualized.getTime(),
	      rule: rule,
	      save: rule.save * 6e4,
	      offset: entry.offset
	    };

	    actualized[actualized.clock] = actualized.sort + rule.time * 6e4;

	    if (actualized.posix) {
	      actualized.wallclock = actualized[actualized.clock] + (entry.offset + rule.saved);
	    } else {
	      actualized.posix = actualized[actualized.clock] - (entry.offset + rule.saved);
	    }

	    return actualized;
	  }

	  function find (request, clock, time) {
	    var i, I, entry, found, zone = request[request.zone], actualized = [], abbrev, rules
	      , j, year = new Date(time).getUTCFullYear(), off = 1;
	    for (i = 1, I = zone.length; i < I; i++) if (zone[i][clock] <= time) break;
	    entry = zone[i];
	    if (entry.rules) {
	      rules = request[entry.rules];
	      for (j = year + 1; j >= year - off; --j)
	        for (i = 0, I = rules.length; i < I; i++)
	          if (rules[i].from <= j && j <= rules[i].to) actualized.push(actualize(entry, rules[i], j));
	          else if (rules[i].to < j && off == 1) off = j - rules[i].to;
	      actualized.sort(function (a, b) { return a.sort - b.sort });
	      for (i = 0, I = actualized.length; i < I; i++) {
	        if (time >= actualized[i][clock] && actualized[i][actualized[i].clock] > entry[actualized[i].clock]) found = actualized[i];
	      }
	    }
	    if (found) {
	      if (abbrev = /^(.*)\/(.*)$/.exec(entry.format)) {
	        found.abbrev = abbrev[found.save ? 2 : 1];
	      } else {
	        found.abbrev = entry.format.replace(/%s/, found.rule.letter);
	      }
	    }
	    return found || entry;
	  }

	  function convertToWallclock (request, posix) {
	    if (request.zone == "UTC") return posix;
	    request.entry = find(request, "posix", posix);
	    return posix + request.entry.offset + request.entry.save;
	  }

	  function convertToPOSIX (request, wallclock) {
	    if (request.zone == "UTC") return wallclock;

	    var entry, diff;
	    request.entry = entry = find(request, "wallclock", wallclock);
	    diff = wallclock - entry.wallclock;

	    return 0 < diff && diff < entry.save ? null : wallclock - entry.offset - entry.save;
	  }

	  function adjust (request, posix, match) {
	    var increment = +(match[1] + 1) // conversion necessary for week day addition
	      , offset = match[2] * increment
	      , index = UNITS.indexOf(match[3].toLowerCase())
	      , date
	      ;
	    if (index > 9) {
	      posix += offset * TIME[index - 10];
	    } else {
	      date = new Date(convertToWallclock(request, posix));
	      if (index < 7) {
	        while (offset) {
	          date.setUTCDate(date.getUTCDate() + increment);
	          if (date.getUTCDay() == index) offset -= increment;
	        }
	      } else if (index == 7) {
	        date.setUTCFullYear(date.getUTCFullYear() + offset);
	      } else if (index == 8) {
	        date.setUTCMonth(date.getUTCMonth() + offset);
	      } else {
	        date.setUTCDate(date.getUTCDate() + offset);
	      }
	      if ((posix = convertToPOSIX(request, date.getTime())) == null) {
	        posix = convertToPOSIX(request, date.getTime() + 864e5 * increment) - 864e5 * increment;
	      }
	    }
	    return posix;
	  }

	  function convert (vargs) {
	    if (!vargs.length) return "1.0.23";

	    var request = Object.create(this)
	      , adjustments = []
	      , i, I, $, argument, date
	      ;

	    for (i = 0; i < vargs.length; i++) { // leave the for loop alone, it works.
	      argument = vargs[i];
	      // https://twitter.com/bigeasy/status/215112186572439552
	      if (Array.isArray(argument)) {
	        if (!i && !isNaN(argument[1])) {
	          date = argument;
	        } else {
	          argument.splice.apply(vargs, [ i--, 1 ].concat(argument));
	        }
	      } else if (isNaN(argument)) {
	        $ = typeof argument;
	        if ($ == "string") {
	          if (~argument.indexOf("%")) {
	            request.format = argument;
	          } else if (!i && argument == "*") {
	            date = argument;
	          } else if (!i && ($ = /^(\d{4})-(\d{2})-(\d{2})(?:[T\s](\d{2}):(\d{2})(?::(\d{2})(?:\.(\d+))?)?(Z|(([+-])(\d{2}(:\d{2}){0,2})))?)?$/.exec(argument))) {
	            date = [];
	            date.push.apply(date, $.slice(1, 8));
	            if ($[9]) {
	              date.push($[10] + 1);
	              date.push.apply(date, $[11].split(/:/));
	            } else if ($[8]) {
	              date.push(1);
	            }
	          } else if (/^\w{2,3}_\w{2}$/.test(argument)) {
	            request.locale = argument;
	          } else if ($ = UNIT_RE.exec(argument)) {
	            adjustments.push($);
	          } else {
	            request.zone = argument;
	          }
	        } else if ($ == "function") {
	          if ($ = argument.call(request)) return $;
	        } else if (/^\w{2,3}_\w{2}$/.test(argument.name)) {
	          request[argument.name] = argument;
	        } else if (argument.zones) {
	          for ($ in argument.zones) request[$] = argument.zones[$];
	          for ($ in argument.rules) request[$] = argument.rules[$];
	        }
	      } else if (!i) {
	        date = argument;
	      }
	    }

	    if (!request[request.locale]) delete request.locale;
	    if (!request[request.zone]) delete request.zone;

	    if (date != null) {
	      if (date == "*") {
	        date = request.clock();
	      } else if (Array.isArray(date)) {
	        $ = [];
	        I = !date[7];
	        for (i = 0; i < 11; i++) $[i] = +(date[i] || 0); // conversion necessary for decrement
	        --$[1]; // Grr..
	        date = Date.UTC.apply(Date.UTC, $) + -$[7] * ($[8] * 36e5 + $[9] * 6e4 + $[10] * 1e3);
	      } else {
	        date = Math.floor(date);
	      }
	      if (!isNaN(date)) {
	        if (I) date = convertToPOSIX(request, date);

	        if (date == null) return date;

	        for (i = 0, I = adjustments.length; i < I; i++) {
	          date = adjust(request, date, adjustments[i]);
	        }

	        if (!request.format) return date;

	        $ = new Date(convertToWallclock(request, date));
	        return request.format.replace(/%([-0_^]?)(:{0,3})(\d*)(.)/g,
	        function (value, flag, colons, padding, specifier) {
	          var f, fill = "0", pad;
	          if (f = request[specifier]) {
	            value = String(f.call(request, $, date, flag, colons.length));
	            if ((flag || f.style) == "_") fill = " ";
	            pad = flag == "-" ? 0 : f.pad || 0;
	            while (value.length < pad) value = fill + value;
	            pad = flag == "-" ? 0 : padding || f.pad;
	            while (value.length < pad) value = fill + value;
	            if (specifier == "N" && pad < value.length) value = value.slice(0, pad);
	            if (flag == "^") value = value.toUpperCase();
	          }
	          return value;
	        });
	      }
	    }

	    return function () { return request.convert(arguments) };
	  }

	  var context =
	    { clock: function () { return +(new Date()) }
	    , zone: "UTC"
	    , entry: { abbrev: "UTC", offset: 0, save: 0 }
	    , UTC: 1
	    , z: function(date, posix, flag, delimiters) {
	        var offset = this.entry.offset + this.entry.save
	          , seconds = Math.abs(offset / 1000), parts = [], part = 3600, i, z;
	        for (i = 0; i < 3; i++) {
	          parts.push(("0" + Math.floor(seconds / part)).slice(-2));
	          seconds %= part;
	          part /= 60;
	        }
	        if (flag == "^" && !offset) return "Z";
	        if (flag == "^") delimiters = 3;
	        if (delimiters == 3) {
	          z = parts.join(":");
	          z = z.replace(/:00$/, "");
	          if (flag != "^") z = z.replace(/:00$/, "");
	        } else if (delimiters) {
	          z = parts.slice(0, delimiters + 1).join(":");
	          if (flag == "^") z = z.replace(/:00$/, "");
	        } else {
	          z = parts.slice(0, 2).join("");
	        }
	        z = (offset < 0 ? "-" : "+") + z;
	        z = z.replace(/([-+])(0)/, { "_": " $1", "-": "$1" }[flag] || "$1$2");
	        return z;
	      }
	    , "%": function(date) { return "%" }
	    , n: function (date) { return "\n" }
	    , t: function (date) { return "\t" }
	    , U: function (date) { return weekOfYear(date, 0) }
	    , W: function (date) { return weekOfYear(date, 1) }
	    , V: function (date) { return isoWeek(date)[0] }
	    , G: function (date) { return isoWeek(date)[1] }
	    , g: function (date) { return isoWeek(date)[1] % 100 }
	    , j: function (date) { return Math.floor((date.getTime() - Date.UTC(date.getUTCFullYear(), 0)) / 864e5) + 1 }
	    , s: function (date) { return Math.floor(date.getTime() / 1000) }
	    , C: function (date) { return Math.floor(date.getUTCFullYear() / 100) }
	    , N: function (date) { return date.getTime() % 1000 * 1000000 }
	    , m: function (date) { return date.getUTCMonth() + 1 }
	    , Y: function (date) { return date.getUTCFullYear() }
	    , y: function (date) { return date.getUTCFullYear() % 100 }
	    , H: function (date) { return date.getUTCHours() }
	    , M: function (date) { return date.getUTCMinutes() }
	    , S: function (date) { return date.getUTCSeconds() }
	    , e: function (date) { return date.getUTCDate() }
	    , d: function (date) { return date.getUTCDate() }
	    , u: function (date) { return date.getUTCDay() || 7 }
	    , w: function (date) { return date.getUTCDay() }
	    , l: function (date) { return date.getUTCHours() % 12 || 12 }
	    , I: function (date) { return date.getUTCHours() % 12 || 12 }
	    , k: function (date) { return date.getUTCHours() }
	    , Z: function (date) { return this.entry.abbrev }
	    , a: function (date) { return this[this.locale].day.abbrev[date.getUTCDay()] }
	    , A: function (date) { return this[this.locale].day.full[date.getUTCDay()] }
	    , h: function (date) { return this[this.locale].month.abbrev[date.getUTCMonth()] }
	    , b: function (date) { return this[this.locale].month.abbrev[date.getUTCMonth()] }
	    , B: function (date) { return this[this.locale].month.full[date.getUTCMonth()] }
	    , P: function (date) { return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)].toLowerCase() }
	    , p: function (date) { return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)] }
	    , R: function (date, posix) { return this.convert([ posix, "%H:%M" ]) }
	    , T: function (date, posix) { return this.convert([ posix, "%H:%M:%S" ]) }
	    , D: function (date, posix) { return this.convert([ posix, "%m/%d/%y" ]) }
	    , F: function (date, posix) { return this.convert([ posix, "%Y-%m-%d" ]) }
	    , x: function (date, posix) { return this.convert([ posix, this[this.locale].date ]) }
	    , r: function (date, posix) { return this.convert([ posix, this[this.locale].time12 || '%I:%M:%S' ]) }
	    , X: function (date, posix) { return this.convert([ posix, this[this.locale].time24 ]) }
	    , c: function (date, posix) { return this.convert([ posix, this[this.locale].dateTime ]) }
	    , convert: convert
	    , locale: "en_US"
	    , en_US: {
	        date: "%m/%d/%Y",
	        time24: "%I:%M:%S %p",
	        time12: "%I:%M:%S %p",
	        dateTime: "%a %d %b %Y %I:%M:%S %p %Z",
	        meridiem: [ "AM", "PM" ],
	        month: {
	          abbrev: "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec".split("|"),
	          full: "January|February|March|April|May|June|July|August|September|October|November|December".split("|")
	        },
	        day: {
	          abbrev: "Sun|Mon|Tue|Wed|Thu|Fri|Sat".split("|"),
	          full: "Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday".split("|")
	        }
	      }
	    };
	  var UNITS = "Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|year|month|day|hour|minute|second|millisecond"
	    , UNIT_RE = new RegExp("^\\s*([+-])(\\d+)\\s+(" + UNITS + ")s?\\s*$", "i")
	    , TIME = [ 36e5, 6e4, 1e3, 1 ]
	    ;
	  UNITS = UNITS.toLowerCase().split("|");

	  "delmHMSUWVgCIky".replace(/./g, function (e) { context[e].pad = 2; });

	  context.N.pad = 9;
	  context.j.pad = 3;

	  context.k.style = "_";
	  context.l.style = "_";
	  context.e.style = "_";

	  function weekOfYear (date, startOfWeek) {
	    var diff, nyd, weekStart;
	    nyd = new Date(Date.UTC(date.getUTCFullYear(), 0));
	    diff = Math.floor((date.getTime() - nyd.getTime()) / 864e5);
	    if (nyd.getUTCDay() == startOfWeek) {
	      weekStart = 0;
	    } else {
	      weekStart = 7 - nyd.getUTCDay() + startOfWeek;
	      if (weekStart == 8) {
	        weekStart = 1;
	      }
	    }
	    return diff >= weekStart ? Math.floor((diff - weekStart) / 7) + 1 : 0;
	  }

	  function isoWeek (date) {
	    var nyd, nyy, week;
	    nyy = date.getUTCFullYear();
	    nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();
	    week = weekOfYear(date, 1) + (nyd > 1 && nyd <= 4 ? 1 : 0);
	    if (!week) {
	      nyy = date.getUTCFullYear() - 1;
	      nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();
	      week = nyd == 4 || (nyd == 3 && new Date(nyy, 1, 29).getDate() == 29) ? 53 : 52;
	      return [week, date.getUTCFullYear() - 1];
	    } else if (week == 53 && !(nyd == 4 || (nyd == 3 && new Date(nyy, 1, 29).getDate() == 29))) {
	      return [1, date.getUTCFullYear() + 1];
	    } else {
	      return [week, date.getUTCFullYear()];
	    }
	  }

	  return function () { return context.convert(arguments) };
	});
	});

	var New_York={"zones":{"America/New_York":["z",{"wallclock":-94694400000,"format":"E%sT","abbrev":"EST","offset":-18000000,"posix":-94676400000,"save":0,"rules":"US"},{"wallclock":-757382400000,"format":"E%sT","abbrev":"EST","offset":-18000000,"posix":-757364400000,"save":0,"rules":"NYC"},{"wallclock":-883612800000,"format":"E%sT","abbrev":"EST","offset":-18000000,"posix":-883594800000,"save":0,"rules":"US"},{"wallclock":-1577923200000,"format":"E%sT","abbrev":"EST","offset":-18000000,"posix":-1577905200000,"save":0,"rules":"NYC"},{"wallclock":-2717668562000,"format":"E%sT","abbrev":"EST","offset":-18000000,"posix":-2717650800000,"save":0,"rules":"US"},{"wallclock":-1.7976931348623157e+308,"format":"LMT","abbrev":"LMT","offset":-17762000,"posix":-1.7976931348623157e+308,"save":0}]},"rules":{"US":[{"from":2007,"to":1.7976931348623157e+308,"month":2,"day":[0,8],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":2007,"to":1.7976931348623157e+308,"month":10,"day":[0,1],"time":120,"clock":"wallclock","save":0,"letter":"S","saved":3600000},{"from":1967,"to":2006,"month":9,"day":[0,-31],"time":120,"clock":"wallclock","save":0,"letter":"S","saved":3600000},{"from":1987,"to":2006,"month":3,"day":[0,1],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":1976,"to":1986,"month":3,"day":[0,-30],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":1975,"to":1975,"month":1,"day":[7,23],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":1974,"to":1974,"month":0,"day":[7,6],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":1967,"to":1973,"month":3,"day":[0,-30],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":1945,"to":1945,"month":7,"day":[7,14],"time":1380,"clock":"posix","save":60,"letter":"P","saved":3600000},{"from":1945,"to":1945,"month":8,"day":[0,-30],"time":120,"clock":"wallclock","save":0,"letter":"S","saved":3600000},{"from":1942,"to":1942,"month":1,"day":[7,9],"time":120,"clock":"wallclock","save":60,"letter":"W","saved":0},{"from":1918,"to":1919,"month":2,"day":[0,-31],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":1918,"to":1919,"month":9,"day":[0,-31],"time":120,"clock":"wallclock","save":0,"letter":"S","saved":3600000}],"NYC":[{"from":1921,"to":1966,"month":3,"day":[0,-30],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":1955,"to":1966,"month":9,"day":[0,-31],"time":120,"clock":"wallclock","save":0,"letter":"S","saved":3600000},{"from":1921,"to":1954,"month":8,"day":[0,-30],"time":120,"clock":"wallclock","save":0,"letter":"S","saved":3600000},{"from":1920,"to":1920,"month":2,"day":[0,-31],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":1920,"to":1920,"month":9,"day":[0,-31],"time":120,"clock":"wallclock","save":0,"letter":"S","saved":3600000}]}};

	const heartbeatThreshold = 20000; // 20 seconds
	// eslint-disable-next-line consistent-return

	function mergeCustomizer(objValue, srcValue) {
	  if (srcValue === null) {
	    return objValue;
	  }
	}

	function playheadOffset(player, plugin) {
	  if (!player.mediainfo) {
	    return;
	  }

	  if (typeof plugin.setPlayheadOffset === 'function' && player.mediainfo.live && player.mediainfo.startDateTime) {
	    const playheadOffset = Math.round((now() - player.mediainfo.startDateTime) / 1000);
	    player.on('omnitureReady', () => {
	      plugin.setPlayheadOffset(playheadOffset);
	    });
	  }
	}

	function configure(player, config) {
	  let contentMetadata = {};
	  const localConfig = {
	    NIELSEN_DATA: {
	      CONTENT_METADATA: {}
	    },
	    ESPN_CUSTOM_METADATA: {
	      Showcode: player.mediainfo.showcode
	    }
	  }; // https://espnjira.disney.com/browse/VPLAYREPLACE-769
	  // Airdate, formatted as `yyyyMMddHH:mm:ss`

	  if (player.mediainfo.originalPublishDate) {
	    localConfig.NIELSEN_DATA.CONTENT_METADATA.airdate = timezone(player.mediainfo.originalPublishDate, '%Y%m%d%k%M%S', New_York, 'America/New_York');
	  }

	  if (player.mediainfo.live) {
	    localConfig.MEDIAINFO = {
	      live: true
	    };
	  } // https://espnjira.disney.com/browse/WEBPLAYER-102
	  //     Live/Long Form Replays OR Long Form on-Demand Content Should = 0
	  //     All Short Form VOD = 2
	  //
	  // The presence of `airingId` on `mediainfo` _should_ indicate that we have
	  // either live or replay content, anything else would be a VOD clip


	  if (player.mediainfo.airingId || player.mediainfo.live) {
	    localConfig.ESPN_CUSTOM_METADATA[ADB.va.plugins.aa.VideoMetadataKeys.SHOW_TYPE] = '0';
	  } else {
	    localConfig.ESPN_CUSTOM_METADATA[ADB.va.plugins.aa.VideoMetadataKeys.SHOW_TYPE] = '2';
	  }

	  if (player.mediainfo.hasNielsenWatermarks) {
	    contentMetadata = {
	      adloadtype: 1,
	      dataSrc: 'ID3',
	      tv: true
	    };
	  } // https://espnjira.disney.com/browse/VPLAYREPLACE-769
	  // Shared inventory


	  if (player.mediainfo.commercialReplacement === 'SHARED INV') {
	    contentMetadata.adloadtype = 1;
	  } // https://espnjira.disney.com/browse/VPLAYREPLACE-769
	  // Cross Reference ID 1


	  if (player.mediainfo.nielsenCrossId1) {
	    contentMetadata.crossId1 = player.mediainfo.nielsenCrossId1;
	  } // https://espnjira.disney.com/browse/WEWEB-1261
	  // Cross Reference ID 2


	  if (player.mediainfo.nielsenCrossId2) {
	    contentMetadata.crossId2 = player.mediainfo.nielsenCrossId2.toLowerCase();
	  }

	  lodash_mergewith(localConfig.NIELSEN_DATA.CONTENT_METADATA, contentMetadata, mergeCustomizer);
	  lodash_mergewith(config, localConfig, mergeCustomizer);
	  return config;
	}

	function setEventListeners(player, plugin, nielsenPlugin, coordinator) {
	  let adBreakStarted;
	  let adStarted;
	  let heartbeatTimeout;
	  const canTrackAdStartComplete = typeof plugin.trackAdStart === 'function' && typeof plugin.trackAdComplete === 'function';

	  function trackAdComplete(adID) {
	    // console.log('sending trackAdComplete', player.currentTime());
	    if (adStarted) {
	      plugin.trackAdComplete();
	      nielsenPlugin.trackAdComplete();

	      if (adID) {
	        coordinator.coordinate('dtci.ads.adEnded', {
	          type: 'midroll',
	          id: adID
	        });
	      }
	    }

	    adStarted = false;
	  }

	  function trackAdBreakStart() {
	    // console.log('sending trackAdBreakStart');
	    adBreakStarted = true;
	    plugin.trackAdBreakStart('midroll', player.currentTime());
	    nielsenPlugin.trackAdBreakStart();
	  }

	  function trackAdStart(adID) {
	    // console.log('sending trackAdStart', player.currentTime());
	    clearTimeout(heartbeatTimeout);

	    if (!adBreakStarted) {
	      trackAdBreakStart();
	    }

	    plugin.trackAdStart(adID);
	    nielsenPlugin.trackAdStart(adID);
	    adStarted = now();

	    if (adID) {
	      coordinator.coordinate('dtci.ads.adStarted', {
	        type: 'midroll',
	        id: adID
	      });
	    }
	  }

	  function startHeartbeatTimer() {
	    // console.debug('starting ad timer', player.currentTime());
	    heartbeatTimeout = setTimeout$1(trackAdStart, heartbeatThreshold);
	  }

	  function trackAdBreakComplete() {
	    // console.log('sending trackAdBreakComplete');
	    plugin.trackAdBreakComplete();
	    nielsenPlugin.trackAdBreakComplete();
	    adBreakStarted = false;
	  }

	  function resetHeartbeatTimer() {
	    // console.log('resetting ad timer', player.currentTime(), adBreakStarted, adStarted);
	    clearTimeout(heartbeatTimeout); // An ad break was started at least 20 seconds ago.

	    if (adStarted && adStarted + heartbeatThreshold < now()) {
	      trackAdComplete();
	      trackAdBreakComplete();
	    }

	    startHeartbeatTimer();
	  }

	  function onPause() {
	    // console.debug('stopping ad timer');
	    if (!player.mediainfo.hasEspnId3Heartbeats) {
	      return;
	    }

	    clearTimeout(heartbeatTimeout);
	    player.one('play', () => {
	      startHeartbeatTimer();
	    });
	  }

	  function shouldSendID(player, cue) {
	    if (!player.mediainfo) {
	      return false;
	    }

	    return typeof plugin.sendID3 === 'function' && cue.owner && cue.owner.match(/^www\.nielsen\.com/i) !== null && (player.mediainfo.hasNielsenWatermarks || player.mediaItem.source.type === 'entitlement');
	  }

	  function onCueChange(event, cue) {
	    let payload;

	    try {
	      payload = JSON.parse(cue.text);
	    } catch (e) {
	      payload = cue.text;
	    }

	    const shouldSendID3 = shouldSendID(player, cue);
	    const shouldTrackAdTransitions = canTrackAdStartComplete && cue.owner === 'com.espn.authnet.transition';
	    const shouldResetAdTimer = canTrackAdStartComplete && player.mediainfo.hasEspnId3Heartbeats && cue.owner === 'com.espn.authnet.heartbeat' && payload[0].type === 'PROGRAM' && !(payload[1] && payload[1].type === 'COMMERCIAL');

	    if (shouldSendID3) {
	      // console.log(cue.owner);
	      const data = player.mediaItem.source.type === 'entitlement' ? cue.text : cue.owner;
	      nielsenPlugin.sendID3(data);
	    }

	    if (shouldTrackAdTransitions) {
	      // console.log('transitioning from ' + payload.from.type + ' to ' + payload.to.type);
	      if (payload.from.type === 'PROGRAM' && payload.to.type === 'COMMERCIAL') {
	        coordinator.coordinate('dtci.ads.podStarted', {
	          type: 'midroll'
	        });
	        trackAdBreakStart();
	        trackAdStart(payload.to.id);
	      } else if (payload.from.type === 'COMMERCIAL' && payload.to.type === 'COMMERCIAL') {
	        trackAdComplete(payload.from.id);
	        trackAdStart(payload.to.id);
	      } else if (payload[1] && payload[1].type === 'COMMERCIAL') {
	        trackAdStart(payload[1].id);
	      } else if (payload.from.type === 'COMMERCIAL' && payload.to.type === 'PROGRAM') {
	        trackAdComplete(payload.from.id);
	        trackAdBreakComplete();
	        coordinator.coordinate('dtci.ads.podEnded', {
	          type: 'midroll'
	        });
	      }
	    }

	    if (shouldResetAdTimer) {
	      resetHeartbeatTimer();
	    }
	  }

	  player.on('pause', onPause);
	  player.on('dtci.id3.cueChange', onCueChange);
	  player.one('dispose', () => {
	    player.off('pause', onPause);
	    player.off('dtci.id3.cueChange', onCueChange);
	    clearTimeout(heartbeatTimeout);
	  });
	}

	class ESPNAdobeNielsenAdapter {
	  constructor(player, config, coordinator) {
	    if (typeof ADB === 'undefined') {
	      console.warn('DTCIVideoPlayer: Adobe Analytics SDK is not available');
	      return;
	    }

	    this.player = player; // eslint-disable-next-line no-param-reassign

	    config = configure(this.player, config);

	    if (typeof this.player.BCGSAdobeDCRPlugin === 'function') {
	      // Brightcove's plugin
	      this.plugin = this.player.BCGSAdobeDCRPlugin({
	        options: config,
	        debug: config.DEBUG
	      });
	    } else {
	      console.error('DTCIVideoPlayer: No Adobe/Nielsen plugin found');
	      return;
	    }

	    if (typeof this.player.nielsen === 'function') {
	      this.nielsenPlugin = player.nielsen(config.NIELSEN_DATA);
	    }

	    playheadOffset(this.player, this.plugin);
	    setEventListeners(this.player, this.plugin, this.nielsenPlugin, coordinator);
	  }

	  loadNewOptions(options) {
	    // console.debug('loading new options');
	    if (typeof this.plugin === 'function') {
	      this.plugin({
	        options
	      });
	    } else if (typeof this.plugin.loadNewOptions === 'function') {
	      this.plugin.loadNewOptions(options);
	    }
	  }

	  completeLiveProgram() {
	    if (typeof this.plugin.completeLiveProgram === 'function') {
	      this.plugin.completeLiveProgram();
	    }
	  }

	}

	var non = '\u200B\u0085\u180E';

	// check that a method works with the correct list
	// of whitespaces and has a correct name
	var stringTrimForced = function (METHOD_NAME) {
	  return fails(function () {
	    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
	  });
	};

	var $trim = stringTrim.trim;


	// `String.prototype.trim` method
	// https://tc39.es/ecma262/#sec-string.prototype.trim
	_export({ target: 'String', proto: true, forced: stringTrimForced('trim') }, {
	  trim: function trim() {
	    return $trim(this);
	  }
	});

	var trim$2 = entryVirtual('String').trim;

	var StringPrototype = String.prototype;

	var trim_1 = function (it) {
	  var own = it.trim;
	  return typeof it === 'string' || it === StringPrototype
	    || (it instanceof String && own === StringPrototype.trim) ? trim$2 : own;
	};

	var trim$1 = trim_1;

	var trim = trim$1;

	/* eslint-disable no-plusplus */

	/* eslint-disable no-bitwise */

	/* globals videojs */
	// From https://edgecastcdn.net/00BB17/fiosmobile/develop/uplynk/web-player-test-app-1.0.8/app/components/utils/fairplay-utils.js
	function arrayToString(array) {
	  const uint16array = new Uint16Array(array.buffer);
	  return String.fromCharCode.apply(null, uint16array);
	}

	function base64EncodeUint8Array(input) {
	  const keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	  let output = '';
	  let chr1;
	  let chr2;
	  let chr3;
	  let enc1;
	  let enc2;
	  let enc3;
	  let enc4;
	  let i = 0;

	  while (i < input.length) {
	    chr1 = input[i++];
	    chr2 = i < input.length ? input[i++] : Number.NaN; // Not sure if the index

	    chr3 = i < input.length ? input[i++] : Number.NaN; // checks are needed here

	    enc1 = chr1 >> 2;
	    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
	    enc3 = (chr2 & 15) << 2 | chr3 >> 6;
	    enc4 = chr3 & 63;

	    if (isNaN(chr2)) {
	      enc3 = 64;
	      enc4 = 64;
	    } else if (isNaN(chr3)) {
	      enc4 = 64;
	    }

	    output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
	  }

	  return output;
	}

	function base64DecodeUint8Array(input) {
	  const raw = window.atob(input);
	  const rawLength = raw.length;
	  const array = new Uint8Array(new ArrayBuffer(rawLength));

	  for (let i = 0; i < rawLength; i++) {
	    array[i] = raw.charCodeAt(i);
	  }

	  return array;
	}

	let licenseURL;
	function getCertificate(emeOptions, callback) {
	  const requestCertUri = emeOptions.keySystems['com.apple.fps.1_0'].certificateUri;
	  videojs.xhr({
	    uri: requestCertUri,
	    responseType: 'arraybuffer'
	  }, (err, response) => {
	    if (err) {
	      callback(err);
	      return;
	    }

	    const certificate = new Uint8Array(response.body);
	    callback(null, certificate);
	  });
	}
	function getContentId(emeOptions, initData) {
	  const contentId = arrayToString(initData);
	  let spcurl = contentId.replace('skd://', 'https://');
	  spcurl = spcurl.substring(1, spcurl.length); // split the url and use the query parameters as the license identifier.

	  let id = spcurl.split('?')[1];

	  if (id.length > 100) {
	    // content id's cannot be longer than 100 bytes or the license request never gets sent.
	    id = id.substring(0, 100);
	  } // save the license URL in a global location with the content ID as a lookup key
	  // to be later used for posting the license


	  licenseURL = spcurl;
	  return id;
	}
	function getLicense(emeOptions, contentId, keyMessage, callback) {
	  const spcMessage = base64EncodeUint8Array(keyMessage);
	  const ckcRequest = {
	    spc: spcMessage
	  };

	  const payload = stringify(ckcRequest);

	  const xhr = new XMLHttpRequest();
	  xhr.addEventListener('readystatechange', () => {
	    if (xhr.readyState === 4) {
	      var _context;

	      const wrapped = JSON.parse(trim(_context = xhr.responseText).call(_context));
	      const key = base64DecodeUint8Array(wrapped.ckc);
	      callback(null, key); // player.play();
	    }
	  });
	  xhr.open('POST', licenseURL);
	  xhr.send(payload);
	}

	function request(url) {
	  return new promise((resolve, reject) => {
	    const xhr = new XMLHttpRequest();
	    xhr.open('GET', url, true);

	    xhr.onreadystatechange = () => {
	      if (xhr.readyState === 4) {
	        if (xhr.status === 200) {
	          resolve(xhr.response);
	        } else {
	          reject(new Error('Error ', url));
	        }
	      }
	    };

	    xhr.send();
	  });
	}

	async function parseXML(mdpUrl) {
	  let parser;
	  let xmlDoc;
	  const data = await request(mdpUrl);

	  if (window.DOMParser) {
	    parser = new DOMParser();
	    xmlDoc = parser.parseFromString(data, 'text/xml');
	  }

	  return xmlDoc;
	}

	function b64ToUint6(nChr) {
	  return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
	}

	function base64DecToArr(sBase64, nBlockSize) {
	  const sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, '');
	  const nInLen = sB64Enc.length;
	  const nOutLen = nBlockSize ? Math.ceil((nInLen * 3 + 1 >>> 2) / nBlockSize) * nBlockSize : nInLen * 3 + 1 >>> 2;
	  const aBytes = new Uint8Array(nOutLen);

	  for (let nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
	    nMod4 = nInIdx & 3;
	    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;

	    if (nMod4 === 3 || nInLen - nInIdx === 1) {
	      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
	        aBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
	      }

	      nUint24 = 0;
	    }
	  }

	  return aBytes;
	}

	function decodeLicense(licenseElement, isPlayready) {
	  if (isPlayready) {
	    const decodePlayReadyData = String.fromCharCode.apply(null, new Uint16Array(base64DecToArr(licenseElement.textContent, 2).buffer));
	    const regex = new RegExp(/<LA_URL>(.*)<\/LA_URL>/);
	    return decodePlayReadyData.match(regex)[1];
	  }

	  const htmlValue = new DOMParser().parseFromString(licenseElement.outerHTML, 'text/xml');
	  return encodeURI(htmlValue.firstElementChild.attributes.licenseUrl.nodeValue);
	}

	async function getUplynkLicense(mdpUrl, keySystem) {
	  let license;
	  const isPlayready = keySystem === 'playready';

	  try {
	    const mdpData = await parseXML(mdpUrl);

	    if (mdpData) {
	      const tagName = isPlayready && IS_WINDOWS ? 'mspr:pro' : 'ms:laurl';
	      const licenseElement = (mdpData.getElementsByTagName(tagName) || [])[0];

	      if (licenseElement) {
	        license = decodeLicense(licenseElement, isPlayready && IS_WINDOWS);
	      } else {
	        license = (mdpData.getElementsByTagName('Location') || [])[0];
	      }
	    }
	  } catch (err) {
	    console.error('error fetching playreadylicense', err);
	  }

	  return license;
	}

	async function drmSourceBuilder(playbackSession) {
	  const {
	    playbackUrl: src,
	    playbackConfig,
	    mediaItem: {
	      source: mediaSource
	    } = {}
	  } = playbackSession || {};
	  const isEntertainment = mediaSource && mediaSource.type === 'entitlement' || false;
	  const {
	    contentType: type = null,
	    keySystem = null
	  } = playbackConfig || {};
	  let {
	    licenseUrl = null
	  } = playbackConfig || {};
	  const source = {
	    src,
	    type
	  };

	  if (isEntertainment && keySystem !== 'fairplay') {
	    licenseUrl = await getUplynkLicense(src, keySystem);
	  }

	  switch (keySystem) {
	    case keySystem === 'playready' && IS_WINDOWS:
	      source.keySystems = {
	        'com.microsoft.playready': licenseUrl
	      };
	      source.keySystemOptions = [{
	        name: 'com.microsoft.playready',
	        options: {
	          serverURL: licenseUrl
	        }
	      }];
	      break;

	    case 'fairplay':
	      source.keySystems = {
	        'com.apple.fps.1_0': {
	          certificateUri: licenseUrl,
	          getCertificate,
	          getContentId,
	          getLicense
	        }
	      };
	      break;

	    case 'widevine':
	      source.keySystems = {
	        'com.widevine.alpha': licenseUrl
	      };
	      source.keySystemOptions = [{
	        name: 'com.widevine.alpha',
	        options: {
	          serverURL: licenseUrl
	        }
	      }];
	  }

	  if (keySystem && keySystem !== 'none' && IS_EDGE_CHROMIUM && IS_WINDOWS) {
	    const playreadyLicense = isEntertainment ? licenseUrl : await getUplynkLicense(src, 'playready');
	    source.keySystems = {
	      'com.widevine.alpha': licenseUrl,
	      'com.microsoft.playready': playreadyLicense
	    };
	    source.keySystemOptions = [{
	      name: 'com.microsoft.playready',
	      options: {
	        serverURL: playreadyLicense
	      }
	    }, {
	      name: 'com.widevine.alpha',
	      options: {
	        serverURL: licenseUrl
	      }
	    }];
	  }

	  return source;
	}
	function drmSupportParam() {
	  let drmSupport; // Do not pass param for unsupported platforms

	  if (IS_WEBVIEW && !IS_ANDROID) {
	    drmSupport = 'HLS';
	  }

	  if (IS_ANDROID) {
	    drmSupport = null; // Explicitly force old Android, that doesn't support EME, to fail by passing an empty param
	  }

	  if (SUPPORTS_EME) {
	    if (IS_EDGE) {
	      drmSupport = 'DASH_PLAYREADY';
	    } else if (IE_VERSION) {
	      drmSupport = null; // Explicitly force IE to fail by passing an empty param
	    } else if (IS_FIREFOX || IS_CHROME && !IS_IOS
	    /* exclude iOS Chrome */
	    ) {
	        drmSupport = 'DASH_WIDEVINE';
	      } else if (IS_SAFARI) {
	      drmSupport = 'HLS_FAIRPLAY';
	    }
	  } else {
	    console.warn('DTCIVideoPlayer: DRM was requested by configuration, but this browser does not support EME.');
	  }

	  return drmSupport;
	}
	function getDRMSupport(drmSupport, enabledDrmSupportValues = []) {
	  let drmSupport_ = drmSupport;
	  const enabledHLSDrmSupport = drmSupport === undefined || indexOf(enabledDrmSupportValues).call(enabledDrmSupportValues, drmSupport) === -1;

	  if (enabledHLSDrmSupport) {
	    drmSupport_ = 'HLS';
	  }

	  return drmSupport_;
	}

	var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');

	var max = Math.max;
	var min = Math.min;
	var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

	// `Array.prototype.splice` method
	// https://tc39.es/ecma262/#sec-array.prototype.splice
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
	  splice: function splice(start, deleteCount /* , ...items */) {
	    var O = toObject(this);
	    var len = toLength(O.length);
	    var actualStart = toAbsoluteIndex(start, len);
	    var argumentsLength = arguments.length;
	    var insertCount, actualDeleteCount, A, k, from, to;
	    if (argumentsLength === 0) {
	      insertCount = actualDeleteCount = 0;
	    } else if (argumentsLength === 1) {
	      insertCount = 0;
	      actualDeleteCount = len - actualStart;
	    } else {
	      insertCount = argumentsLength - 2;
	      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
	    }
	    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {
	      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
	    }
	    A = arraySpeciesCreate(O, actualDeleteCount);
	    for (k = 0; k < actualDeleteCount; k++) {
	      from = actualStart + k;
	      if (from in O) createProperty(A, k, O[from]);
	    }
	    A.length = actualDeleteCount;
	    if (insertCount < actualDeleteCount) {
	      for (k = actualStart; k < len - actualDeleteCount; k++) {
	        from = k + actualDeleteCount;
	        to = k + insertCount;
	        if (from in O) O[to] = O[from];
	        else delete O[to];
	      }
	      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
	    } else if (insertCount > actualDeleteCount) {
	      for (k = len - actualDeleteCount; k > actualStart; k--) {
	        from = k + actualDeleteCount - 1;
	        to = k + insertCount - 1;
	        if (from in O) O[to] = O[from];
	        else delete O[to];
	      }
	    }
	    for (k = 0; k < insertCount; k++) {
	      O[k + actualStart] = arguments[k + 2];
	    }
	    O.length = len - actualDeleteCount + insertCount;
	    return A;
	  }
	});

	var splice$2 = entryVirtual('Array').splice;

	var ArrayPrototype$1 = Array.prototype;

	var splice_1 = function (it) {
	  var own = it.splice;
	  return it === ArrayPrototype$1 || (it instanceof Array && own === ArrayPrototype$1.splice) ? splice$2 : own;
	};

	var splice$1 = splice_1;

	var splice = splice$1;

	/*
	  If the video URL looks like:

	    http://media.video-cdn.espn.com/motion/2015/0318/dm_150318_ncb_feature_president_obama_bracket/dm_150318_ncb_feature_president_obama_bracket.m3u8

	  Then our thumbnail URLs should look like:

	    http://media.video-cdn.espn.com/motion/2015/0318/dm_150318_ncb_feature_president_obama_bracket/chaptertn/dm_150318_ncb_feature_president_obama_bracket_{N}.jpg

	  Chapter thumbnails appear every 10 seconds, beginning at 0:00.

	  Builds an object like this:
	    {
	      "0": {
	        "src": "http://media.video-cdn.espn.com/motion/2015/0318/dm_150318_ncb_feature_pres…bama_bracket/chaptertn/dm_150318_ncb_feature_president_obama_bracket_1.jpg"
	      },
	      "10": {
	        "src": "http://media.video-cdn.espn.com/motion/2015/0318/dm_150318_ncb_feature_pres…bama_bracket/chaptertn/dm_150318_ncb_feature_president_obama_bracket_2.jpg"
	      },
	      "20": {
	        "src": "http://media.video-cdn.espn.com/motion/2015/0318/dm_150318_ncb_feature_pres…bama_bracket/chaptertn/dm_150318_ncb_feature_president_obama_bracket_3.jpg"
	      },
	      "30": {
	        "src": "http://media.video-cdn.espn.com/motion/2015/0318/dm_150318_ncb_feature_pres…bama_bracket/chaptertn/dm_150318_ncb_feature_president_obama_bracket_4.jpg"
	      },
	    }
	 */
	function buildPrevewsFromVideoCDN(pathMatch, duration, imageConfig) {
	  const base = 'https://media.video-cdn.espn.com/motion/';
	  const parts = pathMatch.pop().split('/');

	  splice(parts).call(parts, -1, 0, 'chaptertn'); // Some playback URLs from MediaItem are suffixed with `_nolbr`, need to
	  // remove that to build a valid thumbnail URL


	  const path = parts.join('/').replace('_nolbr', '');
	  const numPreviews = Math.floor(duration / imageConfig.secondPerChapter);
	  const previews = {};
	  let i = 0;

	  while (i <= numPreviews) {
	    previews[`${i * 10}`] = {
	      src: `${base}${path}_${i += 1}.${imageConfig.extension}`,
	      width: imageConfig.width
	    };
	  }

	  return previews;
	}

	var global$1 =
	  (typeof globalThis !== 'undefined' && globalThis) ||
	  (typeof self !== 'undefined' && self) ||
	  (typeof global$1 !== 'undefined' && global$1);

	var support = {
	  searchParams: 'URLSearchParams' in global$1,
	  iterable: 'Symbol' in global$1 && 'iterator' in Symbol,
	  blob:
	    'FileReader' in global$1 &&
	    'Blob' in global$1 &&
	    (function() {
	      try {
	        new Blob();
	        return true
	      } catch (e) {
	        return false
	      }
	    })(),
	  formData: 'FormData' in global$1,
	  arrayBuffer: 'ArrayBuffer' in global$1
	};

	function isDataView(obj) {
	  return obj && DataView.prototype.isPrototypeOf(obj)
	}

	if (support.arrayBuffer) {
	  var viewClasses = [
	    '[object Int8Array]',
	    '[object Uint8Array]',
	    '[object Uint8ClampedArray]',
	    '[object Int16Array]',
	    '[object Uint16Array]',
	    '[object Int32Array]',
	    '[object Uint32Array]',
	    '[object Float32Array]',
	    '[object Float64Array]'
	  ];

	  var isArrayBufferView =
	    ArrayBuffer.isView ||
	    function(obj) {
	      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
	    };
	}

	function normalizeName(name) {
	  if (typeof name !== 'string') {
	    name = String(name);
	  }
	  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
	    throw new TypeError('Invalid character in header field name: "' + name + '"')
	  }
	  return name.toLowerCase()
	}

	function normalizeValue(value) {
	  if (typeof value !== 'string') {
	    value = String(value);
	  }
	  return value
	}

	// Build a destructive iterator for the value list
	function iteratorFor(items) {
	  var iterator = {
	    next: function() {
	      var value = items.shift();
	      return {done: value === undefined, value: value}
	    }
	  };

	  if (support.iterable) {
	    iterator[Symbol.iterator] = function() {
	      return iterator
	    };
	  }

	  return iterator
	}

	function Headers(headers) {
	  this.map = {};

	  if (headers instanceof Headers) {
	    headers.forEach(function(value, name) {
	      this.append(name, value);
	    }, this);
	  } else if (Array.isArray(headers)) {
	    headers.forEach(function(header) {
	      this.append(header[0], header[1]);
	    }, this);
	  } else if (headers) {
	    Object.getOwnPropertyNames(headers).forEach(function(name) {
	      this.append(name, headers[name]);
	    }, this);
	  }
	}

	Headers.prototype.append = function(name, value) {
	  name = normalizeName(name);
	  value = normalizeValue(value);
	  var oldValue = this.map[name];
	  this.map[name] = oldValue ? oldValue + ', ' + value : value;
	};

	Headers.prototype['delete'] = function(name) {
	  delete this.map[normalizeName(name)];
	};

	Headers.prototype.get = function(name) {
	  name = normalizeName(name);
	  return this.has(name) ? this.map[name] : null
	};

	Headers.prototype.has = function(name) {
	  return this.map.hasOwnProperty(normalizeName(name))
	};

	Headers.prototype.set = function(name, value) {
	  this.map[normalizeName(name)] = normalizeValue(value);
	};

	Headers.prototype.forEach = function(callback, thisArg) {
	  for (var name in this.map) {
	    if (this.map.hasOwnProperty(name)) {
	      callback.call(thisArg, this.map[name], name, this);
	    }
	  }
	};

	Headers.prototype.keys = function() {
	  var items = [];
	  this.forEach(function(value, name) {
	    items.push(name);
	  });
	  return iteratorFor(items)
	};

	Headers.prototype.values = function() {
	  var items = [];
	  this.forEach(function(value) {
	    items.push(value);
	  });
	  return iteratorFor(items)
	};

	Headers.prototype.entries = function() {
	  var items = [];
	  this.forEach(function(value, name) {
	    items.push([name, value]);
	  });
	  return iteratorFor(items)
	};

	if (support.iterable) {
	  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
	}

	function consumed(body) {
	  if (body.bodyUsed) {
	    return Promise.reject(new TypeError('Already read'))
	  }
	  body.bodyUsed = true;
	}

	function fileReaderReady(reader) {
	  return new Promise(function(resolve, reject) {
	    reader.onload = function() {
	      resolve(reader.result);
	    };
	    reader.onerror = function() {
	      reject(reader.error);
	    };
	  })
	}

	function readBlobAsArrayBuffer(blob) {
	  var reader = new FileReader();
	  var promise = fileReaderReady(reader);
	  reader.readAsArrayBuffer(blob);
	  return promise
	}

	function readBlobAsText(blob) {
	  var reader = new FileReader();
	  var promise = fileReaderReady(reader);
	  reader.readAsText(blob);
	  return promise
	}

	function readArrayBufferAsText(buf) {
	  var view = new Uint8Array(buf);
	  var chars = new Array(view.length);

	  for (var i = 0; i < view.length; i++) {
	    chars[i] = String.fromCharCode(view[i]);
	  }
	  return chars.join('')
	}

	function bufferClone(buf) {
	  if (buf.slice) {
	    return buf.slice(0)
	  } else {
	    var view = new Uint8Array(buf.byteLength);
	    view.set(new Uint8Array(buf));
	    return view.buffer
	  }
	}

	function Body() {
	  this.bodyUsed = false;

	  this._initBody = function(body) {
	    /*
	      fetch-mock wraps the Response object in an ES6 Proxy to
	      provide useful test harness features such as flush. However, on
	      ES5 browsers without fetch or Proxy support pollyfills must be used;
	      the proxy-pollyfill is unable to proxy an attribute unless it exists
	      on the object before the Proxy is created. This change ensures
	      Response.bodyUsed exists on the instance, while maintaining the
	      semantic of setting Request.bodyUsed in the constructor before
	      _initBody is called.
	    */
	    this.bodyUsed = this.bodyUsed;
	    this._bodyInit = body;
	    if (!body) {
	      this._bodyText = '';
	    } else if (typeof body === 'string') {
	      this._bodyText = body;
	    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	      this._bodyBlob = body;
	    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	      this._bodyFormData = body;
	    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	      this._bodyText = body.toString();
	    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
	      this._bodyArrayBuffer = bufferClone(body.buffer);
	      // IE 10-11 can't handle a DataView body.
	      this._bodyInit = new Blob([this._bodyArrayBuffer]);
	    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
	      this._bodyArrayBuffer = bufferClone(body);
	    } else {
	      this._bodyText = body = Object.prototype.toString.call(body);
	    }

	    if (!this.headers.get('content-type')) {
	      if (typeof body === 'string') {
	        this.headers.set('content-type', 'text/plain;charset=UTF-8');
	      } else if (this._bodyBlob && this._bodyBlob.type) {
	        this.headers.set('content-type', this._bodyBlob.type);
	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	      }
	    }
	  };

	  if (support.blob) {
	    this.blob = function() {
	      var rejected = consumed(this);
	      if (rejected) {
	        return rejected
	      }

	      if (this._bodyBlob) {
	        return Promise.resolve(this._bodyBlob)
	      } else if (this._bodyArrayBuffer) {
	        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
	      } else if (this._bodyFormData) {
	        throw new Error('could not read FormData body as blob')
	      } else {
	        return Promise.resolve(new Blob([this._bodyText]))
	      }
	    };

	    this.arrayBuffer = function() {
	      if (this._bodyArrayBuffer) {
	        var isConsumed = consumed(this);
	        if (isConsumed) {
	          return isConsumed
	        }
	        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
	          return Promise.resolve(
	            this._bodyArrayBuffer.buffer.slice(
	              this._bodyArrayBuffer.byteOffset,
	              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
	            )
	          )
	        } else {
	          return Promise.resolve(this._bodyArrayBuffer)
	        }
	      } else {
	        return this.blob().then(readBlobAsArrayBuffer)
	      }
	    };
	  }

	  this.text = function() {
	    var rejected = consumed(this);
	    if (rejected) {
	      return rejected
	    }

	    if (this._bodyBlob) {
	      return readBlobAsText(this._bodyBlob)
	    } else if (this._bodyArrayBuffer) {
	      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
	    } else if (this._bodyFormData) {
	      throw new Error('could not read FormData body as text')
	    } else {
	      return Promise.resolve(this._bodyText)
	    }
	  };

	  if (support.formData) {
	    this.formData = function() {
	      return this.text().then(decode)
	    };
	  }

	  this.json = function() {
	    return this.text().then(JSON.parse)
	  };

	  return this
	}

	// HTTP methods whose capitalization should be normalized
	var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

	function normalizeMethod(method) {
	  var upcased = method.toUpperCase();
	  return methods.indexOf(upcased) > -1 ? upcased : method
	}

	function Request(input, options) {
	  if (!(this instanceof Request)) {
	    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
	  }

	  options = options || {};
	  var body = options.body;

	  if (input instanceof Request) {
	    if (input.bodyUsed) {
	      throw new TypeError('Already read')
	    }
	    this.url = input.url;
	    this.credentials = input.credentials;
	    if (!options.headers) {
	      this.headers = new Headers(input.headers);
	    }
	    this.method = input.method;
	    this.mode = input.mode;
	    this.signal = input.signal;
	    if (!body && input._bodyInit != null) {
	      body = input._bodyInit;
	      input.bodyUsed = true;
	    }
	  } else {
	    this.url = String(input);
	  }

	  this.credentials = options.credentials || this.credentials || 'same-origin';
	  if (options.headers || !this.headers) {
	    this.headers = new Headers(options.headers);
	  }
	  this.method = normalizeMethod(options.method || this.method || 'GET');
	  this.mode = options.mode || this.mode || null;
	  this.signal = options.signal || this.signal;
	  this.referrer = null;

	  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	    throw new TypeError('Body not allowed for GET or HEAD requests')
	  }
	  this._initBody(body);

	  if (this.method === 'GET' || this.method === 'HEAD') {
	    if (options.cache === 'no-store' || options.cache === 'no-cache') {
	      // Search for a '_' parameter in the query string
	      var reParamSearch = /([?&])_=[^&]*/;
	      if (reParamSearch.test(this.url)) {
	        // If it already exists then set the value with the current time
	        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
	      } else {
	        // Otherwise add a new '_' parameter to the end with the current time
	        var reQueryString = /\?/;
	        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
	      }
	    }
	  }
	}

	Request.prototype.clone = function() {
	  return new Request(this, {body: this._bodyInit})
	};

	function decode(body) {
	  var form = new FormData();
	  body
	    .trim()
	    .split('&')
	    .forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=');
	        var name = split.shift().replace(/\+/g, ' ');
	        var value = split.join('=').replace(/\+/g, ' ');
	        form.append(decodeURIComponent(name), decodeURIComponent(value));
	      }
	    });
	  return form
	}

	function parseHeaders(rawHeaders) {
	  var headers = new Headers();
	  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
	  // https://tools.ietf.org/html/rfc7230#section-3.2
	  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
	  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
	  // https://github.com/github/fetch/issues/748
	  // https://github.com/zloirock/core-js/issues/751
	  preProcessedHeaders
	    .split('\r')
	    .map(function(header) {
	      return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header
	    })
	    .forEach(function(line) {
	      var parts = line.split(':');
	      var key = parts.shift().trim();
	      if (key) {
	        var value = parts.join(':').trim();
	        headers.append(key, value);
	      }
	    });
	  return headers
	}

	Body.call(Request.prototype);

	function Response(bodyInit, options) {
	  if (!(this instanceof Response)) {
	    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
	  }
	  if (!options) {
	    options = {};
	  }

	  this.type = 'default';
	  this.status = options.status === undefined ? 200 : options.status;
	  this.ok = this.status >= 200 && this.status < 300;
	  this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
	  this.headers = new Headers(options.headers);
	  this.url = options.url || '';
	  this._initBody(bodyInit);
	}

	Body.call(Response.prototype);

	Response.prototype.clone = function() {
	  return new Response(this._bodyInit, {
	    status: this.status,
	    statusText: this.statusText,
	    headers: new Headers(this.headers),
	    url: this.url
	  })
	};

	Response.error = function() {
	  var response = new Response(null, {status: 0, statusText: ''});
	  response.type = 'error';
	  return response
	};

	var redirectStatuses = [301, 302, 303, 307, 308];

	Response.redirect = function(url, status) {
	  if (redirectStatuses.indexOf(status) === -1) {
	    throw new RangeError('Invalid status code')
	  }

	  return new Response(null, {status: status, headers: {location: url}})
	};

	var DOMException = global$1.DOMException;
	try {
	  new DOMException();
	} catch (err) {
	  DOMException = function(message, name) {
	    this.message = message;
	    this.name = name;
	    var error = Error(message);
	    this.stack = error.stack;
	  };
	  DOMException.prototype = Object.create(Error.prototype);
	  DOMException.prototype.constructor = DOMException;
	}

	function fetch$1(input, init) {
	  return new Promise(function(resolve, reject) {
	    var request = new Request(input, init);

	    if (request.signal && request.signal.aborted) {
	      return reject(new DOMException('Aborted', 'AbortError'))
	    }

	    var xhr = new XMLHttpRequest();

	    function abortXhr() {
	      xhr.abort();
	    }

	    xhr.onload = function() {
	      var options = {
	        status: xhr.status,
	        statusText: xhr.statusText,
	        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
	      };
	      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
	      var body = 'response' in xhr ? xhr.response : xhr.responseText;
	      setTimeout(function() {
	        resolve(new Response(body, options));
	      }, 0);
	    };

	    xhr.onerror = function() {
	      setTimeout(function() {
	        reject(new TypeError('Network request failed'));
	      }, 0);
	    };

	    xhr.ontimeout = function() {
	      setTimeout(function() {
	        reject(new TypeError('Network request failed'));
	      }, 0);
	    };

	    xhr.onabort = function() {
	      setTimeout(function() {
	        reject(new DOMException('Aborted', 'AbortError'));
	      }, 0);
	    };

	    function fixUrl(url) {
	      try {
	        return url === '' && global$1.location.href ? global$1.location.href : url
	      } catch (e) {
	        return url
	      }
	    }

	    xhr.open(request.method, fixUrl(request.url), true);

	    if (request.credentials === 'include') {
	      xhr.withCredentials = true;
	    } else if (request.credentials === 'omit') {
	      xhr.withCredentials = false;
	    }

	    if ('responseType' in xhr) {
	      if (support.blob) {
	        xhr.responseType = 'blob';
	      } else if (
	        support.arrayBuffer &&
	        request.headers.get('Content-Type') &&
	        request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1
	      ) {
	        xhr.responseType = 'arraybuffer';
	      }
	    }

	    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {
	      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
	        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
	      });
	    } else {
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value);
	      });
	    }

	    if (request.signal) {
	      request.signal.addEventListener('abort', abortXhr);

	      xhr.onreadystatechange = function() {
	        // DONE (success or failure)
	        if (xhr.readyState === 4) {
	          request.signal.removeEventListener('abort', abortXhr);
	        }
	      };
	    }

	    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
	  })
	}

	fetch$1.polyfill = true;

	if (!global$1.fetch) {
	  global$1.fetch = fetch$1;
	  global$1.Headers = Headers;
	  global$1.Request = Request;
	  global$1.Response = Response;
	}

	async function fetchServices({
	  method,
	  postData,
	  headers,
	  url,
	  isAuthNeeded
	}) {
	  const includeCredentials = isAuthNeeded ? {
	    credentials: 'include'
	  } : undefined;
	  const payload = { ...includeCredentials,
	    method,
	    headers,
	    body: stringify(postData)
	  };

	  try {
	    const result = await fetch(url, payload);

	    if (!result.ok) {
	      throw new Error(`fetchServices failed with url: ${url}`);
	    }

	    const response = await result.json();
	    return {
	      response,
	      success: true,
	      err: null
	    };
	  } catch (err) {
	    return {
	      response: null,
	      success: false,
	      err
	    };
	  }
	}

	async function buildPrevewsFromVDMS(idPath, imageConfig) {
	  const base = 'https://content.uplynk.com/player/assetinfo/ext/{id}.json';
	  const url = base.replace('{id}', idPath);
	  const result = await fetchServices({
	    url,
	    method: 'GET'
	  });

	  if (!result.success) {
	    return null;
	  }

	  const {
	    thumb_prefix: thumbBase,
	    duration
	  } = result.response;
	  const numPreviews = Math.floor(duration / imageConfig.secondPerChapter);
	  const previews = {};
	  let i = 0;

	  while (i <= numPreviews) {
	    let hex = `0000000${i.toString(16)}`.toLocaleUpperCase();
	    hex = slice(hex).call(hex, hex.length - 8);
	    previews[`${i * 10}`] = {
	      src: `${thumbBase}${hex}.${imageConfig.extension}`,
	      width: imageConfig.width
	    };
	    i += 1;
	  }

	  return previews;
	}

	const VIDEO_CDN_ASSET_PATH_REGEX = /motion\/(.+?)\./;
	const VDMS_ASSET_PATH_REGEX = /.\/ext\/(.+?)\.(m3u8|mpd).*/;
	const IMAGE_CONFIG = {
	  secondPerChapter: 10,
	  extension: 'jpg',
	  width: '150'
	};

	async function buildTimelinePreviewObject(videoURL, duration, brand) {
	  if (!videoURL) {
	    return null;
	  }

	  const pathMatch = videoURL.match(VIDEO_CDN_ASSET_PATH_REGEX) || videoURL.match(VDMS_ASSET_PATH_REGEX);

	  if (!pathMatch) {
	    return null;
	  }

	  const isESPN = brand === 'espn';
	  let previews = null;

	  if (isESPN) {
	    previews = buildPrevewsFromVideoCDN(pathMatch, duration, IMAGE_CONFIG);
	  } else {
	    previews = await buildPrevewsFromVDMS(pathMatch[1], IMAGE_CONFIG);
	  }

	  return previews;
	}

	function getAdobeCMBuilder(configOptions) {
	  const {
	    messages,
	    serviceUrl,
	    platform = 'web',
	    applicationId = '3bfbbbdf-be8e-40be-9540-97a73469ada2',
	    programmer = 'ESPN'
	  } = configOptions;
	  const metadata = {
	    [MetadataKeys.applicationId]: applicationId,
	    [MetadataKeys.applicationPlatform]: platform,
	    [MetadataKeys.deviceModel]: '',
	    [MetadataKeys.mobileDevice]: 'false',
	    [MetadataKeys.programmerName]: programmer
	  };
	  const builder = new AdobeConcurrencyMonitorBuilder(programmer, applicationId, metadata);

	  if (serviceUrl) {
	    builder.withServiceUrl(serviceUrl);
	  }

	  if (messages) {
	    builder.withMessages(messages);
	  }

	  return builder;
	}

	function initConcurrencyMonitor(session, concurrencyMonitorBuilder, coordinator) {
	  let monitor;

	  if (session.concurrencyMonitorSessionId) {
	    monitor = concurrencyMonitorBuilder.withSession(session).build();

	    if (monitor) {
	      monitor.startWithSession(session.concurrencyMonitorSessionId);
	    }
	  }

	  if (!monitor) {
	    return null;
	  }

	  monitor.onError = () => {
	    const {
	      subject
	    } = monitor;
	    coordinator.coordinate('dtci.concurrencyMonitor.limitReached', {
	      subject
	    });
	  };

	  return monitor;
	}

	function getAuthenticationType(mediaItem, tokenType) {
	  let authenticationType = null;

	  if (mediaItem.authenticationTypes.length === 1) {
	    authenticationType = mediaItem.authenticationTypes[0].toString();
	  } else if (mediaItem.authenticationTypes.length > 1) {
	    var _context, _context2;

	    if (indexOf(_context = mediaItem.authenticationTypes).call(_context, 'MVPD') !== -1 && tokenType === 'ADOBEPASS') {
	      authenticationType = MediaItemAuthenticationType$1.mvpd;
	    } else if (indexOf(_context2 = mediaItem.authenticationTypes).call(_context2, 'ISP') !== -1 && tokenType !== 'ADOBEPASS') {
	      authenticationType = MediaItemAuthenticationType$1.isp;
	    }
	  }

	  return authenticationType;
	}

	const PLAYER_TYPE = {
	  videoPlayer: 'videoPlayer',
	  ima3AdPlayer: 'ima3AdPlayer',
	  imaAdPlayer: 'imaAdPlayer'
	};
	const ERRORS = {
	  STREAM_LIMITED: 'STREAM_LIMITED',
	  MEDIA_ERR_CUSTOM: 'MEDIA_ERR_CUSTOM',
	  MEDIA_ERR_ABORTED: 'MEDIA_ERR_ABORTED',
	  MEDIA_ERR_NETWORK: 'MEDIA_ERR_NETWORK',
	  MEDIA_ERR_DECODE: 'MEDIA_ERR_DECODE',
	  MEDIA_ERR_SRC_NOT_SUPPORTED: 'MEDIA_ERR_SRC_NOT_SUPPORTED',
	  MEDIA_ERR_ENCRYPTED: 'MEDIA_ERR_ENCRYPTED'
	};
	const STREAM_LIMIT_ERROR_MSG = 'You’re already playing the maximum number of streams allowed.';

	const AKAMAI_REGEX = new RegExp(['espn.go.com', 'linearhlsls-i.akamaihd.net', 'linearhlsls2-i.akamaihd.net', 'espn3hlsint-i.akamaihd.net', 'espn-int-hls.akamaized.net', 'espn3hlsls.akamaized.net'].join('|'));

	class BasePlayerAdapter {
	  constructor(el, configs, coordinator) {
	    var _context, _context2;

	    this.player_ = undefined;
	    this.element_ = null;
	    this.adobeNielsen_ = null;
	    this.adobeMonitor_ = null;
	    this.fatalErrors = [ERRORS.STREAM_LIMITED, ERRORS.MEDIA_ERR_CUSTOM, ERRORS.MEDIA_ERR_ABORTED, ERRORS.MEDIA_ERR_NETWORK, ERRORS.MEDIA_ERR_DECODE, ERRORS.MEDIA_ERR_SRC_NOT_SUPPORTED, ERRORS.MEDIA_ERR_ENCRYPTED];
	    this.programChangeMonitor_ = null;
	    this.playlistId_ = null;
	    this.savedVolume = _parseFloat(localStorage.getItem(this.volumeStorageKey));
	    this.configs_ = {
	      authButler: {
	        partner: 'watchespn',
	        platform: 'web'
	      },
	      concurrencyMonitor: {
	        messages: null,
	        serviceUrl: null,
	        platform: 'web',
	        applicationId: '3bfbbbdf-be8e-40be-9540-97a73469ada2',
	        programmer: 'ESPN'
	      },
	      endcard: true,
	      loop: false,
	      seekStep: 10,
	      skipInitialFocus: true,
	      volume: {
	        namespace: 'dtci'
	      },
	      disableAdobe: true,
	      disableComscore: true,
	      disableChartbeat: true,
	      disableNielsen: true
	    };
	    this.isPlaying = false;
	    this.analytics_ = null;
	    this.drmSupport_ = null;
	    this.dmedConviva_ = null;
	    this.isEntertainment = false;
	    let element = el;

	    if (typeof element === 'string') {
	      if (indexOf(element).call(element, '#') === 0) {
	        element = slice(element).call(element, 1);
	      }

	      element = document.getElementById(element);
	    }

	    if (!element || !element.nodeName) {
	      throw new TypeError('The element or ID supplied is not valid.');
	    }

	    this.configs_ = this.mergeConfigs_(configs);
	    this.onSpaceBarKeydown = bind(_context = this.onSpaceBarKeydown).call(_context, this);
	    this.handlePlayerError = bind(_context2 = this.handlePlayerError).call(_context2, this);
	    const {
	      configs_: {
	        advertisingInfo,
	        authorizationPayload
	      } = {}
	    } = this;
	    this.createEl_(element);
	    this.coordinator = coordinator || new EventCoordinator();
	    this.advertisingInfo = advertisingInfo || new AdvertisingInfo();
	    this.authorizationPayload = authorizationPayload || new AuthorizationPayload(MediaItemAuthenticationType$1.none, null, null, null);
	    this.prepareForPlayer_();
	    this.createPlayer_();
	    this.configurePlayer_();
	    this.initContent_();
	  }

	  set player(value) {
	    this.player_ = value;
	  }

	  get player() {
	    return this.player_;
	  }

	  set analytics(value) {
	    this.analytics_ = value;
	  }

	  get analytics() {
	    return this.analytics_;
	  }

	  set dmedConviva(value) {
	    this.dmedConviva_ = value;
	  }

	  get dmedConviva() {
	    return this.dmedConviva_;
	  }

	  get isInAdMode() {
	    const {
	      ads
	    } = this.player || {};
	    return ads && typeof ads.isInAdMode === 'function' && ads.isInAdMode();
	  }

	  get adId() {
	    const {
	      player
	    } = this;
	    let id;

	    if (player.ads && player.ads.ad) {
	      id = player.ads.ad.id;
	    } else if (player.ima && typeof player.ima.getAdsManager === 'function') {
	      const currentAd = player.ima.getAdsManager().getCurrentAd();
	      id = currentAd && currentAd.getAdId();
	    }

	    return id || '';
	  }

	  get mediaItem() {
	    return this.player && this.player.mediaItem || null;
	  }

	  updateConfiguration(configs) {
	    this.configs_ = this.mergeConfigs_(configs);
	    const {
	      configs_: {
	        advertisingInfo,
	        authorizationPayload
	      } = {}
	    } = this;
	    this.advertisingInfo = advertisingInfo || new AdvertisingInfo();
	    this.authorizationPayload = authorizationPayload || new AuthorizationPayload(MediaItemAuthenticationType$1.none, null, null, null);
	    this.configurePlayer_();
	    this.initContent_();
	  }

	  updateAnalytics(configs) {
	    const {
	      chartbeat,
	      comscore,
	      conviva,
	      adobeDCR
	    } = configs;
	    const {
	      analytics
	    } = this;

	    if (chartbeat) {
	      analytics.chartbeat(chartbeat);
	    }

	    if (comscore) {
	      analytics.comscore(comscore);
	    }

	    if (conviva) {
	      analytics.conviva(conviva);
	    }

	    if (adobeDCR) {
	      analytics.adobeDCR(adobeDCR);
	    }

	    return analytics;
	  }

	  mergeConfigs_(configs = {}) {
	    this.configs_.seekStep = configs.isAudio ? 15 : 10;
	    const mergedConfigs = { ...this.configs_,
	      ...configs
	    };

	    if (configs.concurrencyMonitor) {
	      mergedConfigs.concurrencyMonitor = { ...this.configs_.concurrencyMonitor,
	        ...configs.concurrencyMonitor
	      };
	    }

	    if (configs.volume) {
	      mergedConfigs.volume = { ...this.configs_.volume,
	        ...configs.volume
	      };
	    }

	    mergedConfigs.volume = this.updateVolumeConfig_(mergedConfigs.volume);
	    return mergedConfigs;
	  }

	  updateVolumeConfig_(volumeConfg) {
	    const {
	      namespace = 'dtci',
	      value,
	      muted
	    } = volumeConfg;
	    const volumeStorageKey = `${namespace}-volume`;

	    const volumeFromlocalStorage = _parseFloat(localStorage.getItem(volumeStorageKey));

	    const muteStorageKey = `${namespace}-mute`;
	    const mutedFromlocalStorage = localStorage.getItem(muteStorageKey) === 'true'; // get the volume setting from client config, then localStorage, lastly setting default

	    const volumeVal = value || volumeFromlocalStorage || 1;
	    const volumeMuted = muted !== undefined ? muted : mutedFromlocalStorage || false;
	    volumeConfg.value = volumeVal;
	    volumeConfg.muted = volumeMuted;
	    return volumeConfg;
	  }

	  createEl_(element) {
	    const {
	      configs_: {
	        isAudio,
	        brand = 'espn',
	        theme,
	        language = 'en',
	        iphoneplaysinline,
	        enableDRM
	      } = {}
	    } = this;
	    const elementType = isAudio ? 'audio' : 'video';
	    const mode = theme ? ` ${theme}` : '';
	    const brandedClassNames = isAudio ? `branded audio ${brand}-audio${mode}` : `video ${brand}-video${mode}`;
	    const drmClassName = enableDRM ? 'enabled-drm' : '';
	    this.element_ = element.tagName.toLowerCase() === elementType ? element : document.createElement(elementType);
	    this.element_.controls = true;
	    this.element_.preload = 'metadata';
	    this.element_.className = `evp-player video-js ${brandedClassNames} ${drmClassName}`; // Allow skippable ads to play inline on iPhone
	    // https://support.brightcove.com/advertising-ima3-plugin?bp#skippable-ads

	    if (iphoneplaysinline && IS_IOS && IS_IPHONE) {
	      this.element_.setAttribute('playsinline', true);
	    }

	    this.element_.setAttribute('lang', language); // Add the element to the DOM

	    if (element.tagName.toLowerCase() !== elementType && element.parentNode) {
	      // Reset DOM before inserting new content
	      element.parentNode.replaceChild(this.element_, element);
	    }
	  }

	  prepareForPlayer_() {
	    const {
	      configs_: {
	        wasUserInitiated,
	        autoplay = false
	      } = {}
	    } = this;

	    if (wasUserInitiated !== undefined) {
	      this.startType = wasUserInitiated === false ? 'autostart' : 'manual';
	    } else {
	      this.startType = autoplay === 'on' || autoplay === true ? 'autostart' : 'manual';
	    } // If playback was initiated by the user, force the player to unmute.


	    if (wasUserInitiated) {
	      this.configs_.volume.muted = false;
	    }

	    this.configureAnalytics_();
	  }

	  configureAnalytics_() {
	    const {
	      configs_: {
	        analytics,
	        disableAdobe,
	        disableNielsen
	      } = {}
	    } = this;
	    const adobeTrackingEnabled = !disableAdobe && !disableNielsen;
	    this.analytics_ = new Analytics();

	    if (analytics) {
	      this.analytics_.config = analytics;
	    }

	    if (adobeTrackingEnabled) {
	      this.analytics_.adobeDCR({
	        ESPN_CUSTOM_METADATA: {
	          startType: this.startType
	        }
	      });
	    }
	  }

	  createPlayer_() {
	    try {
	      if (typeof this.tech !== 'function') {
	        throw new Error('BasePlayerAdapter: `tech()` MUST be a valid constructor');
	      }

	      this.player = this.tech(this.element_);
	    } catch (err) {
	      console.error(err);
	    }
	  }

	  tech() {
	    // tech is a placeholder here. It will get overloaded in the child class
	    return null;
	  }

	  configurePlayer_() {
	    const {
	      configs_: {
	        autoplay
	      } = {}
	    } = this;

	    if (autoplay != null) {
	      this.autoplay(autoplay);
	    }

	    if (document.hidden) {
	      this.autoplay(false);
	    }
	  }

	  initContent_() {
	    const {
	      error,
	      disableConviva,
	      adOnly,
	      mediaItem
	    } = this.configs_;

	    if (error) {
	      const isRequiredConvivaInit = this.player && !this.dmedConviva && !disableConviva;

	      if (isRequiredConvivaInit) {
	        this.initConviva(mediaItem);
	      }

	      return this.error(error);
	    }

	    if (adOnly) {
	      return this.adOnly();
	    }

	    return this.getMediaItemForPlayback_();
	  }

	  initConviva(mediaItem) {
	    const {
	      player,
	      platformVersion,
	      configs_: {
	        brand,
	        type
	      } = {}
	    } = this;

	    if (typeof player.conviva === 'function') {
	      this.dmedConviva = player.conviva(this.analytics.conviva({
	        brand,
	        platformVersion,
	        type,
	        // audio or video and it is a getter from techOptions.type
	        startType: this.startType,
	        playbackMediaItem: mediaItem
	      }));
	    }
	  }

	  initSocial(mediainfo, socialConfig) {
	    if (socialConfig !== false) {
	      const brand = this.configs_.brand || mediainfo.brand || 'espn';
	      const brandName = this.mapBrandNames(brand);
	      this.socialConfig = new Social(mediainfo, socialConfig, brandName);
	      this.social(this.socialConfig.options);
	    }
	  }

	  mapBrandNames(brand) {
	    return getBrandNames(brand) || 'Entertainment';
	  }

	  async adOnly() {
	    try {
	      const {
	        player
	      } = this;
	      this.autoplay(true);

	      if (player.preload) {
	        player.preload('metadata');
	      }

	      this.startType = 'autostart';
	      this.analytics.adobeDCR({
	        ESPN_CUSTOM_METADATA: {
	          startType: this.startType
	        }
	      });
	      const adProvider = await this.initAdProvider_({});

	      if (adProvider) {
	        this.advertisingInfo = getAdvertisingInfo(this.advertisingInfo, player, {}, this);
	        adProvider.initAds(this.advertisingInfo);
	        this.src({
	          src: 'data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAA79tZGF0AAAC9AYF///w3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9MTIgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3ZWlnaHRwPTEga2V5aW50PTI0MCBrZXlpbnRfbWluPTI0IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9MTAgcmM9Y3JmIG1idHJlZT0xIGNyZj01MS4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCB2YnZfbWF4cmF0ZT0yMDAwMCB2YnZfYnVmc2l6ZT0yNTAwMCBjcmZfbWF4PTAuMCBuYWxfaHJkPW5vbmUgZmlsbGVyPTAgaXBfcmF0aW89MS40MCBhcT0xOjEuMDAAgAAAADFliIQAbwTYb+YMExstjI/2DFAAAAMAAA94QCcYYsAAASkAtD1oHHXQk/QgAAADAHxBAAAACUGaJBiL/wAA/wAAAAhBnkJCfwAB6QAAAAgBnmFF/wAB8wAAAAgBnmNF/wAB8wAAAApBmmg0TET/AAEPAAAACkGehkURLP8AAekAAAAIAZ6lRf8AAfMAAAAIAZ6nRf8AAfMAAAAJQZqrNExfAAFTAAAACEGeykJfAAHpAAAACAGe6UX/AAHzAAADym1vb3YAAABsbXZoZAAAAADTQ/Pq00Pz6gAAA+gAAAHLAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAL1dHJhawAAAFx0a2hkAAAAD9ND8+rTQ/PqAAAAAQAAAAAAAAHLAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAGsAAAA8AAAAAAAJGVkdHMAAAAcZWxzdAAAAAAAAAABAAABywAAHVQAAQAAAAACbW1kaWEAAAAgbWRoZAAAAADTQ/Pq00Pz6gABX5AAAKFMVcQAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAAAhhtaW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAHYc3RibAAAAJhzdHNkAAAAAAAAAAEAAACIYXZjMQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAGsAPAASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAADJhdmNDAU1AKP/hABpnTUAo7KDY/3zUBAQFAAADAAEAAr8gDxgxlgEABWjvgZcgAAAAQHN0dHMAAAAAAAAABgAAAAUAAA6qAAAAAQAADqkAAAADAAAOqgAAAAEAAA6pAAAAAQAADqoAAAABAAAAAAAAABRzdHNzAAAAAAAAAAEAAAABAAAAcGN0dHMAAAAAAAAADAAAAAEAAB1UAAAAAQAASVEAAAABAAAdVAAAAAEAAAAAAAAAAQAADqoAAAABAABJUAAAAAEAAB1UAAAAAQAAAAAAAAABAAAOqgAAAAEAADqnAAAAAQAAHVQAAAABAAAAAAAAABxzdHNjAAAAAAAAAAEAAAABAAAADAAAAAEAAABEc3RzegAAAAAAAAAAAAAADAAAAy0AAAANAAAADAAAAAwAAAAMAAAADgAAAA4AAAAMAAAADAAAAA0AAAAMAAAADAAAABRzdGNvAAAAAAAAAAEAAAAwAAAAYXVkdGEAAABZbWV0YQAAAAAAAAAhaGRscgAAAAAAAAAAbWRpcmFwcGwAAAAAAAAAAAAAAAAsaWxzdAAAACSpdG9vAAAAHGRhdGEAAAABAAAAAExhdmY1NC42LjEwMA==',
	          type: 'video/mp4'
	        });
	      }
	    } catch (err) {
	      console.error(`init adOnly failed: ${err}`);
	    }
	  }

	  async getMediaItemForPlayback_() {
	    const {
	      identifier,
	      mediaItem,
	      disableConviva,
	      api: {
	        contentApi
	      } = {}
	    } = this.configs_;
	    let mediaItem_ = mediaItem;

	    try {
	      if (!mediaItem_ && identifier) {
	        mediaItem_ = await fetchMediaItemFromApi({
	          identifier,
	          contentApi
	        });
	      }

	      if (mediaItem_) {
	        this.coordinator.coordinate('dtci.loaded', mediaItem_);

	        if (mediaItem_.type === 'audio') {
	          if (mediaItem_.entityType === 'longform') {
	            this.player_.controlBar.seekToLive.el_.removeAttribute('title');
	            this.player_.controlBar.seekToLive.show();
	          } else {
	            this.player_.controlBar.seekToLive.hide();
	          }
	        }

	        if (mediaItem_.source.type === 'entitlement') {
	          this.isEntertainment = true;
	        }

	        const isRequiredConvivaInit = this.player && !this.dmedConviva && !disableConviva;

	        if (isRequiredConvivaInit) {
	          this.initConviva(mediaItem_);
	        }

	        this.handlePlayButtonOnLiveStream(mediaItem_.streamType);

	        if (mediaItem_.entityType === 'shortform' && mediaItem_.streamType !== 'live') {
	          return this.clipLoadedCallback(mediaItem_);
	        }

	        return this.initPlaybackSession(mediaItem_);
	      }

	      throw new Error('mediaItem is null');
	    } catch (err) {
	      const {
	        player
	      } = this;

	      if (player && typeof player.error === 'function') {
	        player.error('getMediaItemForPlayback failed: ', err);
	      }
	    }

	    return null;
	  }

	  async clipLoadedCallback(mediaItem) {
	    const {
	      player
	    } = this;

	    try {
	      const authenticationManager = this.getAuthenticationManager(mediaItem);
	      const playbackSession = await this.getPlaybackSession(mediaItem, authenticationManager);

	      if (playbackSession) {
	        const {
	          cues,
	          tvrating,
	          duration,
	          images: [{
	            url: posterHref
	          }]
	        } = mediaItem;
	        const adProvider = await this.initAdProvider_(mediaItem);

	        if (adProvider) {
	          adProvider.initAds(this.advertisingInfo);
	          const {
	            configs_
	          } = this;

	          if (typeof this.mediainfo === 'function') {
	            this.mediainfo(mediaItem);
	          }

	          if (posterHref && !this.autoplay()) {
	            this.poster(posterHref);
	          } else {
	            // black poster image
	            this.poster('data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=');
	          }

	          this.initEndcardOrLoop(configs_, mediaItem);
	          this.initTVRatingIfMediaItemTvRatingIsSet(player, tvrating);
	          this.initMidrollAdPodsIndicator(cues, duration);

	          if (typeof player.social === 'function' || typeof player.brandedSocial === 'function') {
	            this.initSocial(player.mediainfo, configs_.social);
	          }

	          this.updateConvivaCustomMetadata_({
	            playbackMediaItem: playbackSession.mediaItem || mediaItem,
	            drmProtectionType: 'none',
	            streamProtocol: 'HLS'
	          });

	          if (this.isEntertainment) {
	            const source = await drmSourceBuilder(playbackSession);
	            this.src(source);
	          } else {
	            this.src(playbackSession.playbackUrl);
	          }

	          this.initThumbnails(mediaItem, playbackSession);
	          this.initAnalytics();
	        }
	      }
	    } catch (err) {
	      console.error(`clipLoadedCallback failed ${err}`);

	      if (player && typeof player.error === 'function') {
	        player.error(err);
	      }
	    }
	  }

	  initEndcardOrLoop(configs_, mediaItem) {
	    if (mediaItem.streamType === 'live') {
	      return;
	    }

	    if (configs_.loop && typeof this.loop === 'function') {
	      this.loop();
	    } else if (configs_.endcard && typeof this.endcard === 'function') {
	      var _context3;

	      const endcard = bind(_context3 = this.endcard).call(_context3, this);

	      endcard(mediaItem, configs_.endcard);
	    }
	  }

	  shouldInitThumbnails(mediaItem) {
	    const {
	      entityType,
	      streamType,
	      source
	    } = mediaItem;
	    return streamType !== 'live' && (entityType === 'shortform' || entityType === 'longform' && source.type === 'entitlement');
	  }

	  async initThumbnails(mediaItem, playbackSession) {
	    if (!this.shouldInitThumbnails(mediaItem)) return;
	    const {
	      player,
	      configs_ = {}
	    } = this;
	    const {
	      duration,
	      source: {
	        url: srcUrl
	      },
	      type,
	      brand
	    } = mediaItem;

	    if (typeof this.thumbnails === 'function' && configs_.disableTimelinePreview !== true) {
	      if (type === 'audio' && typeof player.timeDisplay === 'function') {
	        player.timeDisplay();
	      } else {
	        const source = brand === 'espn' ? srcUrl : playbackSession.playbackUrl;
	        const previews = await buildTimelinePreviewObject(source, duration, brand);

	        if (previews) {
	          this.thumbnails(previews);
	        }
	      }
	    }
	  }

	  async initPlaybackSession(mediaItem) {
	    const {
	      player
	    } = this;

	    try {
	      const authenticationManager = this.getAuthenticationManager(mediaItem);
	      const playbackSession = await this.getPlaybackSession(mediaItem, authenticationManager);

	      if (playbackSession) {
	        const {
	          tvrating,
	          cues,
	          duration,
	          type
	        } = mediaItem;

	        if (authenticationManager.concurrencyMonitorBuilder) {
	          this.adobeMonitor_ = initConcurrencyMonitor(playbackSession, authenticationManager.concurrencyMonitorBuilder, this.coordinator);
	        }

	        this.initTVRatingIfMediaItemTvRatingIsSet(player, tvrating);
	        this.initMidrollAdPodsIndicator(cues, duration);
	        this.initEndcardOrLoop(this.configs_, mediaItem);
	        this.initProgramChangeMonitor(mediaItem);
	        await this.watchLoadedCallback(mediaItem, playbackSession);

	        if (type === 'audio') {
	          if (typeof player.timeDisplay === 'function') {
	            player.timeDisplay();
	          }
	        }
	      } // Remove item for local.espn.com (This will not impact other environments)


	      localStorage.removeItem('endcardNextItem');
	    } catch (err) {
	      if (player && typeof player.error === 'function') {
	        if ((err === null || err === void 0 ? void 0 : err.message) === STREAM_LIMIT_ERROR_MSG) {
	          this.coordinator.coordinate('dtci.concurrencyMonitor.limitReached');
	        } else {
	          player.error(`initPlaybackSession failed ${err}`);
	        }
	      }

	      this.cleanUp();
	      console.error(`initPlaybackSession failed ${err}`);
	    }
	  }

	  async getPlaybackSession(mediaItem, authenticationManager) {
	    const {
	      player
	    } = this;
	    this.advertisingInfo = getAdvertisingInfo(this.advertisingInfo, player, mediaItem, this);
	    await this.coordinator.coordinate('dtci.adProvider.getAdvertisingInfo', this.advertisingInfo);
	    return authenticationManager.initPlaybackSession(mediaItem, this.advertisingInfo);
	  }

	  getAuthenticationManager(mediaItem) {
	    const {
	      api: {
	        shieldApiKey,
	        palEnabled = true
	      } = {},
	      authButler: {
	        partner = 'watchespn',
	        platform = 'web'
	      } = {},
	      concurrencyMonitor,
	      enableDRM,
	      entitlement,
	      brandConfig = {}
	    } = this.configs_ || {};
	    const {
	      enabledDrmSupportValues
	    } = brandConfig;
	    const shieldAPI = new ShieldAPI(shieldApiKey);
	    shieldAPI.drmSupport = enableDRM ? getDRMSupport(drmSupportParam(), enabledDrmSupportValues) : 'HLS';
	    shieldAPI.palEnabled = palEnabled;
	    this.drmSupport_ = shieldAPI.drmSupport;
	    const authButler = new ESPNAuthButler(partner, platform);
	    const {
	      authenticationType,
	      customData: {
	        tokenType
	      } = {}
	    } = this.authorizationPayload || {};

	    if (!authenticationType) {
	      this.authorizationPayload.authenticationType = getAuthenticationType(mediaItem, tokenType);
	    }

	    const payloadAuthenticator = new PayloadAuthenticator();
	    payloadAuthenticator.authorizationPayload = this.authorizationPayload;
	    payloadAuthenticator.mediaItem = mediaItem;
	    const allAuthenticationTypes = [MediaItemAuthenticationType$1.mvpd, MediaItemAuthenticationType$1.isp, MediaItemAuthenticationType$1.open, MediaItemAuthenticationType$1.none];
	    const shieldFactory = new ShieldPlaybackSessionFactory(shieldAPI);
	    const startSessionFactory = new StartSessionPlaybackSessionFactory(authButler);
	    const clipFactory = new ClipPlaybackSessionFactory();
	    const {
	      serviceUrl,
	      appVersion,
	      appName,
	      deviceID = entitlement.device
	    } = entitlement || defaultConfiguration;
	    const entitlementConfiguration = new Configuration(serviceUrl, appVersion, appName, deviceID);
	    const entitlementSessionFactory = new EntitlementPlaybackSessionFactory(entitlementConfiguration);
	    const authenticationManager = new AuthenticationManager();
	    authenticationManager.setAuthenticator(payloadAuthenticator, allAuthenticationTypes);
	    authenticationManager.setAuthorizer(payloadAuthenticator, allAuthenticationTypes);
	    authenticationManager.setPlaybackSessionFactory(shieldFactory, MediaItemSourceType$1.shield);
	    authenticationManager.setPlaybackSessionFactory(startSessionFactory, MediaItemSourceType$1.startSession);
	    authenticationManager.setPlaybackSessionFactory(clipFactory, MediaItemSourceType$1.none);
	    authenticationManager.setPlaybackSessionFactory(entitlementSessionFactory, MediaItemSourceType$1.entitlement);
	    authenticationManager.concurrencyMonitorBuilder = getAdobeCMBuilder(concurrencyMonitor);
	    return authenticationManager;
	  }

	  initProgramChangeMonitor(mediaItem) {
	    const mediaItemDataSource = this.getMediaItemDataSource(mediaItem);
	    const programChangeMonitor = new ProgramChangeMonitor(mediaItem, mediaItemDataSource);

	    programChangeMonitor.onProgramChange = mediaItem => {
	      if (this.adobeMonitor_) {
	        this.adobeMonitor_.stop();
	      }

	      if (this.programChangeMonitor_) {
	        this.programChangeMonitor_.stop();
	      }

	      this.initPlaybackSession(mediaItem);
	      this.coordinator.coordinate('dtci.programChange', mediaItem);
	    };

	    this.programChangeMonitor_ = programChangeMonitor;
	    this.programChangeMonitor_.start();
	  }

	  getMediaItemDataSource(mediaItem) {
	    switch (mediaItem.apiSource) {
	      case ApiSource$1.graphQL:
	        return new UniversalMediaItemAPI();

	      case ApiSource$1.pluto:
	        return new PlutoAPI();

	      case ApiSource$1.cfa:
	        return new UniversalMediaItemAPI();
	    }

	    return null;
	  }

	  handlePlayButtonOnLiveStream(streamType) {
	    const {
	      configs_,
	      player
	    } = this;

	    if (configs_) {
	      const {
	        brandConfig: {
	          disablePlayButtonOnLiveStream
	        } = {}
	      } = configs_;
	      const noPlayButtonOnLiveStream = streamType === 'live' && disablePlayButtonOnLiveStream;

	      if (noPlayButtonOnLiveStream) {
	        player.addClass('hide-play-button');
	      } else {
	        // toggle play and pause video when users press on spacebar
	        this.isKeydownEventEnabled = true;
	        document.addEventListener('keydown', this.onSpaceBarKeydown);
	      }
	    }
	  }

	  onSpaceBarKeydown(event) {
	    const {
	      keyCode,
	      target
	    } = event || {};
	    const {
	      player
	    } = this;
	    const {
	      configs_: {
	        disableSpacebarPlayToggle
	      } = {}
	    } = this;
	    const spaceBar = 32;
	    const playerElm = player && player.el();
	    const targetIsBodyOrPlayer = target === document.body || target === playerElm;
	    const keyCodeIsSpaceBar = keyCode === spaceBar;

	    if (disableSpacebarPlayToggle || !event || !targetIsBodyOrPlayer || !keyCodeIsSpaceBar) {
	      return;
	    } // Prevent scrolling the page, DTCIMMP-1174


	    event.preventDefault();

	    if (this.isPlaying) {
	      this.pause();
	    } else {
	      this.play();
	    }
	  }

	  async watchLoadedCallback(mediaItem, playbackSession) {
	    let player;

	    try {
	      player = this.player;
	      const {
	        configs_
	      } = this;
	      const {
	        images: [{
	          url: posterHref
	        }],
	        seekInSeconds
	      } = mediaItem;
	      const adProvider = await this.initAdProvider_(mediaItem);

	      if (adProvider) {
	        const source = await drmSourceBuilder(playbackSession);

	        if (typeof this.mediaInfoForEntertainment === 'function' && mediaItem.apiSource === 'pluto') {
	          this.mediaInfoForEntertainment(mediaItem);
	        } else if (typeof this.mediainfo === 'function') {
	          this.mediainfo(mediaItem);
	        }

	        this.poster(posterHref);

	        if (typeof player.social === 'function' || typeof player.brandedSocial === 'function') {
	          // eslint-disable-next-line no-new
	          this.initSocial(player.mediainfo, configs_.social);
	        }

	        this.advertisingInfo = getAdvertisingInfo(this.advertisingInfo, this.player, mediaItem, this);
	        adProvider.initAds(this.advertisingInfo);
	        const {
	          playbackConfig,
	          mediaItem: playbackMediaItem
	        } = playbackSession || {};
	        const keySystem = playbackConfig && playbackConfig.keySystem || 'none';
	        this.initTVRatingIfMediaItemTvRatingIsSet(player, mediaItem.tvrating);
	        this.updateConvivaCustomMetadata_({
	          playbackMediaItem,
	          drmProtectionType: keySystem,
	          streamProtocol: this.drmSupport_
	        });
	        this.src(source);

	        if (seekInSeconds) {
	          player.currentTime(seekInSeconds);
	        }

	        this.initThumbnails(mediaItem, playbackSession);
	        this.initAnalytics(mediaItem.tracking);
	      }
	    } catch (err) {
	      console.error('watchLoadedCallback error: ', err);

	      if (player && player.error) {
	        player.error(err);
	      }
	    }
	  }

	  initTVRatingIfMediaItemTvRatingIsSet(player, tvrating) {
	    if (player && typeof player.tvRating === 'function' && tvrating && tvrating !== 'NR') {
	      player.tvRating({
	        tvRating: tvrating
	      });
	    }
	  }

	  initMidrollAdPodsIndicator(midrollPodCues, duration) {
	    if (this.isMidrollAdPodsIndicatorEnabled(midrollPodCues)) {
	      this.player.midrollPods({
	        midrollPodCues,
	        duration
	      });
	    }
	  }

	  isMidrollAdPodsIndicatorEnabled(midrollPodCues) {
	    const {
	      player,
	      configs_: {
	        brandConfig: {
	          enableMidrollPods = false
	        } = {}
	      }
	    } = this;

	    if (midrollPodCues && enableMidrollPods && typeof player.midrollPods === 'function') {
	      return true;
	    }

	    return false;
	  }

	  updateConvivaCustomMetadata_(streamInfo) {
	    try {
	      if (this.dmedConviva) {
	        const {
	          authenticatedProvider: {
	            id
	          } = {}
	        } = this.authorizationPayload || {};
	        const startType = this.startType || streamInfo.startType;
	        const {
	          isConvivaC3DMEDAccount
	        } = this.analytics;

	        if (isConvivaC3DMEDAccount) {
	          this.dmedConviva.options = { ...this.dmedConviva.options,
	            ...streamInfo,
	            startType,
	            affiliate: id
	          };
	        } else {
	          /**
	           * Follow code updates option for the old Conviva plugin (dtci-conviva) for clients who will be on the old Conviva SDK.
	           * After v3.2.63, the old Conviva plugin dtci-conviva has been removed in the repo. In Brightcove studio,
	           * we will need to include dtci-conviva v3.2.63 or earlier version. Using the old Conviva plugin will be temporary.
	           * All clients should be on the new Conviva plugin (demed-conviva) after Covnva is done validation
	           */
	          this.dmedConviva.options = { ...this.dmedConviva.options,
	            tags: {
	              startType,
	              drmProtectionType: streamInfo.drmProtectionType,
	              streamProtocol: streamInfo.streamProtocol,
	              reloadCause: 'null'
	            }
	          };
	        }

	        return this.dmedConviva.options;
	      }
	    } catch (err) {
	      console.error('updateConvivaCustomMetadata_ error: ', err);
	    }

	    return null;
	  }

	  cleanUp() {
	    if (this.adobeMonitor_) {
	      this.adobeMonitor_.stop();
	      this.adobeMonitor_ = null;
	    }

	    if (this.programChangeMonitor_) {
	      this.programChangeMonitor_.stop();
	      this.programChangeMonitor_ = null;
	    }
	  }
	  /*
	    Set the `mediainfo` prop for Entertainment Live Content.
	  */


	  mediaInfoForEntertainment(mediaItem) {
	    const {
	      player,
	      configs_: {
	        affiliate
	      } = {}
	    } = this;

	    if (mediaItem) {
	      const {
	        description,
	        duration,
	        id,
	        isSyndicatable,
	        network,
	        references: {
	          cerebroId,
	          eventId,
	          simulcastAiringId
	        } = {},
	        source: {
	          commercialReplacement
	        } = {},
	        streamType,
	        title,
	        tvrating,
	        tracking: {
	          comscore: {
	            c6: comscoreC6,
	            ns_st_ct: comscoreContentType,
	            ns_st_pu: publisher
	          } = {},
	          heartbeats: {
	            CMSID: assetName,
	            League: leagueName,
	            PublishDate,
	            PublishTime,
	            ShowCode: showcode = 'Not Applicable',
	            Sport: sportName,
	            VideoTypeDetail: mediaType
	          } = {},
	          nielsen: {
	            program,
	            crossId1: nielsenCrossId1,
	            crossId2: nielsenCrossId2
	          } = {}
	        } = {},
	        webHref
	      } = mediaItem;
	      const live = streamType === 'live';
	      const originalPublishDate = PublishDate && PublishTime ? `${PublishDate}T${PublishTime}` : null;
	      const data = {
	        affiliate,
	        cerebroId,
	        commercialReplacement,
	        comscoreC6,
	        comscoreContentType,
	        custom_fields: {},
	        description,
	        duration,
	        eventId,
	        headline: title,
	        tvrating,
	        id,
	        leagueName,
	        live,
	        name: assetName || mediaItem.name,
	        program,
	        nielsenCrossId1,
	        nielsenCrossId2,
	        originalPublishDate,
	        pageTitle: document.title || title,
	        publisher,
	        showcode,
	        simulcastAiringId,
	        sourceId: network && network.id,
	        sourceType: network && network.type,
	        sportName,
	        startType: this.startType,
	        status: streamType,
	        syndicatable: isSyndicatable,
	        webHref
	      };

	      if (mediaType) {
	        data.custom_fields.mediaType = mediaType;
	      }

	      player.mediainfo = data;
	      /**
	       Short-term: exposing mediaItem publicly for DTCIMMP-1417.
	       Longer-term: we need to convert mediainfo into MediaItem instance;
	       Some plugins need to be tweaked because they look for specific data on mediainfo
	       */

	      player.mediaItem = this.getTrackMediaItem_(mediaItem, data);
	    }

	    return player.mediainfo;
	  }
	  /*
	    Set the `mediainfo` prop on the player with mediaItem data.
	  */


	  mediainfo(mediaItem) {
	    const {
	      player,
	      configs_: {
	        affiliate
	      } = {}
	    } = this;

	    if (mediaItem) {
	      const {
	        description,
	        duration,
	        id,
	        images: [{
	          url: posterHref
	        }],
	        isSyndicatable,
	        network,
	        tvrating,
	        references: {
	          cerebroId,
	          eventId,
	          simulcastAiringId
	        } = {},
	        source: {
	          commercialReplacement,
	          hasEspnId3Heartbeats,
	          hasNielsenWatermarks,
	          hasPassThroughAds
	        } = {},
	        streamType,
	        title,
	        tracking: {
	          comscore: {
	            c6: comscoreC6,
	            ns_st_ct: comscoreContentType,
	            ns_st_pu: publisher
	          } = {},
	          heartbeats: {
	            CMSID: assetName,
	            League: leagueName,
	            PublishDate,
	            PublishTime,
	            ShowCode: showcode = 'Not Applicable',
	            Sport: sportName,
	            VideoTypeDetail: mediaType,
	            'a.media.asset': asset,
	            'a.media.show': show,
	            'a.media.genre': genre
	          } = {},
	          nielsen: {
	            program,
	            crossId1: nielsenCrossId1,
	            crossId2: nielsenCrossId2
	          } = {}
	        } = {},
	        webHref
	      } = mediaItem;
	      const live = streamType === 'live';
	      const originalPublishDate = PublishDate && PublishTime ? `${PublishDate}T${PublishTime}` : null;
	      const data = {
	        affiliate,
	        cerebroId,
	        commercialReplacement,
	        comscoreC6,
	        comscoreContentType,
	        custom_fields: {},
	        description,
	        duration,
	        eventId,
	        hasEspnId3Heartbeats,
	        hasNielsenWatermarks,
	        hasPassThroughAds,
	        headline: title,
	        id,
	        leagueName,
	        live,
	        name: assetName || mediaItem.name,
	        program,
	        nielsenCrossId1,
	        nielsenCrossId2,
	        originalPublishDate,
	        tvrating,
	        pageTitle: document.title || title,
	        posterHref,
	        publisher,
	        showcode,
	        simulcastAiringId,
	        sourceId: network && network.id,
	        sourceType: network && network.type,
	        sportName,
	        startType: this.startType,
	        status: streamType,
	        syndicatable: isSyndicatable,
	        webHref,
	        asset,
	        show,
	        genre
	      };

	      if (mediaType) {
	        data.custom_fields.mediaType = mediaType;
	      }

	      player.mediainfo = data;
	      /**
	       Short-term: exposing mediaItem publicly for DTCIMMP-1417.
	       Longer-term: we need to convert mediainfo into MediaItem instance;
	       Some plugins need to be tweaked because they look for specific data on mediainfo
	       */

	      player.mediaItem = this.getTrackMediaItem_(mediaItem, data);
	    }

	    return player.mediainfo;
	  }

	  getTrackMediaItem_(mediaItem, mediainfoData = {}) {
	    const {
	      name,
	      headline,
	      status,
	      live,
	      program,
	      publisher,
	      showcode,
	      simulcastAiringId,
	      leagueName,
	      sportName,
	      startType,
	      originalPublishDate,
	      custom_fields: mediaType
	    } = mediainfoData;
	    return { ...mediaItem,
	      name,
	      headline,
	      status,
	      live,
	      program,
	      publisher,
	      showcode,
	      simulcastAiringId,
	      leagueName,
	      sportName,
	      startType,
	      originalPublishDate,
	      mediaType,
	      adIdSource: 'GAM',
	      playlistId: this.playlistId_
	    };
	  }

	  async initAdProvider_(mediaItem) {
	    try {
	      const {
	        player,
	        configs_,
	        coordinator
	      } = this;
	      const adProvider = await new AdProvider(player, mediaItem, configs_.adProvider, coordinator);
	      return adProvider;
	    } catch (err) {
	      console.error(`initAdProvider failed: ${err}`);
	      return null;
	    }
	  }

	  src(src) {
	    const {
	      player
	    } = this;
	    let sources = src;

	    if (isArray$1(sources) === false) {
	      sources = [sources];
	    }

	    const currentSrc = sources[0]; // use CORS for Akamai only (HLS auth uses cookie)
	    // multiple sources are currently passed for non-auth VOD only in which case `useCORS` will be both `false`.

	    const useCORS = AKAMAI_REGEX.test(currentSrc);
	    this.updateCrossOrigin(useCORS);

	    if (player && player.src) {
	      player.on('error', this.handlePlayerError);
	      player.src(sources);
	    }
	  }

	  handlePlayerError() {
	    let errorTitle;
	    const {
	      player
	    } = this;

	    if (player && typeof player.error() === 'function') {
	      const {
	        code,
	        message
	      } = player.error();

	      switch (code) {
	        case 0:
	          errorTitle = ERRORS.MEDIA_ERR_CUSTOM;
	          break;

	        case 1:
	          errorTitle = ERRORS.MEDIA_ERR_ABORTED;
	          break;

	        case 2:
	          errorTitle = ERRORS.MEDIA_ERR_NETWORK;
	          break;

	        case 3:
	          errorTitle = ERRORS.MEDIA_ERR_DECODE;
	          break;

	        case 4:
	          errorTitle = ERRORS.MEDIA_ERR_SRC_NOT_SUPPORTED;
	          break;

	        case 5:
	          errorTitle = ERRORS.MEDIA_ERR_ENCRYPTED;
	          break;
	      }

	      this.error(errorTitle, message);
	    }
	  }

	  updateCrossOrigin(useCORS) {
	    if (!IS_CHROME) {
	      if (IS_IOS && IOS_VERSION === '11' && useCORS) {
	        this.element_.crossOrigin = 'use-credentials';
	      } else {
	        this.element_.crossOrigin = undefined;
	      }
	    }
	  }

	  async initAnalytics(tracking) {
	    try {
	      const {
	        player,
	        configs_
	      } = this;
	      await this.coordinator.coordinate('dtci.updateAnalytics');

	      if (player.comscore && !configs_.disableComscore) {
	        player.comscore(this.analytics.comscore());
	      }

	      if (player.chartbeat && !configs_.disableChartbeat) {
	        player.chartbeat(this.analytics.chartbeat());
	      }

	      this.liveAnalyticsWatcher = new LiveAnalyticsWatcher(player, configs_);
	      const scheduleData = await this.liveAnalyticsWatcher.getScheduleData();
	      player.mediainfo.scheduleData = scheduleData;

	      if (player.mediaItem.streamType === 'live' && player.mediaItem.apiSource === 'pluto') {
	        this.liveAnalyticsWatcher.trackScheduleShows(this.coordinator);
	      }

	      if (!configs_.disableAdobe && !configs_.disableNielsen) {
	        let customMetadata = null;

	        if (tracking && tracking.heartbeats) {
	          const {
	            'a.media.asset': asset,
	            'a.media.show': show,
	            'a.media.genre': genre
	          } = tracking.heartbeats;

	          if (asset || show || genre) {
	            customMetadata = {
	              ESPN_CUSTOM_METADATA: {
	                'a.media.asset': asset,
	                'a.media.show': show,
	                'a.media.genre': genre
	              }
	            };
	          }
	        }

	        if (!this.adobeNielsen_) {
	          this.adobeNielsen_ = new ESPNAdobeNielsenAdapter(player, this.analytics.adobeDCR(customMetadata), this.coordinator);
	        } else {
	          this.adobeNielsen_.loadNewOptions(this.analytics.adobeDCR(customMetadata));
	        }
	      }
	    } catch (err) {
	      console.error(`initAnalytics: ${err}`);
	    }
	  }

	  autoplay(value) {
	    const {
	      player
	    } = this;

	    if (player && player.autoplay) {
	      return player.autoplay(value);
	    }

	    return this;
	  }

	  play() {
	    const {
	      player
	    } = this;

	    if (player) {
	      return player.play();
	    }

	    return promise.reject();
	  }

	  pause() {
	    const {
	      player
	    } = this;

	    if (player) {
	      player.pause();
	    }

	    return this;
	  }

	  muted(value) {
	    const {
	      player
	    } = this;

	    if (player) {
	      return player.muted(value);
	    }

	    return null;
	  }

	  currentTime(value) {
	    const {
	      player
	    } = this;

	    if (player) {
	      if (typeof value === 'undefined') {
	        return player.currentTime();
	      }

	      player.currentTime(value);
	    }

	    return this;
	  }

	  currentType() {
	    const {
	      player
	    } = this;

	    if (player) {
	      return player.currentType();
	    }

	    return null;
	  }

	  playbackRate() {
	    const {
	      player
	    } = this;

	    if (player) {
	      return player.playbackRate();
	    }

	    return null;
	  }

	  duration() {
	    const {
	      player
	    } = this;

	    if (player) {
	      return player.duration();
	    }

	    return null;
	  }

	  language() {
	    const {
	      player
	    } = this;

	    if (player) {
	      return player.language();
	    }

	    return null;
	  }

	  requestFullscreen() {
	    const {
	      player
	    } = this;

	    if (player) {
	      player.requestFullscreen();
	    }

	    return this;
	  }

	  exitFullscreen() {
	    const {
	      player
	    } = this;

	    if (player) {
	      player.exitFullscreen();
	    }

	    return this;
	  }
	  /**
	   * Set caption display state
	   * @param {Boolean}   [showCaptions=false]
	   */


	  captions(showCaptions) {
	    const {
	      player
	    } = this;

	    if (player) {
	      if (typeof player.captionController !== 'function') {
	        console.warn('DTCIVideoPlayer: This player tech does not implement this method.');
	        return this;
	      }

	      if (typeof showCaptions === 'boolean' && showCaptions !== player.captionController().tracksEnabled) {
	        player.captionController().toggleTracks();
	      } else {
	        // eslint-disable-next-line no-console
	        console.log(`DTCIVideoPlayer: Captions already ${showCaptions ? 'on' : 'off'}`);
	      }

	      return player.captionController().tracksEnabled;
	    }

	    return this;
	  }

	  poster(value) {
	    const {
	      player
	    } = this;

	    if (player && player.poster) {
	      player.poster(value);
	    }
	  }
	  /*
	    This will listen for the player event and returns the function to detach the listener
	   */


	  listen(type, callback) {
	    const {
	      player
	    } = this;

	    const fn = bind(callback).call(callback, this);

	    player.on(type, fn);
	    return function unlisten() {
	      try {
	        player.off(type, fn);
	      } catch (err) {
	        console.error(`Player unlisten error: ${err}`);
	      }
	    };
	  }

	  buildErrObject_(value) {
	    let err;

	    if (typeof value === 'object') {
	      err = {
	        message: value.message,
	        headline: value.headline || value.message
	      };

	      if (value.code || value.status) {
	        err.code = value.code || value.status;
	      }

	      if (value.type || value.abbreviation) {
	        err.type = value.type || value.abbreviation;
	      }

	      if (value.exception) {
	        err.message = value.exception;
	        err.headline = value.exception;
	      }
	    } else {
	      err = {
	        headline: value,
	        message: value
	      };
	    }

	    return err;
	  }

	  showCustomErrorContent_(content) {
	    if (!content) {
	      return;
	    }

	    const {
	      player
	    } = this;
	    const modal = player.getChild('errorDisplay');
	    let modalContent; // Check if content is HTML

	    if (content.nodeName) {
	      modalContent = content;
	    } else {
	      modalContent = document.createElement('div');
	      modalContent.innerHTML = content;
	    }

	    modalContent.className = 'vjs-errors-dialog';
	    modalContent.id = 'vjs-errors-dialog';
	    modal.fillWith(modalContent);

	    if (player.width() <= 600 || player.height() <= 250) {
	      modal.addClass('vjs-xs');
	    }
	  }

	  error(value, content) {
	    const {
	      player
	    } = this;
	    const err = this.buildErrObject_(value);

	    if (window.newrelic && typeof window.newrelic.noticeError === 'function') {
	      window.newrelic.noticeError(new Error(err.type || err.headline || err.message));
	    } // Errors can sometimes occur before the player is ready...


	    player.ready(() => {
	      var _context4, _context5;

	      player.error(err);
	      this.showCustomErrorContent_(content);

	      if (typeof value !== 'object' && indexOf(_context4 = this.fatalErrors).call(_context4, value) > -1 || indexOf(_context5 = this.fatalErrors).call(_context5, value.message) > -1) {
	        this.onFatalErrorDisposePlayer();
	      }
	    });
	  }

	  dispose() {
	    this.adobeNielsen_ = null;
	    this.cleanUp();

	    if (this.configs_.disposeBundleCSS) {
	      this.removePlayerCSSFromDom_();
	    }

	    if (this.dmedConviva) {
	      this.dmedConviva = null;
	    }

	    if (this.isKeydownEventEnabled) {
	      document.removeEventListener('keydown', this.onSpaceBarKeydown);
	    }

	    if (this.player) {
	      this.player.off('error', this.handlePlayerError);
	      this.player.dispose();
	    }
	  }

	  removePlayerCSSFromDom_() {
	    const cssEl = document.getElementById('web_player_css');

	    if (cssEl) {
	      document.head.removeChild(cssEl);
	    }
	  }

	  getNextContent(currentMediaItem) {
	    return async () => {
	      const nextContent = await this.coordinator.coordinate('dtci.getNextContent', currentMediaItem);

	      if (!nextContent || this.isEntertainment && !nextContent.link) {
	        return null;
	      }
	      /**
	       * this.playlistId_ is the ID of the playlist from which the video was initiated.
	       * There are two cases in which this value should be populated.
	       * First, when a user triggers a video by clicking on it in a playlist and,
	       * second, when a video is auto played from a playlist. see comment in DDA-1018.
	       * Not sure if this is where we can get playlistId. We need to confirm with clients
	       * since they will be providing getNextContent function on player init.
	       */


	      if (typeof nextContent === 'string') {
	        const mediaItem = await fetchMediaItemFromApi({
	          identifier: nextContent
	        });

	        if (mediaItem) {
	          this.playlistId_ = mediaItem.id;
	          this.coordinator.coordinate('load', mediaItem);
	          return mediaItem;
	        }
	      }

	      this.playlistId_ = nextContent.id;
	      return promise.resolve(nextContent);
	    };
	  }

	}

	var DRM_REQUIRED$4 = "We're sorry, but this browser is no longer supported.  Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.";
	var EMBARGOED$4 = "Video is not yet available.";
	var EXPIRED$4 = "Video has expired.";
	var EXPIRED_CONTENT$4 = "Video has expired.";
	var Fullscreen$4 = "Full Screen";
	var GEOLOCATION_NOT_ALLOWED$4 = "Video is not available in your country.";
	var NOT_FOUND$4 = "This video is unavailable.";
	var STREAM_LIMITED$4 = "The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.";
	var STREAM_LIMIT_ERROR$4 = "The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.";
	var hours_minutes_seconds_format$4 = "<%= hours %>, <%= minutes %> and <%= seconds %>";
	var minutes_seconds_format$4 = "<%= minutes %> and <%= seconds %>";
	var en = {
		"com.espn.watch.api.AccessDeniedException": "This content is not available for your package or region.",
		"Could not download the video": "An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.",
		DRM_REQUIRED: DRM_REQUIRED$4,
		EMBARGOED: EMBARGOED$4,
		EXPIRED: EXPIRED$4,
		EXPIRED_CONTENT: EXPIRED_CONTENT$4,
		Fullscreen: Fullscreen$4,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$4,
		NOT_FOUND: NOT_FOUND$4,
		"Non-Fullscreen": "Exit Full Screen",
		STREAM_LIMITED: STREAM_LIMITED$4,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$4,
		hours_minutes_seconds_format: hours_minutes_seconds_format$4,
		minutes_seconds_format: minutes_seconds_format$4
	};

	var Ad$2 = "Anuncio";
	var Autoplay$2 = "Reproducción automática";
	var Background$3 = "Fondo";
	var Black$2 = "Negro";
	var Blue$2 = "Azul";
	var Captions$2 = "Subtítulos especiales";
	var Casual$2 = "Informal";
	var Chapters$2 = "Capítulos";
	var Copied$2 = "Copiado";
	var Copy$3 = "Copiar";
	var Cyan$2 = "Cian";
	var Default$2 = "Default";
	var Depressed$2 = "Hundido";
	var Done$3 = "Finalizado";
	var DRM_REQUIRED$3 = "Lo siento, su navegador ya no es compatible. Por favor descarga la última versión de Google Chrome, FireFox o Microsoft Edge para disfrutar de este contenido.";
	var EMBARGOED$3 = "El vídeo no está disponible todavía.";
	var EXPIRED$3 = "El video ha expirado.";
	var EXPIRED_CONTENT$3 = "El video ha expirado.";
	var Email$2 = "Enviar por correo";
	var Foreground$3 = "Primer plano";
	var From$2 = "De";
	var Fullscreen$3 = "Maximizar video";
	var GEOLOCATION_NOT_ALLOWED$3 = "El vídeo no está disponible en tu país.";
	var Green$2 = "Verde";
	var LIVE$2 = "En Vivo";
	var Loaded$2 = "Cargado";
	var Magenta$2 = "Magenta";
	var Menu$2 = "Menú";
	var Message$2 = "Mensaje";
	var Mute$2 = "Silenciador";
	var NOT_FOUND$3 = "Este vídeo no está disponible.";
	var None$3 = "Ninguno";
	var OK$2 = "Aprobar";
	var Opaque$3 = "Opaco";
	var Pause$3 = "Pausar";
	var Play$2 = "Reproducir";
	var Progress$2 = "Progreso";
	var Purchased$2 = "Comprado";
	var Raised$2 = "Levantado";
	var Red$2 = "Rojo";
	var Replay$2 = "Reproducir de nuevo";
	var STREAM_LIMITED$3 = "El máximo número de transmisiones de vídeo simultáneas ha sido alcanzado en su cuenta.";
	var STREAM_LIMIT_ERROR$3 = "El máximo número de transmisiones de vídeo simultáneas ha sido alcanzado en su cuenta.";
	var Script$2 = "Cursiva";
	var Send$2 = "Enviar";
	var Settings$3 = "Configuración";
	var Share$3 = "Compartir";
	var Stop$2 = "Detener";
	var Subtitles$2 = "Subtítulos";
	var To$2 = "A";
	var Transparent$3 = "Transparente";
	var Uniform$2 = "Uniforme";
	var Unmute$2 = "Eliminar silenciador";
	var Unmuted$2 = "Eliminar silenciador";
	var Watch$2 = "Ver";
	var White$3 = "Blanco";
	var Window$3 = "Ventana";
	var Yellow$2 = "Amarillo";
	var Rewind$1 = "Retroceder";
	var More$1 = "Más";
	var hours$3 = "horas";
	var hour$3 = "hora";
	var minutes$3 = "minutes";
	var minute$3 = "minuto";
	var seconds$3 = "segundos";
	var second$3 = "segundo";
	var Button$3 = "Botón";
	var Pausing$3 = "Pausar";
	var Playing$2 = "Reproduciendo";
	var hours_minutes_seconds_format$3 = "<%= hours %>, <%= minutes %> y <%= seconds %>";
	var minutes_seconds_format$3 = "<%= minutes %> y <%= seconds %>";
	var es = {
		"A network error caused the video download to fail part-way.": "Un error de red ha interrumpido la descarga del vídeo.",
		Ad: Ad$2,
		Autoplay: Autoplay$2,
		"Back to video": "Volver al video",
		Background: Background$3,
		Black: Black$2,
		Blue: Blue$2,
		"Buy PPV": "Comprar PPV",
		"com.espn.watch.api.AccessDeniedException": "Este contenido no está disponible para su región o para el paquete que tiene contratado.",
		"Caption Settings": "Opciones de subtítulos",
		"Audio Options": "Opciones de audio",
		Captions: Captions$2,
		"Captions Preview": "Vista previa de subtítulos",
		Casual: Casual$2,
		Chapters: Chapters$2,
		"Check out this video on ESPN": "Echa un vistazo a este video en ESPN Play",
		"Choose Broadcast": "Elige tu transmisión",
		"Choose TV Provider": "Elegir Su Proveedor",
		"Closed Caption": "Subtítulos",
		"Closed Captions": "Subtítulos",
		Copied: Copied$2,
		"Copy Embed Link": "Obtener código",
		"Copy Link": "Obtener URL",
		Copy: Copy$3,
		"Could not download the video": "No se ha podido descargar el vídeo.",
		"Current Time": "Tiempo reproducido",
		Cyan: Cyan$2,
		Default: Default$2,
		Depressed: Depressed$2,
		Done: Done$3,
		DRM_REQUIRED: DRM_REQUIRED$3,
		"Drop shadow": "Sombra paralela",
		"Duration Time": "Duración total",
		EMBARGOED: EMBARGOED$3,
		EXPIRED: EXPIRED$3,
		EXPIRED_CONTENT: EXPIRED_CONTENT$3,
		"Email Video": "Enviar por Email",
		Email: Email$2,
		"Embed Code": "Insertar código",
		"Error Code": "Código De Error",
		"Font Family": "Familia de fuente",
		"Font Size": "Tamaño de fuente",
		Foreground: Foreground$3,
		From: From$2,
		Fullscreen: Fullscreen$3,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$3,
		"Get ESPN+": "Suscríbete a ESPN+",
		"Get MLB.TV": "Suscríbete a MLB.TV",
		Green: Green$2,
		"Language Settings": "Ajustes de idioma",
		"Learn More": "Aprende más",
		LIVE: LIVE$2,
		Loaded: Loaded$2,
		"Logged Into TV Provider": "Conectado a Proveedor",
		Magenta: Magenta$2,
		Menu: Menu$2,
		Message: Message$2,
		"Monospace Sans-Serif": "Sans-Serif monoespaciada",
		"Monospace Serif": "Serif monoespaciada",
		Mute: Mute$2,
		NOT_FOUND: NOT_FOUND$3,
		"No compatible source was found for this video.": "No se ha encontrado ninguna fuente compatible con este vídeo.",
		"No video has been loaded": "No hay ningún vídeo cargado.",
		"Non-Fullscreen": "Tamaño original",
		None: None$3,
		"Now Playing": "Reproduciendo Ahora",
		OK: OK$2,
		Opaque: Opaque$3,
		Pause: Pause$3,
		Play: Play$2,
		"Playback Rate": "Velocidad de reproducción",
		Progress: Progress$2,
		"Proportional Sans-Serif": "Sans-Serifproporcional",
		"Proportional Serif": "Serif proporcional",
		Purchased: Purchased$2,
		Raised: Raised$2,
		Red: Red$2,
		"Remaining Time": "Tiempo restante",
		Replay: Replay$2,
		"Reset to Defaults": "Regresar a configuración original",
		"Select Broadcast": "Elegir transmisión",
		STREAM_LIMITED: STREAM_LIMITED$3,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$3,
		Script: Script$2,
		"Semi-Opaque": "Semi-opaco",
		"Semi-Transparent": "Semitransparente",
		Send: Send$2,
		Settings: Settings$3,
		Share: Share$3,
		"Skip Ad": "Saltar anuncio",
		"Small Caps": "Versalitas",
		"Start at": "Iniciar en",
		Stop: Stop$2,
		"Stream Type": "Tipo de secuencia",
		"Subscribed to ESPN+": "Suscrito a ESPN+",
		Subtitles: Subtitles$2,
		"Technical details": "Detalles técnicos",
		"Text Edge Style": "Estilo de borde de los caracteres",
		"This content is not available for your package or region.": "Este contenido no está disponible para su región o para el paquete que tiene contratado.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "No se ha podido cargar el vídeo debido a un fallo de red o del servidor o porque el formato es incompatible.",
		"The video connection was lost, please confirm you are connected to the internet": "Se ha perdido la conexión al vídeo. Compruebe si su equipo está conectado a internet.",
		"The video download was cancelled": "Ha interrumpido la reproducción del vídeo.",
		"The video is bad or in a format that cannot be played on your browser": "El vídeo está dañado o tiene un formato no reproducible en su navegador.",
		"The video playback was aborted due to a corruption problem or because the video used features your browser did not support.": "La reproducción de vídeo se ha interrumpido por un problema de corrupción de datos o porque el vídeo precisa funciones que su navegador no ofrece.",
		"The video you're trying to watch is encrypted and we don't know how to decrypt it": "The video you're trying to watch is encrypted and we don't know how to decrypt it",
		"This video is either unavailable or not supported in this browser": "Este vídeo no está disponible o es incompatible con este navegador.",
		"This video is unavailable": "Este vídeo no está disponible.",
		To: To$2,
		Transparent: Transparent$3,
		Uniform: Uniform$2,
		Unmute: Unmute$2,
		Unmuted: Unmuted$2,
		"Up Next": "A continuación",
		"WATCH NOW": "VER AHORA",
		Watch: Watch$2,
		White: White$3,
		Window: Window$3,
		Yellow: Yellow$2,
		"You aborted the video playback": "Ha interrumpido la reproducción del vídeo.",
		"captions off": "Subtítulos especiales desactivados",
		"subtitles off": "Subtítulos desactivados",
		"Playback Speed": "Velocidad de reproducción",
		Rewind: Rewind$1,
		"Fast Forward": "Adelantar",
		More: More$1,
		"Seek to live, currently playing live": "Escuchando En vivo",
		"Seek to live, currently behind live": "Progreso a En Vivo",
		hours: hours$3,
		hour: hour$3,
		minutes: minutes$3,
		minute: minute$3,
		seconds: seconds$3,
		second: second$3,
		Button: Button$3,
		Pausing: Pausing$3,
		Playing: Playing$2,
		"elapsed out of": "transcurridos de",
		hours_minutes_seconds_format: hours_minutes_seconds_format$3,
		minutes_seconds_format: minutes_seconds_format$3,
		"Video Player": "Reproductor de video"
	};

	var Ad$1 = "Publicidade";
	var Autoplay$1 = "Reproduzir automaticamente";
	var Background$2 = "Fundo";
	var Black$1 = "Preto";
	var Blue$1 = "Azul";
	var Captions$1 = "Anotações";
	var Casual$1 = "Casual";
	var Chapters$1 = "Capítulos";
	var Copy$2 = "Copiar";
	var Cyan$1 = "Ciano";
	var Default$1 = "Padrão";
	var Depressed$1 = "Diminuido";
	var Done$2 = "Pronto";
	var DRM_REQUIRED$2 = "Desculpe-nos, mas este navegador não é mais suportado. Por favor, atualize para a versão mais recente do Google Chrome, FireFox ou Microsoft Edge para assistir o conteúdo.";
	var EMBARGOED$2 = "Vídeo ainda não disponível.";
	var EXPIRED$2 = "Vídeo expirou.";
	var EXPIRED_CONTENT$2 = "Vídeo expirou.";
	var Email$1 = "Email";
	var Foreground$2 = "Primer plano";
	var From$1 = "Dê";
	var Fullscreen$2 = "Tela cheia";
	var GEOLOCATION_NOT_ALLOWED$2 = "Vídeo não está disponível no seu país.";
	var Green$1 = "Verde";
	var LIVE$1 = "AO VIVO";
	var Loaded$1 = "Carregado";
	var Magenta$1 = "Magenta";
	var Menu$1 = "Menu";
	var Message$1 = "Mensagem";
	var Mute$1 = "Mudo";
	var NOT_FOUND$2 = "Vídeo não disponível.";
	var None$2 = "Nenhum";
	var OK$1 = "Ok";
	var Opaque$2 = "Opaco";
	var Pause$2 = "Pauzeren";
	var Play$1 = "Play";
	var Progress$1 = "Progresso";
	var Purchased$1 = "Comprado";
	var Raised$1 = "Aumentado";
	var Red$1 = "Vermelho";
	var Replay$1 = "Tocar novamente";
	var STREAM_LIMITED$2 = "O número máximo de conexões simultâneas foi atingido em sua conta.";
	var STREAM_LIMIT_ERROR$2 = "O número máximo de conexões simultâneas foi atingido em sua conta.";
	var Script$1 = "Script";
	var Send$1 = "Enviar";
	var Settings$2 = "Opções";
	var Share$2 = "Compartilhar";
	var Stop$1 = "Parar";
	var Subtitles$1 = "Legendas";
	var To$1 = "Para";
	var Transparent$2 = "Transparente";
	var Uniform$1 = "Uniforme";
	var Unmute$1 = "Ativar o som";
	var Unmuted$1 = "Ativar o som";
	var Watch$1 = "Assista";
	var White$2 = "Branco";
	var Window$2 = "Janela";
	var Yellow$1 = "Amarelo";
	var hours$2 = "horas";
	var hour$2 = "hora";
	var minutes$2 = "minutes";
	var minute$2 = "minuto";
	var seconds$2 = "segundos";
	var second$2 = "segundo";
	var Button$2 = "botão";
	var Pausing$2 = "Pausando";
	var hours_minutes_seconds_format$2 = "<%= hours %>, <%= minutes %> y <%= seconds %>";
	var minutes_seconds_format$2 = "<%= minutes %> y <%= seconds %>";
	var pt = {
		"A network error caused the media download to fail part-way.": "Um erro na rede fez o vídeo parar parcialmente.",
		Ad: Ad$1,
		"An unanticipated problem was encountered, check back soon and try again": "Aconteceu um erro inesperado, tente novamente mais tarde",
		Autoplay: Autoplay$1,
		Background: Background$2,
		"Back to video": "Voltar ao vídeo",
		Black: Black$1,
		Blue: Blue$1,
		"Buy PPV": "Comprar PPV",
		"com.espn.watch.api.AccessDeniedException": "Esse conteúdo não está disponível no seu pacote de assinatura ou região.",
		"Caption Settings": "Opções da legenda",
		"Audio Options": "Opções da áudio",
		Captions: Captions$1,
		"Captions Preview": "Visualização de legendas",
		Casual: Casual$1,
		Chapters: Chapters$1,
		"Check out this video on ESPN": "Confira esse vídeo no WatchESPN",
		"Choose Broadcast": "Escolha o Canal",
		"Choose TV Provider": "Escolha o Seu Provedor",
		"Closed Caption": "Legendas",
		"Closed Captions": "Legendas",
		"Copy Embed Link": "Copiar o link de embed",
		"Copy Link": "Copiar o link",
		Copy: Copy$2,
		"Could not download the video": "Ocorreu um erro durante a reprodução do vídeo, provavelmente devido a problemas na sua conexão ou em uma aba do navegador em segundo plano. Por favor, tente novamente.",
		"Current Time": "Hora atual",
		Cyan: Cyan$1,
		Default: Default$1,
		Depressed: Depressed$1,
		Done: Done$2,
		DRM_REQUIRED: DRM_REQUIRED$2,
		"Drop shadow": "Sombra",
		"Duration Time": "Tempo de duração",
		EMBARGOED: EMBARGOED$2,
		EXPIRED: EXPIRED$2,
		EXPIRED_CONTENT: EXPIRED_CONTENT$2,
		"Email Video": "Enviar vídeo por email",
		Email: Email$1,
		"Embed Code": "Código de embed",
		"Error Code": "Código de erro",
		"Font Family": "Grupo de fontes",
		"Font Size": "Tamanho da fonte",
		Foreground: Foreground$2,
		From: From$1,
		Fullscreen: Fullscreen$2,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$2,
		"Get ESPN+": "Assine a ESPN+",
		"Get MLB.TV": "Assine a MLB.TV",
		Green: Green$1,
		"Language Settings": "Configurações de idioma",
		"Learn More": "Saiba mais",
		LIVE: LIVE$1,
		Loaded: Loaded$1,
		"Logged Into TV Provider": "Logado ao Seu Provedor",
		Magenta: Magenta$1,
		Menu: Menu$1,
		Message: Message$1,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		Mute: Mute$1,
		NOT_FOUND: NOT_FOUND$2,
		"No compatible source was found for this media.": "Não foi encontrada fonte de vídeo compatível.",
		"No video has been loaded": "Nenhum vídeo foi carregado",
		"Non-Fullscreen": "Tela Normal",
		None: None$2,
		"Now Playing": "Reproduzindo Agora",
		OK: OK$1,
		Opaque: Opaque$2,
		Pause: Pause$2,
		Play: Play$1,
		"Playback Rate": "axa de reprodução",
		Progress: Progress$1,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$1,
		Raised: Raised$1,
		Red: Red$1,
		"Remaining Time": "Tempo restante",
		Replay: Replay$1,
		"Reset to Defaults": "Restaurar para as configurações padrão",
		"Select Broadcast": "Escolha a transmissão",
		"Skip Ad": "Pular anúncio",
		STREAM_LIMITED: STREAM_LIMITED$2,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$2,
		Script: Script$1,
		"Semi-Opaque": "Meio opaco",
		"Semi-Transparent": "Meio transparente",
		Send: Send$1,
		Settings: Settings$2,
		Share: Share$2,
		"Small Caps": "Minúscula",
		"Start at": "Começar em",
		Stop: Stop$1,
		"Stream Type": "Tipo de streaming",
		"Subscribed to ESPN+": "Assinante da ESPN+",
		Subtitles: Subtitles$1,
		"Technical details": "Detalhes técnicos",
		"Text Edge Style": "Estilo da borda do texto",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "O vídeo não pode ser carregado, ou porque houve um problema com sua rede ou pelo formato do vídeo não ser suportado.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "A execução foi interrompida por um problema com o vídeo ou por seu navegador não dar suporte ao seu formato.",
		"The video connection was lost, please confirm you are connected to the internet": "A conexão com o vídeo foi perdida. Por favor, confirme que está conectado a internet",
		"The video download was cancelled": "O download do vídeo foi cancelado",
		"The video is bad or in a format that cannot be played on your browser": "O vídeo está em um formato que o seu browser não suporta",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "O vídeo que você está tentando assistir é criptografado e nós não sabemos como decodificá-lo",
		"This content is not available for your package or region.": "Esse conteúdo não está disponível no seu pacote de assinatura ou região.",
		"This video is either unavailable or not supported in this browser": "O vídeo não está disponível ou não é suportado pelo seu browser",
		"This video is unavailable": "Vídeo não disponível",
		To: To$1,
		Transparent: Transparent$2,
		Uniform: Uniform$1,
		Unmute: Unmute$1,
		Unmuted: Unmuted$1,
		"Up Next": "VER AGORA",
		"WATCH NOW": "VER AHORA",
		Watch: Watch$1,
		White: White$2,
		Window: Window$2,
		Yellow: Yellow$1,
		"You aborted the media playback": "Você parou a execução do vídeo.",
		"captions off": "Legendas desligadas",
		"subtitles off": "Desligar legendas",
		hours: hours$2,
		hour: hour$2,
		minutes: minutes$2,
		minute: minute$2,
		seconds: seconds$2,
		second: second$2,
		Button: Button$2,
		Pausing: Pausing$2,
		"elapsed out of": "verstreken van",
		hours_minutes_seconds_format: hours_minutes_seconds_format$2,
		minutes_seconds_format: minutes_seconds_format$2,
		"Video Player": "Player de Vídeo"
	};

	var Settings$1 = "Instellingen";
	var DRM_REQUIRED$1 = "Het spijt ons, maar deze browser wordt niet langer ondersteund. Upgrade naar de laatste versie van Google Chrome, FireFox of Microsoft Edge om deze content te bekijken.";
	var EMBARGOED$1 = "De video is nog niet beschikbaar.";
	var EXPIRED$1 = "De video is verlopen.";
	var EXPIRED_CONTENT$1 = "De video is verlopen.";
	var Fullscreen$1 = "Volledig scherm";
	var GEOLOCATION_NOT_ALLOWED$1 = "De video is niet beschikbaar in jouw land.";
	var NOT_FOUND$1 = "De video is niet beschikbaar.";
	var STREAM_LIMITED$1 = "Het maximale aantal gelijktijdige streams is bereikt op jouw account. Als je vragen hebt of hulp nodig hebt, ga naar es.pn/watchfag of bel ???";
	var STREAM_LIMIT_ERROR$1 = "Het maximale aantal gelijktijdige streams is bereikt op jouw account. Als je vragen hebt of hulp nodig hebt, ga naar es.pn/watchfag of bel ???";
	var Foreground$1 = "Voorgrond";
	var White$1 = "Wit";
	var Opaque$1 = "Ondoorzichtig";
	var Transparent$1 = "Transparant";
	var Background$1 = "Achtergrond";
	var Window$1 = "Venster";
	var Off = "Uit";
	var On = "Aan";
	var None$1 = "Geen";
	var Done$1 = "Klaar";
	var Share$1 = "Delen";
	var Copied$1 = "Gekopieerd";
	var Copy$1 = "Kopiëren";
	var hours$1 = "uren";
	var hour$1 = "uur";
	var minutes$1 = "minuten";
	var minute$1 = "minuut";
	var seconds$1 = "seconden";
	var second$1 = "seconde";
	var Button$1 = "Knop";
	var Playing$1 = "Reproduzindo";
	var Pausing$1 = "Pauzeren";
	var Pause$1 = "Pauzeren";
	var hours_minutes_seconds_format$1 = "<%= hours %>, <%= minutes %> en <%= seconds %>";
	var minutes_seconds_format$1 = "<%= minutes %> en <%= seconds %>";
	var nl = {
		"Choose Your Broadcast": "Selecteer je uitzending",
		"Choose Broadcast": "Selecteer je uitzending",
		Settings: Settings$1,
		"Log Out of TV Provider": "Log uit bij je TV-aanbieder",
		"Logged Into TV Provider": "Aangemeld bij tv-aanbieder",
		"Closed Caption": "Gesloten bijschrift",
		"Closed Captions": "Gesloten bijschriften",
		"com.espn.watch.api.AccessDeniedException": "Deze video is niet beschikbaar in jouw TV-abonnement of regio. Mogelijk is de uitzending te zien via een ESPN Extra-kanaal.",
		"Could not download the video": "Er is een fout opgetreden tijdens het afspelen van de video, waarschijnlijk door netwerkproblemen of door het afspelen in een browser op de achtergrond. Probeer het opnieuw.",
		DRM_REQUIRED: DRM_REQUIRED$1,
		EMBARGOED: EMBARGOED$1,
		EXPIRED: EXPIRED$1,
		EXPIRED_CONTENT: EXPIRED_CONTENT$1,
		Fullscreen: Fullscreen$1,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$1,
		NOT_FOUND: NOT_FOUND$1,
		"Non-Fullscreen": "Volledig scherm afsluiten.",
		STREAM_LIMITED: STREAM_LIMITED$1,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$1,
		"This video is either unavailable or not supported in this browser": "Deze video is niet beschikbaar of wordt niet ondersteund in deze browser.",
		Foreground: Foreground$1,
		White: White$1,
		Opaque: Opaque$1,
		Transparent: Transparent$1,
		Background: Background$1,
		Window: Window$1,
		"Font Size": "Lettergrootte",
		"Language Setting": "Taal instelling",
		Off: Off,
		On: On,
		"Captions Preview": "Ondertiteling voorbeeld",
		"Text Edge Style": "Tekst omlijning",
		None: None$1,
		"Font Family": "Lettertype",
		"Reset to Defaults": "Terugzetten naar standaard",
		Done: Done$1,
		Share: Share$1,
		Copied: Copied$1,
		"Copy Embed Link": "Kopieer de Embed Link",
		"Copy Link": "Kopieer link",
		Copy: Copy$1,
		hours: hours$1,
		hour: hour$1,
		minutes: minutes$1,
		minute: minute$1,
		seconds: seconds$1,
		second: second$1,
		Button: Button$1,
		Playing: Playing$1,
		Pausing: Pausing$1,
		Pause: Pause$1,
		"elapsed out of": "decorridos em",
		hours_minutes_seconds_format: hours_minutes_seconds_format$1,
		minutes_seconds_format: minutes_seconds_format$1,
		"Video Player": "Videospeler",
		"Up Next": "Hierna"
	};

	var Ad = "Ad";
	var Autoplay = "Autoplay";
	var Background = "Background";
	var Black = "Black";
	var Blue = "Blue";
	var Captions = "Captions";
	var Casual = "Casual";
	var Chapters = "Chapters";
	var Copied = "Copied";
	var Copy = "Copy";
	var Cyan = "Cyan";
	var Default = "Default";
	var Depressed = "Depressed";
	var Done = "Done";
	var DRM_REQUIRED = "DRM_REQUIRED.";
	var EMBARGOED = "EMBARGOED";
	var EXPIRED = "EXPIRED";
	var EXPIRED_CONTENT = "EXPIRED_CONTENT";
	var Email = "Email";
	var Foreground = "Foreground";
	var From = "From";
	var Fullscreen = "全画面";
	var GEOLOCATION_NOT_ALLOWED = "GEOLOCATION_NOT_ALLOWED";
	var Green = "Green";
	var LIVE = "LIVE";
	var Loaded = "Loaded";
	var Magenta = "Magenta";
	var Menu = "Menu";
	var Message = "Message";
	var Mute = "ミュート";
	var NOT_FOUND = "NOT_FOUND";
	var None = "None";
	var OK = "OK";
	var Opaque = "Opaque";
	var Pause = "一時停止";
	var Play = "再生";
	var Progress = "Progress";
	var Purchased = "Purchased";
	var Raised = "Raised";
	var Red = "Red";
	var Replay = "再生";
	var STREAM_LIMITED = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR = "STREAM_LIMIT_ERROR";
	var Script = "Script";
	var Send = "Send";
	var Settings = "Settings";
	var Share = "Share";
	var Stop = "Stop";
	var Subtitles = "Subtitles";
	var To = "To";
	var Transparent = "Transparent";
	var Uniform = "Uniform";
	var Unmute = "ミュート解除";
	var Unmuted = "Unmuted";
	var Watch = "Watch";
	var White = "White";
	var Window = "Window";
	var Yellow = "Yellow";
	var Rewind = "10秒戻し";
	var More = "More";
	var hours = "hours";
	var hour = "hour";
	var minutes = "minutes";
	var minute = "minute";
	var seconds = "seconds";
	var second = "second";
	var Button = "Button";
	var Pausing = "Pausing";
	var Playing = "Playing";
	var hours_minutes_seconds_format = "<%= hours %>, <%= minutes %> y <%= seconds %>";
	var minutes_seconds_format = "<%= minutes %> y <%= seconds %>";
	var jp = {
		"A network error caused the video download to fail part-way.": "A network error caused the video download to fail part-way.",
		Ad: Ad,
		Autoplay: Autoplay,
		"Back to video": "Back to video",
		Background: Background,
		Black: Black,
		Blue: Blue,
		"Buy PPV": "Buy PPV",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Caption Settings",
		"Audio Options": "Audio Options",
		Captions: Captions,
		"Captions Preview": "Captions Preview",
		Casual: Casual,
		Chapters: Chapters,
		"Check out this video on ESPN": "Check out this video on ESPN",
		"Choose Broadcast": "Choose Broadcast",
		"Choose TV Provider": "Choose TV Provider",
		"Closed Caption": "Closed Caption",
		"Closed Captions": "Closed Captions",
		Copied: Copied,
		"Copy Embed Link": "Copy Embed Link",
		"Copy Link": "Copy Link",
		Copy: Copy,
		"Could not download the video": "Could not download the video",
		"Current Time": "Current Time",
		Cyan: Cyan,
		Default: Default,
		Depressed: Depressed,
		Done: Done,
		DRM_REQUIRED: DRM_REQUIRED,
		"Drop shadow": "Drop shadow",
		"Duration Time": "Duration Time",
		EMBARGOED: EMBARGOED,
		EXPIRED: EXPIRED,
		EXPIRED_CONTENT: EXPIRED_CONTENT,
		"Email Video": "Email Video",
		Email: Email,
		"Embed Code": "Embed Code",
		"Error Code": "Error Code",
		"Font Family": "Font Family",
		"Font Size": "Font Size",
		Foreground: Foreground,
		From: From,
		Fullscreen: Fullscreen,
		"Full Screen": "全画面",
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED,
		"Get ESPN+": "Get ESPN+",
		"Get MLB.TV": "Get MLB.TV",
		Green: Green,
		"Language Settings": "Language Settings",
		"Learn More": "Learn More",
		LIVE: LIVE,
		Loaded: Loaded,
		"Logged Into TV Provider": "Logged Into TV Provider",
		Magenta: Magenta,
		Menu: Menu,
		Message: Message,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		Mute: Mute,
		NOT_FOUND: NOT_FOUND,
		"No compatible source was found for this video.": "No compatible source was found for this video.",
		"No video has been loaded": "No video has been loaded",
		"Non-Fullscreen": "全画面終了",
		None: None,
		"Now Playing": "Now Playing",
		OK: OK,
		Opaque: Opaque,
		Pause: Pause,
		Play: Play,
		"Playback Rate": "Playback Rate",
		Progress: Progress,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased,
		Raised: Raised,
		Red: Red,
		"Remaining Time": "Remaining Time",
		Replay: Replay,
		"Reset to Defaults": "Reset to Defaults",
		"Select Broadcast": "Select Broadcast",
		STREAM_LIMITED: STREAM_LIMITED,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR,
		Script: Script,
		"Semi-Opaque": "Semi-Opaque",
		"Semi-Transparent": "Semi-Transparent",
		Send: Send,
		Settings: Settings,
		Share: Share,
		"Skip Ad": "Skip Ad",
		"Small Caps": "Small Caps",
		"Start at": "Start at",
		Stop: Stop,
		"Stream Type": "Stream Type",
		"Subscribed to ESPN+": "Subscribed to ESPN+",
		Subtitles: Subtitles,
		"Technical details": "Technical details",
		"Text Edge Style": "Text Edge Style",
		"This content is not available for your package or region.": "This content is not available for your package or region.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "The media could not be loaded, either because the server or network failed or because the format is not supported.",
		"The video connection was lost, please confirm you are connected to the internet": "The video connection was lost, please confirm you are connected to the internet",
		"The video download was cancelled": "The video download was cancelled",
		"The video is bad or in a format that cannot be played on your browser": "The video is bad or in a format that cannot be played on your browser",
		"The video playback was aborted due to a corruption problem or because the video used features your browser did not support.": "The video playback was aborted due to a corruption problem or because the video used features your browser did not support.",
		"The video you're trying to watch is encrypted and we don't know how to decrypt it": "The video you're trying to watch is encrypted and we don't know how to decrypt it",
		"This video is either unavailable or not supported in this browser": "This video is either unavailable or not supported in this browser",
		"This video is unavailable": "This video is unavailable",
		To: To,
		Transparent: Transparent,
		Uniform: Uniform,
		Unmute: Unmute,
		Unmuted: Unmuted,
		"Up Next": "Up Next",
		"WATCH NOW": "WATCH NOW",
		Watch: Watch,
		White: White,
		Window: Window,
		Yellow: Yellow,
		"You aborted the video playback": "You aborted the video playback",
		"captions off": "captions off",
		"subtitles off": "subtitles off",
		"Playback Speed": "Playback Speed",
		Rewind: Rewind,
		"Fast Forward": "10秒送り",
		More: More,
		"Seek to live, currently playing live": "Seek to live, currently playing live",
		"Seek to live, currently behind live": "Seek to live, currently behind live",
		hours: hours,
		hour: hour,
		minutes: minutes,
		minute: minute,
		seconds: seconds,
		second: second,
		Button: Button,
		Pausing: Pausing,
		Playing: Playing,
		"elapsed out of": "elapsed out of",
		"Exit Full Screen": "全画面終了",
		"Play Video": "再生",
		hours_minutes_seconds_format: hours_minutes_seconds_format,
		minutes_seconds_format: minutes_seconds_format,
		"Video Player": "Reproductor de video"
	};

	/* eslint-disable no-restricted-syntax */
	let LANG = 'en';
	let TRANSLATIONS = {};

	const I18n = function I18n(key) {
	  return TRANSLATIONS[LANG][key] || TRANSLATIONS.en[key] || key;
	};
	/*
	  Adds key/value pairs in the form of:
	  {
	    "Yes": "はい"
	    "No": "いいえ"
	  }
	 */


	I18n.add = function add(lang, data) {
	  let k;
	  let v;

	  if (!TRANSLATIONS[lang]) {
	    TRANSLATIONS[lang] = {};
	  }

	  for (k in data) {
	    v = data[k];
	    TRANSLATIONS[lang][k] = v;
	  }
	};
	/*
	  Destroy translation data
	 */


	I18n.reset = function reset() {
	  TRANSLATIONS = {};
	  LANG = 'en';
	};

	I18n.setLang = function setLang(lang) {
	  if (TRANSLATIONS[lang]) {
	    LANG = lang;
	  }
	};

	I18n.translations = function translations() {
	  return TRANSLATIONS;
	};

	I18n.add('en', en);
	I18n.add('es', es);
	I18n.add('pt', pt);
	I18n.add('nl', nl);
	I18n.add('jp', jp);

	class LoggingEvent {
	  constructor(player, actionType, eventType, logPlaybackDetails, data) {
	    this.player_ = {};
	    this.actionType_ = undefined;
	    this.eventType_ = undefined;
	    this.logPlaybackDetails_ = true;
	    this.data_ = undefined;
	    this.player_ = player;
	    this.actionType_ = actionType;
	    this.eventType_ = eventType;
	    this.logPlaybackDetails_ = logPlaybackDetails;
	    this.data_ = data;
	  }

	  getLoggingEvent() {
	    const defaultLoggings = this.defaultLoggings_();

	    if (this.logPlaybackDetails_) {
	      const playerInfo = this.getPlayerInfo();
	      const error = this.player_.error();

	      if (error && (error.code || error.message)) {
	        return { ...defaultLoggings,
	          ...playerInfo,
	          ...error,
	          ...this.data_
	        };
	      }

	      return { ...defaultLoggings,
	        ...playerInfo,
	        ...this.data_
	      };
	    }

	    return { ...defaultLoggings,
	      eventType: this.eventType_,
	      actionType: this.actionType_,
	      ...this.data_
	    };
	  }

	  defaultLoggings_() {
	    const {
	      location: {
	        href
	      } = {},
	      navigator: {
	        userAgent
	      } = {},
	      languages
	    } = window || {};
	    const fan = new Fan();
	    return {
	      href,
	      userAgent,
	      languages,
	      swid: fan.SWID
	    };
	  }

	  getPlayerInfo() {
	    const player = this.player_;
	    const {
	      src
	    } = player.currentSource();
	    const {
	      vhs,
	      dash
	    } = player;

	    if (vhs) {
	      return this.getPlayerInfoFromVHS(src, vhs);
	    }

	    if (dash) {
	      const {
	        mediaPlayer
	      } = dash;
	      return this.getPlayerInfoFromDash(src, mediaPlayer);
	    }

	    return null;
	  }

	  getPlayerInfoFromVHS(playerSource, vhs = {}) {
	    const {
	      playlists: {
	        media_: {
	          resolvedUri
	        } = {}
	      } = {},
	      masterPlaylistController_: {
	        mainSegmentLoader_: {
	          error_,
	          pendingSegment_
	        } = {}
	      } = {},
	      stats: {
	        bandwidth,
	        buffered,
	        currentSource: {
	          src
	        },
	        currentTime,
	        mediaRequests,
	        mediaRequestsAborted,
	        mediaRequestsTimedout,
	        mediaRequestsErrored,
	        mediaTransferDuration,
	        mediaBytesTransferred,
	        mediaSecondsLoaded,
	        videoPlaybackQuality
	      } = {}
	    } = vhs;
	    return {
	      playerSource,
	      resolvedUri,
	      error_,
	      pendingSegment_,
	      bandwidth,
	      buffered,
	      currentTime,
	      mediaRequests,
	      mediaRequestsAborted,
	      mediaRequestsTimedout,
	      mediaRequestsErrored,
	      mediaTransferDuration,
	      mediaBytesTransferred,
	      mediaSecondsLoaded,
	      videoPlaybackQuality,
	      currentSource: src,
	      mediaType: 'VHS',
	      eventType: this.eventType_,
	      actionType: this.actionType_
	    };
	  }

	  getPlayerInfoFromDash(playerSource, mediaPlayer = {}) {
	    let info = {};

	    if (mediaPlayer.getActiveStream && typeof mediaPlayer.getActiveStream === 'function') {
	      const activeStream = mediaPlayer.getActiveStream();

	      if (activeStream && typeof activeStream.getId === 'function') {
	        info.activeStreamId = activeStream.getId();
	      }
	    }

	    if (mediaPlayer.getDashAdapter && typeof mediaPlayer.getDashAdapter === 'function') {
	      const dashAdapter = mediaPlayer.getDashAdapter();

	      if (dashAdapter && typeof dashAdapter.getMpd === 'function') {
	        const mpd = dashAdapter.getMpd();

	        if (mpd && typeof mpd === 'object') {
	          const {
	            availabilityEndTime,
	            availabilityStartTime,
	            maxSegmentDuration,
	            mediaPresentationDuration,
	            minimumUpdatePeriod,
	            suggestedPresentationDelay,
	            timeShiftBufferDepth
	          } = mpd;
	          info = { ...info,
	            availabilityEndTime,
	            availabilityStartTime,
	            maxSegmentDuration,
	            mediaPresentationDuration,
	            minimumUpdatePeriod,
	            suggestedPresentationDelay,
	            timeShiftBufferDepth
	          };
	        }
	      }
	    }

	    const mpdInfo = { ...info,
	      playerSource,
	      mediaType: 'Dash',
	      eventType: this.eventType_,
	      actionType: this.actionType_
	    };
	    return mpdInfo;
	  }

	}

	class NewRelicLogging {
	  constructor(serviceUrl, accountId, insertKey, enabled) {
	    this.serviceUrl_ = undefined;
	    this.accountId_ = undefined;
	    this.insertKey_ = undefined;
	    this.enabled_ = false;
	    this.serviceUrl_ = serviceUrl;
	    this.accountId_ = accountId;
	    this.insertKey_ = insertKey;
	    this.enabled_ = enabled;
	  }

	  logEvent(postData = {}) {
	    if (this.enabled_) {
	      const url = this._getServiceUrl(this.serviceUrl_, this.accountId_);

	      const headers = this._getHeaders(this.insertKey_);

	      return this.sendLogEvent(postData, headers, url);
	    }

	    return null;
	  }

	  _getServiceUrl(serviceUrl, accountId) {
	    return `${serviceUrl}${accountId}/events`;
	  }

	  _getHeaders(insertKey) {
	    return {
	      'Content-Type': 'application/json',
	      'X-Insert-Key': insertKey
	    };
	  }

	  async sendLogEvent(postData, headers, url) {
	    const result = await fetchServices({
	      url,
	      headers,
	      postData,
	      method: 'POST',
	      isAuthNeeded: false
	    });
	    return result;
	  }

	}

	async function newRelicLoggingFactory({
	  player,
	  actionType,
	  message,
	  newRelicConfig,
	  logPlaybackDetails = true,
	  eventType = 'webPlayerBundlePlayback',
	  data
	}) {
	  try {
	    const {
	      serviceUrl,
	      accountId,
	      insertKey,
	      enabled
	    } = newRelicConfig;
	    const loggingEvent = new LoggingEvent(player, actionType, eventType, logPlaybackDetails, data);
	    const newRelicLogging = new NewRelicLogging(serviceUrl, accountId, insertKey, enabled);
	    const loggingEventData = loggingEvent.getLoggingEvent();
	    const result = await newRelicLogging.logEvent(loggingEventData);

	    if (result && result.err) {
	      throw new Error(`${message}: ${result.err}`);
	    }
	  } catch (err) {
	    console.error(`newRelicLogging: ${err}`);
	  }
	}

	function initNewRelicTracking(player, newRelicConfig) {
	  player.on('error', e => {
	    const {
	      mediainfo: {
	        cerebroId,
	        id: mediainfoId
	      } = {}
	    } = player;
	    newRelicLoggingFactory({
	      player,
	      newRelicConfig,
	      actionType: e.type,
	      message: 'send newRelic logging onError',
	      data: {
	        mediainfoId,
	        cerebroId
	      }
	    });
	  });
	  /**
	   * More event NR tracking can be added as following example:
	   * additional tracking data and logPlaybackDetails can be passed in newRelicLoggingFactory.
	   * if logPlaybackDetails is set to false, playbackDetails will not be tracked
	    player.on('ad-started', (e) => {
	      newRelicLoggingFactory({
	        player,
	        newRelicConfig,
	        actionType: e.type,
	        message: 'send newRelic logging on ad-started',
	        data: {
	          adId: player.ads.adId,
	          adStartedTime: Date.now(),
	        },
	        logPlaybackDetails: false,
	      });
	    });
	   */
	}

	var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
	var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

	// We can't use this feature detection in V8 since it causes
	// deoptimization and serious performance degradation
	// https://github.com/zloirock/core-js/issues/679
	var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
	  var array = [];
	  array[IS_CONCAT_SPREADABLE] = false;
	  return array.concat()[0] !== array;
	});

	var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

	var isConcatSpreadable = function (O) {
	  if (!isObject(O)) return false;
	  var spreadable = O[IS_CONCAT_SPREADABLE];
	  return spreadable !== undefined ? !!spreadable : isArray$4(O);
	};

	var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

	// `Array.prototype.concat` method
	// https://tc39.es/ecma262/#sec-array.prototype.concat
	// with adding support of @@isConcatSpreadable and @@species
	_export({ target: 'Array', proto: true, forced: FORCED }, {
	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  concat: function concat(arg) {
	    var O = toObject(this);
	    var A = arraySpeciesCreate(O, 0);
	    var n = 0;
	    var i, k, length, len, E;
	    for (i = -1, length = arguments.length; i < length; i++) {
	      E = i === -1 ? O : arguments[i];
	      if (isConcatSpreadable(E)) {
	        len = toLength(E.length);
	        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
	        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
	      } else {
	        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
	        createProperty(A, n++, E);
	      }
	    }
	    A.length = n;
	    return A;
	  }
	});

	var concat$2 = entryVirtual('Array').concat;

	var ArrayPrototype = Array.prototype;

	var concat_1 = function (it) {
	  var own = it.concat;
	  return it === ArrayPrototype || (it instanceof Array && own === ArrayPrototype.concat) ? concat$2 : own;
	};

	var concat$1 = concat_1;

	var concat = concat$1;

	/**
	 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** Used to match template delimiters. */
	var reInterpolate = /<%=([\s\S]+?)%>/g;

	var lodash__reinterpolate = reInterpolate;

	/**
	 * Lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */


	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    symbolTag = '[object Symbol]',
	    undefinedTag = '[object Undefined]';

	/** Used to match HTML entities and HTML characters. */
	var reUnescapedHtml = /[&<>"']/g,
	    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

	/** Used to match template delimiters. */
	var reEscape = /<%-([\s\S]+?)%>/g,
	    reEvaluate = /<%([\s\S]+?)%>/g;

	/** Used to map characters to HTML entities. */
	var htmlEscapes = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#39;'
	};

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.propertyOf` without support for deep paths.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyOf(object) {
	  return function(key) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * Used by `_.escape` to convert characters to HTML entities.
	 *
	 * @private
	 * @param {string} chr The matched character to escape.
	 * @returns {string} Returns the escaped character.
	 */
	var escapeHtmlChar = basePropertyOf(htmlEscapes);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var Symbol$1 = root.Symbol,
	    symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * By default, the template delimiters used by lodash are like those in
	 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
	 * following template settings to use alternative delimiters.
	 *
	 * @static
	 * @memberOf _
	 * @type {Object}
	 */
	var templateSettings = {

	  /**
	   * Used to detect `data` property values to be HTML-escaped.
	   *
	   * @memberOf _.templateSettings
	   * @type {RegExp}
	   */
	  'escape': reEscape,

	  /**
	   * Used to detect code to be evaluated.
	   *
	   * @memberOf _.templateSettings
	   * @type {RegExp}
	   */
	  'evaluate': reEvaluate,

	  /**
	   * Used to detect `data` property values to inject.
	   *
	   * @memberOf _.templateSettings
	   * @type {RegExp}
	   */
	  'interpolate': lodash__reinterpolate,

	  /**
	   * Used to reference the data object in the template text.
	   *
	   * @memberOf _.templateSettings
	   * @type {string}
	   */
	  'variable': '',

	  /**
	   * Used to import variables into the compiled template.
	   *
	   * @memberOf _.templateSettings
	   * @type {Object}
	   */
	  'imports': {

	    /**
	     * A reference to the `lodash` function.
	     *
	     * @memberOf _.templateSettings.imports
	     * @type {Function}
	     */
	    '_': { 'escape': escape$1 }
	  }
	};

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	/**
	 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
	 * corresponding HTML entities.
	 *
	 * **Note:** No other characters are escaped. To escape additional
	 * characters use a third-party library like [_he_](https://mths.be/he).
	 *
	 * Though the ">" character is escaped for symmetry, characters like
	 * ">" and "/" don't need escaping in HTML and have no special meaning
	 * unless they're part of a tag or unquoted attribute value. See
	 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	 * (under "semi-related fun fact") for more details.
	 *
	 * When working with HTML you should always
	 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
	 * XSS vectors.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category String
	 * @param {string} [string=''] The string to escape.
	 * @returns {string} Returns the escaped string.
	 * @example
	 *
	 * _.escape('fred, barney, & pebbles');
	 * // => 'fred, barney, &amp; pebbles'
	 */
	function escape$1(string) {
	  string = toString(string);
	  return (string && reHasUnescapedHtml.test(string))
	    ? string.replace(reUnescapedHtml, escapeHtmlChar)
	    : string;
	}

	var lodash_templatesettings = templateSettings;

	var lodash_template = createCommonjsModule(function (module, exports) {
	/**
	 * Lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */


	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    asyncTag = '[object AsyncFunction]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    domExcTag = '[object DOMException]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    nullTag = '[object Null]',
	    objectTag = '[object Object]',
	    proxyTag = '[object Proxy]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    undefinedTag = '[object Undefined]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to match empty string literals in compiled template source. */
	var reEmptyStringLeading = /\b__p \+= '';/g,
	    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/**
	 * Used to match
	 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
	 */
	var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Used to ensure capturing order of template delimiters. */
	var reNoMatch = /($^)/;

	/** Used to match unescaped characters in compiled string literals. */
	var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/** Used to escape characters for inclusion in compiled string literals. */
	var stringEscapes = {
	  '\\': '\\',
	  "'": "'",
	  '\n': 'n',
	  '\r': 'r',
	  '\u2028': 'u2028',
	  '\u2029': 'u2029'
	};

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Detect free variable `exports`. */
	var freeExports = exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    // Use `util.types` for Node.js 10+.
	    var types = freeModule && freeModule.require && freeModule.require('util').types;

	    if (types) {
	      return types;
	    }

	    // Legacy `process.binding('util')` for Node.js < 10.
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/**
	 * The base implementation of `_.values` and `_.valuesIn` which creates an
	 * array of `object` property values corresponding to the property names
	 * of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the array of property values.
	 */
	function baseValues(object, props) {
	  return arrayMap(props, function(key) {
	    return object[key];
	  });
	}

	/**
	 * Used by `_.template` to escape characters for inclusion in compiled string literals.
	 *
	 * @private
	 * @param {string} chr The matched character to escape.
	 * @returns {string} Returns the escaped character.
	 */
	function escapeStringChar(chr) {
	  return '\\' + stringEscapes[chr];
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    Symbol = root.Symbol,
	    getPrototype = overArg(Object.getPrototypeOf, Object),
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	    nativeKeys = overArg(Object.keys, Object),
	    nativeMax = Math.max,
	    nativeNow = Date.now;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	/**
	 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
	 * of source objects to the destination object for all destination properties
	 * that resolve to `undefined`.
	 *
	 * @private
	 * @param {*} objValue The destination value.
	 * @param {*} srcValue The source value.
	 * @param {string} key The key of the property to assign.
	 * @param {Object} object The parent object of `objValue`.
	 * @returns {*} Returns the value to assign.
	 */
	function customDefaultsAssignIn(objValue, srcValue, key, object) {
	  if (objValue === undefined ||
	      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	    return srcValue;
	  }
	  return objValue;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	/**
	 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	 * `SyntaxError`, `TypeError`, or `URIError` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	 * @example
	 *
	 * _.isError(new Error);
	 * // => true
	 *
	 * _.isError(Error);
	 * // => false
	 */
	function isError(value) {
	  if (!isObjectLike(value)) {
	    return false;
	  }
	  var tag = baseGetTag(value);
	  return tag == errorTag || tag == domExcTag ||
	    (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	/**
	 * This method is like `_.assignIn` except that it accepts `customizer`
	 * which is invoked to produce the assigned values. If `customizer` returns
	 * `undefined`, assignment is handled by the method instead. The `customizer`
	 * is invoked with five arguments: (objValue, srcValue, key, object, source).
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias extendWith
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} sources The source objects.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 * @see _.assignWith
	 * @example
	 *
	 * function customizer(objValue, srcValue) {
	 *   return _.isUndefined(objValue) ? srcValue : objValue;
	 * }
	 *
	 * var defaults = _.partialRight(_.assignInWith, customizer);
	 *
	 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	  copyObject(source, keysIn(source), object, customizer);
	});

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	/**
	 * Creates a compiled template function that can interpolate data properties
	 * in "interpolate" delimiters, HTML-escape interpolated data properties in
	 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	 * properties may be accessed as free variables in the template. If a setting
	 * object is given, it takes precedence over `_.templateSettings` values.
	 *
	 * **Note:** In the development build `_.template` utilizes
	 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	 * for easier debugging.
	 *
	 * For more information on precompiling templates see
	 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	 *
	 * For more information on Chrome extension sandboxes see
	 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category String
	 * @param {string} [string=''] The template string.
	 * @param {Object} [options={}] The options object.
	 * @param {RegExp} [options.escape=_.templateSettings.escape]
	 *  The HTML "escape" delimiter.
	 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
	 *  The "evaluate" delimiter.
	 * @param {Object} [options.imports=_.templateSettings.imports]
	 *  An object to import into the template as free variables.
	 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
	 *  The "interpolate" delimiter.
	 * @param {string} [options.sourceURL='templateSources[n]']
	 *  The sourceURL of the compiled template.
	 * @param {string} [options.variable='obj']
	 *  The data object variable name.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Function} Returns the compiled template function.
	 * @example
	 *
	 * // Use the "interpolate" delimiter to create a compiled template.
	 * var compiled = _.template('hello <%= user %>!');
	 * compiled({ 'user': 'fred' });
	 * // => 'hello fred!'
	 *
	 * // Use the HTML "escape" delimiter to escape data property values.
	 * var compiled = _.template('<b><%- value %></b>');
	 * compiled({ 'value': '<script>' });
	 * // => '<b>&lt;script&gt;</b>'
	 *
	 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
	 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	 * compiled({ 'users': ['fred', 'barney'] });
	 * // => '<li>fred</li><li>barney</li>'
	 *
	 * // Use the internal `print` function in "evaluate" delimiters.
	 * var compiled = _.template('<% print("hello " + user); %>!');
	 * compiled({ 'user': 'barney' });
	 * // => 'hello barney!'
	 *
	 * // Use the ES template literal delimiter as an "interpolate" delimiter.
	 * // Disable support by replacing the "interpolate" delimiter.
	 * var compiled = _.template('hello ${ user }!');
	 * compiled({ 'user': 'pebbles' });
	 * // => 'hello pebbles!'
	 *
	 * // Use backslashes to treat delimiters as plain text.
	 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	 * compiled({ 'value': 'ignored' });
	 * // => '<%- value %>'
	 *
	 * // Use the `imports` option to import `jQuery` as `jq`.
	 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	 * compiled({ 'users': ['fred', 'barney'] });
	 * // => '<li>fred</li><li>barney</li>'
	 *
	 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
	 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	 * compiled(data);
	 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
	 *
	 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
	 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	 * compiled.source;
	 * // => function(data) {
	 * //   var __t, __p = '';
	 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	 * //   return __p;
	 * // }
	 *
	 * // Use custom template delimiters.
	 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	 * var compiled = _.template('hello {{ user }}!');
	 * compiled({ 'user': 'mustache' });
	 * // => 'hello mustache!'
	 *
	 * // Use the `source` property to inline compiled templates for meaningful
	 * // line numbers in error messages and stack traces.
	 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
	 *   var JST = {\
	 *     "main": ' + _.template(mainText).source + '\
	 *   };\
	 * ');
	 */
	function template(string, options, guard) {
	  // Based on John Resig's `tmpl` implementation
	  // (http://ejohn.org/blog/javascript-micro-templating/)
	  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	  var settings = lodash_templatesettings.imports._.templateSettings || lodash_templatesettings;

	  if (guard && isIterateeCall(string, options, guard)) {
	    options = undefined;
	  }
	  string = toString(string);
	  options = assignInWith({}, options, settings, customDefaultsAssignIn);

	  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
	      importsKeys = keys(imports),
	      importsValues = baseValues(imports, importsKeys);

	  var isEscaping,
	      isEvaluating,
	      index = 0,
	      interpolate = options.interpolate || reNoMatch,
	      source = "__p += '";

	  // Compile the regexp to match each delimiter.
	  var reDelimiters = RegExp(
	    (options.escape || reNoMatch).source + '|' +
	    interpolate.source + '|' +
	    (interpolate === lodash__reinterpolate ? reEsTemplate : reNoMatch).source + '|' +
	    (options.evaluate || reNoMatch).source + '|$'
	  , 'g');

	  // Use a sourceURL for easier debugging.
	  // The sourceURL gets injected into the source that's eval-ed, so be careful
	  // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
	  // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.
	  var sourceURL = hasOwnProperty.call(options, 'sourceURL')
	    ? ('//# sourceURL=' +
	       (options.sourceURL + '').replace(/[\r\n]/g, ' ') +
	       '\n')
	    : '';

	  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	    interpolateValue || (interpolateValue = esTemplateValue);

	    // Escape characters that can't be included in string literals.
	    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	    // Replace delimiters with snippets.
	    if (escapeValue) {
	      isEscaping = true;
	      source += "' +\n__e(" + escapeValue + ") +\n'";
	    }
	    if (evaluateValue) {
	      isEvaluating = true;
	      source += "';\n" + evaluateValue + ";\n__p += '";
	    }
	    if (interpolateValue) {
	      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	    }
	    index = offset + match.length;

	    // The JS engine embedded in Adobe products needs `match` returned in
	    // order to produce the correct `offset` value.
	    return match;
	  });

	  source += "';\n";

	  // If `variable` is not specified wrap a with-statement around the generated
	  // code to add the data object to the top of the scope chain.
	  // Like with sourceURL, we take care to not check the option's prototype,
	  // as this configuration is a code injection vector.
	  var variable = hasOwnProperty.call(options, 'variable') && options.variable;
	  if (!variable) {
	    source = 'with (obj) {\n' + source + '\n}\n';
	  }
	  // Cleanup code by stripping empty strings.
	  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	    .replace(reEmptyStringMiddle, '$1')
	    .replace(reEmptyStringTrailing, '$1;');

	  // Frame code as the function body.
	  source = 'function(' + (variable || 'obj') + ') {\n' +
	    (variable
	      ? ''
	      : 'obj || (obj = {});\n'
	    ) +
	    "var __t, __p = ''" +
	    (isEscaping
	       ? ', __e = _.escape'
	       : ''
	    ) +
	    (isEvaluating
	      ? ', __j = Array.prototype.join;\n' +
	        "function print() { __p += __j.call(arguments, '') }\n"
	      : ';\n'
	    ) +
	    source +
	    'return __p\n}';

	  var result = attempt(function() {
	    return Function(importsKeys, sourceURL + 'return ' + source)
	      .apply(undefined, importsValues);
	  });

	  // Provide the compiled function's source by its `toString` method or
	  // the `source` property as a convenience for inlining compiled templates.
	  result.source = source;
	  if (isError(result)) {
	    throw result;
	  }
	  return result;
	}

	/**
	 * Attempts to invoke `func`, returning either the result or the caught error
	 * object. Any additional arguments are provided to `func` when it's invoked.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Util
	 * @param {Function} func The function to attempt.
	 * @param {...*} [args] The arguments to invoke `func` with.
	 * @returns {*} Returns the `func` result or error object.
	 * @example
	 *
	 * // Avoid throwing errors for invalid selectors.
	 * var elements = _.attempt(function(selector) {
	 *   return document.querySelectorAll(selector);
	 * }, '>_>');
	 *
	 * if (_.isError(elements)) {
	 *   elements = [];
	 * }
	 */
	var attempt = baseRest(function(func, args) {
	  try {
	    return apply(func, undefined, args);
	  } catch (e) {
	    return isError(e) ? e : new Error(e);
	  }
	});

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = template;
	});

	const HOURS = 'hours';
	const HOUR = 'hour';
	const MINUTES = 'minutes';
	const MINUTE = 'minute';
	const SECONDS = 'seconds';
	const SECOND = 'second';
	const SECONDS_TEMPLATE = '<%= seconds %>';
	const SECONDS_FORMAT = ['seconds', 'format'];
	const defaultLabels = {
	  hours: HOURS,
	  hour: HOUR,
	  minutes: MINUTES,
	  minute: MINUTE,
	  seconds: SECONDS,
	  second: SECOND,
	  hours_minutes_seconds_format: '<%= hours %>, <%= minutes %> and <%= seconds %>',
	  minutes_seconds_format: '<%= minutes %> and <%= seconds %>'
	};
	var humanizeDuration = ((ms, labels = defaultLabels) => {
	  let seconds = ms / 1000;
	  let minutes = seconds / 60;
	  let hours = minutes / 60;
	  let templateParts = [];
	  seconds = Math.floor(seconds) % 60;
	  minutes = Math.floor(minutes) % 60;
	  hours = Math.floor(hours);

	  if (hours > 0) {
	    templateParts.push(HOURS);
	  }

	  if (minutes > 0 || hours > 0) {
	    templateParts.push(MINUTES);
	  }

	  templateParts = concat(templateParts).call(templateParts, SECONDS_FORMAT);
	  const compiled = lodash_template(labels[templateParts.join('_')] || SECONDS_TEMPLATE);
	  return compiled({
	    hours: `${hours} ${labels[hours === 1 ? HOUR : HOURS]}`,
	    minutes: `${minutes} ${labels[minutes === 1 ? MINUTE : MINUTES]}`,
	    seconds: `${seconds} ${labels[seconds === 1 ? SECOND : SECONDS]}`
	  });
	});

	const defaultOptions = {
	  bindTo: 'on',
	  unbindTo: 'off',
	  createDisposer: true
	};

	const noop = function noop() {};

	function subscribeTo(target, evtNames, handler, options) {
	  var _context, _context2;

	  const {
	    bindTo,
	    unbindTo,
	    createDisposer
	  } = videojs.mergeOptions(defaultOptions, options);
	  const bindToFunc = typeof target[bindTo] === 'function' ? bind(_context = target[bindTo]).call(_context, target) : noop;
	  const unbindToFunc = typeof target[unbindTo] === 'function' ? bind(_context2 = target[unbindTo]).call(_context2, target) : noop;
	  const disposers = [];

	  if (evtNames instanceof Array) {
	    forEach(evtNames).call(evtNames, evtName => {
	      bindToFunc(evtName, handler);

	      if (createDisposer) {
	        disposers.push(() => {
	          unbindToFunc(evtName, handler);
	        });
	      }
	    });
	  }

	  return disposers;
	}

	const PLAY_PAUSED_DELAY = 1000;
	const AD_PLAY_BTN_SELECTOR = '.ima-ad-container .ima-play-pause-div, .vjs-ad-control-bar .vjs-play-control';

	class VideoJsAdapter extends BasePlayerAdapter {
	  constructor(element, configs = {}, coordinator) {
	    var _context, _context2, _context3, _context4;

	    super(element, configs, coordinator);
	    this.newRelic_ = {};
	    this.isNRtrackingEnabled_ = false;
	    this.lastErrorTime_ = null;
	    this.isDisposed = false;
	    this.resumePausedTimeouts_ = [];
	    this.dtciSocial = null;
	    this.setUsingKeyboard_ = bind(_context = this.setUsingKeyboard_).call(_context, this);
	    this.setUsingMouse_ = bind(_context2 = this.setUsingMouse_).call(_context2, this);
	    this.resumePausedVideo = bind(_context3 = this.resumePausedVideo).call(_context3, this);
	    this.debouncedSetSizeClass = debounce(bind(_context4 = this.setSizeClass).call(_context4, this), 250);
	  }

	  get tech() {
	    return window.videojs;
	  }

	  get playerName() {
	    return `DTCI bundle ${"3.3.40"}, VideoJS ${this.tech.VERSION}`;
	  }

	  get platformVersion() {
	    return "3.3.40";
	  }

	  get showCaptionsUI_() {
	    const {
	      captions: {
	        disabled = false
	      } = {}
	    } = this.configs_;
	    return !disabled;
	  }

	  prepareForPlayer_() {
	    super.prepareForPlayer_();
	    const adProvider = this.configs_ && this.configs_.adProvider;

	    if (adProvider) {
	      const options = adProvider.options || {};
	      this.configs_.adProvider = {
	        options,
	        provider: adProvider.provider || 'GoogleForVideoJS'
	      };
	    }

	    this.setUpVideoJs_();
	  }

	  createPlayer_() {
	    super.createPlayer_(); // Set dispose player to false when create a new player
	    // isDisposed let the player know when it has been disposed to prevent dispose twice

	    this.isDisposed = false;
	    this.initPlugins_();
	    this.initEventHandlers_();
	  }

	  async configurePlayer_() {
	    const {
	      configs_ = {}
	    } = this;
	    const {
	      disableAutoplayMenu
	    } = configs_;

	    if (!disableAutoplayMenu) {
	      let {
	        autoplay
	      } = configs_;

	      if (autoplay === 'userPreference') {
	        const fan = new Fan();
	        autoplay = await fan.getAutoStart();
	      } else {
	        autoplay = !!(autoplay === 'on' || autoplay === true);
	      } // Set the autoplay menu item to reflect `autoStart` value in the UI


	      this.updateAutoplayUI(autoplay);
	    }

	    super.configurePlayer_();
	  }

	  updateAutoplayUI(autoplay) {
	    const {
	      player,
	      configs_: {
	        isAudio
	      }
	    } = this;

	    if (isAudio && typeof player.brandedSettingsMenu === 'function') {
	      player.brandedSettingsMenu().autoplayMenuItem.selected(autoplay);
	    } else if (typeof player.settingsMenu === 'function') {
	      player.settingsMenu().autoplayMenuItem.selected(autoplay);
	    }
	  }

	  setUpVideoJs_() {
	    const localizations = I18n.translations();

	    for (const lang in localizations) {
	      videojs.addLanguage(lang, localizations[lang]);
	    } // As of Brightcove v5.19.2, `player.error()` no longer pauses playback by default.


	    videojs.hook('beforesetup', (videoEl, options) => {
	      options.errorDisplay = {
	        pauseOnOpen: true
	      };

	      if (this.configs_.chromeless) {
	        // Disable controls
	        videoEl.controls = false;
	        options.controls = false;
	      }

	      return options;
	    });
	  }

	  initPlugins_() {
	    const {
	      configs_: {
	        auth,
	        captions,
	        disableAdSkip,
	        brandConfig: {
	          enableAdCountdown = false
	        } = {},
	        disableFastForwardAndRewind,
	        feedsMenu,
	        logo,
	        settingsMenu = {},
	        disableAutoplayMenu,
	        seekStep,
	        skipInitialFocus,
	        volume,
	        isAudio,
	        playbackRates = [0.5, 1, 1.5, 2]
	      } = {},
	      player,
	      player: {
	        controlBar
	      }
	    } = this;
	    this.initNewRelicOnTrackingEnabled_();

	    if (typeof player.id3 === 'function') {
	      player.id3();
	    }

	    if (videojs.browser.TOUCH_ENABLED && typeof player.contextmenuUI === 'function') {
	      // disable playerInfo modal for touch device that's triggered by long press
	      player.contextmenuUI({
	        content: []
	      });
	    }

	    if (videojs.getComponent('logoLink')) {
	      player.addChild('logoLink', logo, 4
	      /* after text-track-display */
	      );
	    }

	    if (typeof player.captionController === 'function') {
	      player.captionController(captions);
	    }

	    if (typeof player.settingsMenu === 'function' && !isAudio) {
	      player.settingsMenu({ ...settingsMenu,
	        disableAutoplayMenu
	      });
	    } else if (typeof player.brandedSettingsMenu === 'function') {
	      let descendingOrderPlaybackRates;

	      if (isArray$1(playbackRates)) {
	        descendingOrderPlaybackRates = sort(playbackRates).call(playbackRates, (a, b) => b - a);
	      }

	      const brandedSettingsMenuOption = { ...settingsMenu,
	        playbackRates: descendingOrderPlaybackRates
	      };
	      player.brandedSettingsMenu(brandedSettingsMenuOption);
	    }

	    if (feedsMenu && typeof player.streamPicker === 'function') {
	      if (!feedsMenu.auth && auth) {
	        feedsMenu.auth = auth;
	      }

	      player.streamPicker(feedsMenu);
	    }

	    if (this.showCaptionsUI_ && videojs.getComponent('captionSettings')) {
	      player.addChild('captionSettings');
	    }

	    if (typeof player.adUI === 'function') {
	      const {
	        configs_: {
	          brandConfig: {
	            enableGracePeriod,
	            gracePeriodTime
	          } = {}
	        }
	      } = this;
	      player.adUI({
	        disableAdSkip,
	        enableAdCountdown,
	        enableGracePeriod,
	        gracePeriodTime
	      });
	    }

	    if (typeof player.audioContentContainer === 'function' && player.isAudio_) {
	      player.audioContentContainer();
	    }

	    if (typeof controlBar.seekToLive === 'function') {
	      controlBar.seekToLive.hide();
	    } // `fastForward` and `rewind` are defined in the same plugin, so we can
	    // safely assume that if one exists, so does the other.


	    if (videojs.getComponent('fastForward') && !disableFastForwardAndRewind && controlBar) {
	      controlBar.addChild('fastForward', {
	        seekStep
	      }, 2);
	      controlBar.addChild('rewind', {
	        seekStep
	      }, 2);
	    }

	    if (typeof player.volumeMenuButton === 'function') {
	      player.volumeMenuButton(volume);
	    }

	    if (videojs.getPlugin('hotkeys')) {
	      // https://github.com/ctd1500/videojs-hotkeys#options
	      player.hotkeys({
	        seekStep,
	        enableVolumeScroll: false,
	        // disables volume scrolling with mouse
	        enableInactiveFocus: false,
	        // WEBPLAYER-174
	        skipInitialFocus
	      });
	    }
	  }

	  getAdType() {
	    const {
	      player
	    } = this;
	    const currTime = player.currentTime();
	    return currTime === 0 ? 'preroll' : 'midroll';
	  }

	  initEventHandlers_() {
	    const {
	      configs_: {
	        loop
	      } = {},
	      player
	    } = this;
	    this.disposers = this.disposers || [];
	    player.on('error', () => this.handlePlayerErrorEvent_());
	    /*
	      Addresses issue where user could not resume a video after leaving
	      fullscreen mode on iPhone.
	       `usingNativeControls()` is `true` for iPhone, but `false` for iPad,
	      so this only affects iPhone. On iPad, controls _are_ visible, so this
	      isn't necessary.
	    */

	    player.on('touchstart', () => {
	      if (player.paused() && player.usingNativeControls()) {
	        player.play();
	      }
	    });
	    this.disposers.push(...subscribeTo(player, ['waiting', 'ima3-ad-buffering'], evt => {
	      this.coordinator.coordinate('dtci.waiting', evt);
	    }));
	    this.disposers.push(...subscribeTo(player, ['ads-pod-started'], () => {
	      player.addClass('vjs-ad-playing');
	      const adType = this.getAdType();
	      this.coordinator.coordinate('dtci.ads.podStarted', {
	        type: adType
	      });
	    }));
	    this.disposers.push(...subscribeTo(player, ['ads-pod-ended'], () => {
	      const adType = this.getAdType();
	      this.coordinator.coordinate('dtci.ads.podEnded', {
	        type: adType
	      });
	      this.resumePausedVideo();
	      player.removeClass('vjs-ad-playing');
	    }));
	    /*
	      Addresses an issue where the player remains hidden, if an ad doesn't play.
	    */

	    this.disposers.push(...subscribeTo(player, ['adend'], () => {
	      player.removeClass('vjs-ad-loading');
	      this.coordinator.coordinate('dtci.adend');
	      this.resumePausedVideo();
	    }));
	    this.disposers.push(...subscribeTo(player, ['contentplayback'], () => {
	      // Addresses an issue where the control bar is not visible in fullscreen
	      player.one('mouseover', () => player.el().classList.remove('not-hover')); // Addresses an issue where `vjs-ad-playing` is not removed during preroll ad either from ad or network error

	      player.removeClass('vjs-ad-playing');
	    }));

	    const onPlaying = () => this.coordinator.coordinate('dtci.playing');

	    this.disposers.push(...subscribeTo(player, ['play', 'ads-play', 'ads-ad-started'], event => {
	      this.isPlaying = true;

	      if (IS_IOS) {
	        player.addClass('ios-device');
	      }

	      if (event.type === 'play') {
	        this.coordinator.coordinate('dtci.play');
	        /*
	        work around the issue where `playing` event is fired twice after paused
	        This event is triggered when the content playback has started
	        Use this event to detect if the content has started to play (not including ads)
	        */

	        player.one('playing', onPlaying);
	      }
	    }));
	    this.disposers.push(...subscribeTo(player, ['pause', 'ads-pause'], event => {
	      this.isPlaying = false;

	      if (event.type === 'pause') {
	        this.coordinator.coordinate('dtci.pause');
	        player.off('playing', onPlaying);
	      }
	    }));
	    this.disposers.push(...subscribeTo(player, ['dtci.autoplayToggled'], (e, autoplay) => {
	      const fan = new Fan();
	      fan.setAutoStart(autoplay);
	      this.coordinator.coordinate('dtci.autoplayToggled', autoplay);
	    }));
	    this.disposers.push(...subscribeTo(player, ['ended'], () => {
	      if (!player.ads.state || player.ads.state === 'content-playback') {
	        this.coordinator.coordinate('dtci.contentEnded');

	        if (loop) {
	          player.play();
	        }
	      }
	    })); // iOS 11 Safari adds `controls` attribute automatically after exiting from fullscreen

	    this.disposers.push(...subscribeTo(player, ['fullscreenchange'], () => {
	      this.coordinator.coordinate(player.isFullscreen() ? 'dtci.fullscreen.entered' : 'dtci.fullscreen.exited');

	      if (IS_IOS && !player.isFullscreen()) {
	        player.tech().el().controls = false;
	      }
	    }));
	    this.disposers.push(...subscribeTo(player, ['loadstart'], () => this.handlePlayerLoadstartEvent_()));
	    this.coordinator.addEventListener('dtci.concurrencyMonitor.limitReached', () => this.error('STREAM_LIMITED'));
	    this.disposers.push(...subscribeTo(player, ['dtci.captionSettings.closed', 'dtci.captionSettings.opened', 'dtci.socialOverlay.closed', 'dtci.socialOverlay.opened', 'dtci.id3.cueChange', 'dtci.autoplay', 'dtci.autoplay.muted', 'dtci.play.blocked'], (event, payload) => {
	      this.coordinator.coordinate(event.type, payload);
	    })); // Emit player events: DTCIMMP-1417

	    this.disposers.push(...subscribeTo(player, ['ads-ad-started'], () => {
	      const id = this.adId;
	      player.addClass('vjs-ad-playing');

	      if (id) {
	        const adType = this.getAdType();
	        this.coordinator.coordinate('dtci.ads.adStarted', {
	          type: adType,
	          id
	        });
	      }
	    }));
	    this.disposers.push(...subscribeTo(player, ['ads-ad-ended', 'adend', 'ads-ad-skipped'], () => {
	      const id = this.adId;

	      if (id) {
	        const adType = this.getAdType();
	        this.coordinator.coordinate('dtci.ads.adEnded', {
	          type: adType,
	          id
	        });
	      }

	      player.removeClass('vjs-ad-playing');
	    }));
	    this.disposers.push(...subscribeTo(player, ['adserror', 'ima3-ad-error'], () => {
	      player.removeClass('vjs-ad-playing');
	    }));
	    this.disposers.push(...subscribeTo(player, ['ads-play'], () => this.coordinator.coordinate('dtci.ads.play')));
	    this.disposers.push(...subscribeTo(player, ['ads-pause'], () => this.coordinator.coordinate('dtci.ads.pause')));
	    this.disposers.push(...subscribeTo(player, ['ads-ad-skipped'], () => this.coordinator.coordinate('dtci.ads.adSkipped')));
	    this.disposers.push(...subscribeTo(player, ['dispose'], () => this.coordinator.coordinate('dtci.dispose')));
	    this.disposers.push(...subscribeTo(player, ['seeking'], () => this.coordinator.coordinate('dtci.seeking')));
	    this.disposers.push(...subscribeTo(player, ['seeked'], () => this.coordinator.coordinate('dtci.seeked')));
	    this.disposers.push(...subscribeTo(player, ['timeupdate'], (evt, evtData = {}) => {
	      const {
	        currentTime,
	        type
	      } = evtData;
	      const coordinatedData = {
	        currentTime: currentTime || player.currentTime()
	      };

	      if (type) {
	        coordinatedData.type = type;
	      }

	      this.coordinator.coordinate('dtci.timeupdate', coordinatedData);
	    }));

	    if (this.configs_.chromeless) {
	      player.addClass('espn-chromeless'); // We use this to enforce controls remaining hidden.

	      this.disposers.push(...subscribeTo(player, ['controlsenabled'], () => player.controls(false)));

	      if (player.controlBar) {
	        player.controlBar.el().setAttribute('aria-hidden', 'true');
	      }

	      if (!this.showCaptionsUI_) {
	        // if we're surpressing text tracks for ambient video, consider
	        // the video decorative and indicate that by setting root element
	        // aria-hidden to "true" -- SEWEB-25685
	        player.el().setAttribute('aria-hidden', 'true');
	      }
	    } // During pre-roll, the content player is paused behind the ad player. When
	    // playing a live stream, the content player doesn't always resume after
	    // the pre-roll. This ensures that playback resumes after pre-roll ads.


	    this.disposers.push(...subscribeTo(player, ['ads-allpods-completed'], () => {
	      this.resumePausedVideo();
	    }));
	    this.disposers.push(...subscribeTo(player, ['volumechange'], () => {
	      const volume = player.volume();
	      let data;

	      if (!player.muted()) {
	        data = {
	          value: volume,
	          muted: false
	        };
	      } else {
	        data = {
	          value: volume,
	          muted: true
	        };
	      }

	      this.coordinator.coordinate('dtci.volumeChanged', data);
	    }));
	    player.ready(() => {
	      this.setSizeClass();
	      window.addEventListener('resize', this.debouncedSetSizeClass);
	      this.coordinator.coordinate('dtci.embedded');
	      this.initAccessibiltyEnhancements();
	    });
	  }
	  /**
	   * Makes a `player_.play()` call if paused. If the play call fails, it attempts to mute the player and play again
	   *
	   * @param {number} [timeout=PLAY_PAUSED_DELAY]
	   * @returns {Promise}
	   * @memberof VideoJsAdapter
	   */


	  resumePausedVideo(timeout = PLAY_PAUSED_DELAY) {
	    return new promise((resolve, reject) => {
	      var _context5;

	      this.resumePausedTimeouts_.push(setTimeout$1(bind(_context5 = function doResume() {
	        const {
	          player_
	        } = this;

	        if (!player_) {
	          reject(new Error('no player instance to resume'));
	        } else if (player_.paused()) {
	          player_.play().then(resolve).catch(function tryPlayingMuted() {
	            // often a `play()` fails when it's trying to autoplay an unmuted video when the browser won't allow it...
	            // so try muting
	            player_.muted(true); // and attempt playing the video again

	            player_.play().then(resolve).catch(reject);
	          });
	        } else {
	          resolve();
	        }
	      }).call(_context5, this), timeout));
	    });
	  }

	  initAccessibiltyEnhancements() {
	    const {
	      player
	    } = this;
	    const playerEl = player && player.el();
	    const controlBar = player && player.controlBar;
	    const playButton = controlBar && controlBar.playToggle.el();

	    if (!playerEl) {
	      throw new Error('cannot find player element');
	    }

	    this.humanizeLabels = {
	      hours: player.localize('hours'),
	      hour: player.localize('hour'),
	      minutes: player.localize('minutes'),
	      minute: player.localize('minute'),
	      seconds: player.localize('seconds'),
	      second: player.localize('second'),
	      hours_minutes_seconds_format: player.localize('hours_minutes_seconds_format'),
	      minutes_seconds_format: player.localize('minutes_seconds_format')
	    };
	    this.disposers = this.disposers || []; // Main video display is an interactive element, so it should be in tab order

	    playerEl.setAttribute('tabindex', '0'); // Accessibility changes based on player events
	    // ...Accessibility updates when ad plays

	    this.disposers.push(...subscribeTo(player, ['ads-ad-started', 'ads-play'], () => {
	      const adPlayBtn = playerEl && playerEl.querySelector(AD_PLAY_BTN_SELECTOR);

	      if (adPlayBtn) {
	        adPlayBtn.setAttribute('tabindex', '0');
	      }

	      this.updateAriaLabels('Play', 'ads', adPlayBtn);
	    })); // ...Accessibility updates when ad pauses

	    this.disposers.push(...subscribeTo(player, ['ads-pause'], () => {
	      const adPlayBtn = playerEl && playerEl.querySelector(AD_PLAY_BTN_SELECTOR);
	      this.updateAriaLabels('Pause', 'ads', adPlayBtn);
	    })); // ...Accessibility updates when video pauses

	    this.disposers.push(...subscribeTo(player, ['pause'], () => {
	      this.updateAriaLabels('Pause', 'content', playButton);
	    })); // ...Accessibility updates when video plays or resumes

	    this.disposers.push(...subscribeTo(player, ['play', 'mediachange'], () => {
	      const setLabel = () => {
	        this.updateAriaLabels('Play', 'content', playButton);
	      }; // once the video gets triggered to play, wait until we actually detect playing started, then update aria-labels


	      this.disposers.push(...subscribeTo(player, ['playing'], setLabel, {
	        bindTo: 'one'
	      }));
	    })); // re-label aria-label based on current media item

	    this.disposers.push(...subscribeTo(player, ['loadedmetadata'], () => {
	      const mediaItem = player && player.mediaItem;
	      const videoPlayer = player && player.localize('Video Player');
	      const title = mediaItem && mediaItem.title ? `${videoPlayer}: ${mediaItem.title}` : videoPlayer;

	      if (player) {
	        player.setAttribute('aria-label', title);
	      }
	    })); // when user clicks, remove "using-keyboard" class to avoid showing outlines

	    this.disposers.push(...subscribeTo(playerEl, ['click'], this.setUsingMouse_, {
	      bindTo: 'addEventListener',
	      unbindTo: 'removeEventListener'
	    })); // when user uses keyboard within the player, add "using-keyboard" class so we know to show focus outlines
	    // videojs stops propagation of `keydown`, so this listener only works when tabbing
	    // -into- the player, `keyup` works when tabbing within the player

	    this.disposers.push(...subscribeTo(document, ['keydown', 'keyup'], this.setUsingKeyboard_, {
	      bindTo: 'addEventListener',
	      unbindTo: 'removeEventListener'
	    }));
	  }

	  setUsingKeyboard_(evt = {}) {
	    const {
	      player
	    } = this;
	    const {
	      target
	    } = evt;
	    const playerEl = player && player.el();
	    const focusedInPlayer = playerEl && playerEl.contains && playerEl.contains(target);

	    if (focusedInPlayer) {
	      playerEl.classList.add('using-keyboard');
	    }
	  }

	  setUsingMouse_(evt = {}) {
	    const {
	      player
	    } = this;
	    const playerEl = player && player.el();
	    const {
	      screenX,
	      screenY
	    } = evt; // vjs creates synthetic clicks for some keyboard events w/ coordinates at { 0, 0 }, ignore these

	    if ((screenX || screenY) && playerEl) {
	      playerEl.classList.remove('using-keyboard');
	    }
	  }

	  updateAriaLabels(playState, contentType = 'content', buttonEl) {
	    const {
	      player
	    } = this;
	    const isPlaying = playState === 'Play';
	    const currentTime = Math.floor(player.currentTime()) || 0;
	    const duration = Math.floor(player.duration()) || 0;
	    const startStatus = isPlaying ? player.localize('Playing') : player.localize('Pausing');
	    const buttonStatus = isPlaying ? player.localize('Pause') : player.localize('Play');
	    let label = `${startStatus} ${contentType}.`;

	    if (currentTime > 0 && currentTime < Infinity && duration > 0 && duration < Infinity && !isPlaying) {
	      const humanTime = humanizeDuration(currentTime * 1000, this.humanizeLabels);
	      const humanDuration = humanizeDuration(duration * 1000, this.humanizeLabels);
	      label += ` ${humanTime} ${player.localize('elapsed out of')} ${humanDuration}.`;
	    } // Append after elapsed time


	    label += ` ${buttonStatus} ${player.localize('Button')}.`;

	    if (buttonEl) {
	      buttonEl.setAttribute('aria-label', label);
	    }
	  }

	  handlePlayerErrorEvent_() {
	    const {
	      player
	    } = this;
	    const interval = 30;
	    const error = player.error();

	    if (error) {
	      var _context6;

	      // Ensure an ad is not playing behind the error overlay.
	      // Shouldn't be necessary but I've seen cases where an ad continues playing under an error message.
	      if (player.ads && typeof player.ads.isAdPlaying === 'function' && player.ads.isAdPlaying()) {
	        player.pause();

	        if (player.ima3 && player.ima3.adPlayer) {
	          player.ima3.adPlayer.pause();
	        }

	        if (player.ima && typeof player.ima.pauseAd === 'function') {
	          player.ima.pauseAd();
	        }
	      } // Shaka player (used for DRM) raises 1001, similar to VideoJS's -2


	      if (error.code === -2 || error.code === 1001) {
	        if (this.lastErrorTime_) {
	          // if the error has re-occured within the interval
	          if (now() - this.lastErrorTime_ < interval * 1000) {
	            // make sure we don't loop
	            this.lastErrorTime_ = 0;
	            player.reset();
	            player.error(error);
	            this.coordinator.coordinate('dtci.error', error);
	          }
	        }

	        if (this.lastErrorTime_ !== 0) this.lastErrorTime_ = now();
	      } else if (error.message === 'DRM_REQUIRED' || indexOf(_context6 = [1002, 3016, 4012, 6001, 6004, 6007, 6008]).call(_context6, error.code) > -1) {
	        // `DRM_REQUIRED` is returned by Shield when the content requires a `drmSupport` param, but none was provided
	        // The error codes are raised by the Shaka player; more info: https://github.com/google/shaka-player/blob/master/docs/tutorials/faq.md
	        this.coordinator.coordinate('dtci.drm.error', error);
	      } else {
	        this.coordinator.coordinate('dtci.error', error);
	      }
	    }
	  }

	  handlePlayerLoadstartEvent_() {
	    const {
	      player
	    } = this;
	    const hlsTech = player.tech({
	      IWillNotUseThisInPlugins: true
	    }).vhs;

	    if (player.dash && player.dash.mediaPlayer) {
	      const {
	        updateSettings,
	        getProtectionController
	      } = player.dash.mediaPlayer;

	      if (typeof updateSettings === 'function') {
	        const targetLatency = _parseFloat('1', 10);

	        const minDrift = _parseFloat('0.05', 10);

	        const catchupPlaybackRate = _parseFloat('0.1', 10);

	        const liveCatchupLatencyThreshold = _parseFloat('10', 10);

	        updateSettings({
	          streaming: {
	            liveDelay: targetLatency,
	            liveCatchup: {
	              minDrift,
	              playbackRate: catchupPlaybackRate,
	              latencyThreshold: liveCatchupLatencyThreshold
	            }
	          }
	        });
	      }

	      if (typeof getProtectionController === 'function') {
	        const {
	          setRobustnessLevel
	        } = getProtectionController();

	        if (typeof setRobustnessLevel === 'function') {
	          setRobustnessLevel('SW_SECURE_CRYPTO');
	        }
	      }
	    } // Check for the HLS plugin. Safari supports HLS natively, so the plugin doesn't get loaded.


	    if (hlsTech) {
	      // start live playback 4 fragments from the end of the playlist (default 3)
	      videojs.Vhs.Playlist.UNSAFE_LIVE_SEGMENTS = 4; // Send cookies (by setting `withCredentials`) only for `generateKey` request from Akamai

	      hlsTech.xhr.beforeRequest = options => {
	        const rex = new RegExp('generateKey');

	        if (rex.test(options.uri)) {
	          options.withCredentials = true;
	        }
	      };
	    }

	    if (IS_MOBILE) {
	      // Hide the volume slider, but show the mute button.
	      player.controlBar.volumePanel.volumeControl.hide();
	    }

	    if (player.dash && player.dash.shakaPlayer) {
	      player.dash.shakaPlayer.configure({
	        // https://espn.slack.com/archives/CLRUZSTAL/p1567698463210900
	        // Make Shaka player start with the lowest rendition and work its way up from there.
	        // Improves initial performance on Android Chrome.
	        abr: {
	          defaultBandwidthEstimate: 1
	        },
	        // https://jira.disney.com/browse/WEBPLAYER-275
	        // Override Shaka's default retry logic and raise a -2
	        streaming: {
	          failureCallback(error) {
	            console.error('shakaPlayer failureCallback error: ', error);
	            player.error({
	              code: -2
	            });
	          }

	        }
	      });
	    }
	  }

	  initNewRelicOnTrackingEnabled_() {
	    const {
	      player
	    } = this;
	    const {
	      analytics: {
	        newRelic
	      } = {},
	      drmTesting
	    } = this.configs_ || {};
	    this.isNRtrackingEnabled_ = newRelic && newRelic.enabled && !drmTesting;

	    if (this.isNRtrackingEnabled_) {
	      this.newRelic_ = newRelic;
	      initNewRelicTracking(player, newRelic);
	    }
	  }

	  autoplay(value) {
	    let value_;

	    if (value != null) {
	      value_ = value ? 'any' : false;
	    }

	    value_ = IS_IOS && value ? 'muted' : value_;
	    return this.player.autoplay(value_);
	  }

	  async play() {
	    const {
	      player
	    } = this;

	    if (player) {
	      const playerType = this.getPlayerType_(player);

	      try {
	        const isPlayerMuted = player.muted();

	        if (playerType === PLAYER_TYPE.ima3AdPlayer) {
	          player.ima3.adPlayer.play(); // ima3.adPlayer.play is function, not a promise, but if it gets here, we got playback

	          this.emitAutoPlayEvent_(isPlayerMuted);
	        } else if (playerType === PLAYER_TYPE.imaAdPlayer) {
	          player.ima.resumeAd(); // player.ima.resumeAd is function, not a promise, but if it gets here, we got playback

	          this.emitAutoPlayEvent_(isPlayerMuted);
	        } else {
	          const res = await this.handlePlayerPlayPromise_();

	          if (res !== true) {
	            throw new Error('handlePlayerPlayPromise_ failed');
	          }
	        }

	        return promise.resolve();
	      } catch (error) {
	        console.error(`dtci.play.blocked, playerType = ${playerType}, error: `, error); // use player.trigger instead of this.coordinator.coordinate so that it works on Conviva plugin event listener

	        player.trigger('dtci.play.blocked', {
	          error,
	          playerType
	        });
	        return promise.reject(error);
	      }
	    }

	    return promise.reject(new Error('Player is not ready'));
	  }

	  pause() {
	    const {
	      player
	    } = this;

	    if (player) {
	      const playerType = this.getPlayerType_(player);

	      if (playerType === PLAYER_TYPE.ima3AdPlayer) {
	        player.ima3.adPlayer.pause();
	      } else if (playerType === PLAYER_TYPE.imaAdPlayer) {
	        player.ima.pauseAd();
	      } else {
	        player.pause();
	      }
	    }

	    return this;
	  }

	  getPlayerType_(player) {
	    let playerType = PLAYER_TYPE.videoPlayer;

	    if (this.isInAdMode) {
	      const {
	        ima3: {
	          adPlayer
	        } = {},
	        ima
	      } = player;

	      if (adPlayer && typeof adPlayer.duration === 'function' && adPlayer.duration() !== 0) {
	        playerType = PLAYER_TYPE.ima3AdPlayer;
	      } else if (ima && typeof ima.pauseAd === 'function' && typeof ima.resumeAd === 'function') {
	        playerType = PLAYER_TYPE.imaAdPlayer;
	      }
	    }

	    return playerType;
	  }

	  emitAutoPlayEvent_(isPlayerMuted) {
	    if (isPlayerMuted) {
	      this.coordinator.coordinate('dtci.autoplay.muted');
	    } else {
	      this.coordinator.coordinate('dtci.autoplay');
	    }
	  }

	  async handlePlayerPlayPromise_() {
	    let playResult = false;
	    const {
	      player
	    } = this;

	    try {
	      await player.play();
	      playResult = true; // if we make it to this line, the play worked!
	    } catch (err) {
	      playResult = err;
	    }

	    if (playResult === true) {
	      this.emitAutoPlayEvent_(player.muted());
	    }

	    return playResult;
	  }

	  muted(value) {
	    const {
	      player
	    } = this;

	    if (player) {
	      if (typeof value === 'undefined') {
	        return player.muted();
	      }

	      const muteValue = player.muted(value);
	      const {
	        adPlayer
	      } = this.player.ima3 || {};

	      if (adPlayer && typeof adPlayer.muted === 'function') {
	        adPlayer.muted(value);
	      } // I don't think there is a mechanism on videojs-ima for accessing mute values


	      return muteValue;
	    }

	    return this;
	  }

	  onFatalErrorDisposePlayer() {
	    const {
	      player
	    } = this;

	    if (!player) {
	      return;
	    }

	    const playerParent = document.querySelector(`#${player.id()}`).parentElement;
	    const playerSupport = document.createElement('div');
	    playerSupport.className = player.contentEl().className;
	    const errorMessage = document.querySelector('.vjs-error-display.vjs-modal-dialog').cloneNode(true);
	    this.dispose();
	    playerParent.appendChild(playerSupport);
	    playerSupport.appendChild(errorMessage);
	    this.player = null;
	  }

	  thumbnails(previews) {
	    const {
	      player
	    } = this;

	    if (typeof player.thumbnails !== 'function') {
	      return;
	    }

	    if (player.controlBar && player.controlBar.progressControl.$('.vjs-thumbnail-holder')) {
	      player.thumbnails().updatePreviews(previews);
	    } else {
	      player.thumbnails(previews);
	    }

	    player.thumbnailTime();
	  }

	  social(options) {
	    const {
	      player
	    } = this;

	    if ((!options || typeof player.social !== 'function') && !this.configs_.isAudio) {
	      return null;
	    }

	    if ((!options || typeof player.brandedSocial !== 'function') && this.configs_.isAudio) {
	      return null;
	    }

	    if (!this.dtciSocial) {
	      if (this.configs_.isAudio) {
	        this.dtciSocial = player.brandedSocial(options);
	      } else {
	        this.dtciSocial = player.social(options);
	      }
	    } else {
	      this.dtciSocial.options = options;
	    }

	    return this.dtciSocial;
	  }

	  endcard(clip, options = {}) {
	    var _context7;

	    const getNextContent = this.getNextContent(clip);

	    const timeoutHandler = bind(_context7 = this.onTimeoutHandler).call(_context7, this);

	    const {
	      timeout,
	      autoplay
	    } = options;

	    if (this.player.endcard && typeof this.player.endcard === 'function') {
	      this.player.endcard().updateOptions({
	        clip,
	        getNextContent,
	        timeout,
	        autoplay,
	        timeoutHandler
	      });
	    }
	  }

	  onTimeoutHandler(mediaItem, wasManual) {
	    if (mediaItem) {
	      const {
	        player,
	        configs_: {
	          disableAdobe,
	          disableNielsen
	        } = {}
	      } = this;
	      const playerAutoplay = !!(player && typeof player.autoplay === 'function' && player.autoplay());
	      const analyticsEnabled = !disableAdobe && !disableNielsen;
	      this.startType = wasManual ? 'manual:endcard_continuous' : 'endcard_continuous';
	      mediaItem.startType = this.startType;

	      if (mediaItem.link) {
	        localStorage.setItem('endcardNextItem', mediaItem.link.id);
	        const nextUrl = document.location.hostname === 'local.espn.com' ? `${document.location.origin}/entertainment.html?origin=endcard&tech=videojs` // Origin for test harness is different
	        : document.location.origin + mediaItem.link.urlValue;
	        window.top.location.href = nextUrl;
	      }

	      if (analyticsEnabled) {
	        this.analytics.adobeDCR({
	          ESPN_CUSTOM_METADATA: {
	            startType: this.startType
	          }
	        });
	        this.analytics.conviva({
	          startType: this.startType
	        });
	      } // The client provides a new `mediaItem` in `getNextContent` interceptor without knowing
	      // if and when the video player will actually play it. Here we know the player is about
	      // to play this next `mediaItem`, so let the client know, so it can do updates outside
	      // of the player if needed


	      this.coordinator.coordinate('dtci.loaded', mediaItem);

	      if (!mediaItem.link) {
	        this.clipLoadedCallback(mediaItem);
	      }

	      if (!playerAutoplay) {
	        // if autoplay was off, but endcard.autoplay was true, set player.autoplay to true the rest of continuous play
	        player.autoplay(true);
	      }
	    }
	  }

	  watchLoadedCallback(mediaItem, playbackSession) {
	    const {
	      player
	    } = this;
	    super.watchLoadedCallback(mediaItem, playbackSession);
	    /*
	      Seek to live point on play if the source is live. This prevents DVR-
	      like behavior for live streams.
	    */

	    if (mediaItem && mediaItem.isLive && player) {
	      player.on('play', () => {
	        if (player.seekable().length > 0 && player.mediainfo.live) {
	          player.currentTime(player.seekable().end(0));
	        }
	      });
	    }
	  }

	  setSizeClass() {
	    const {
	      player
	    } = this;
	    const playerWidth = player && player.currentWidth() || -1;

	    if (playerWidth >= 900) {
	      player.addClass('desktop-view');
	    } else {
	      player.removeClass('desktop-view');
	    }

	    if (playerWidth > 480 && playerWidth < 900) {
	      player.addClass('mobile-landscape');
	    } else {
	      player.removeClass('mobile-landscape');
	    }

	    if (playerWidth <= 480) {
	      player.addClass('mobile-portrait');
	    } else {
	      player.removeClass('mobile-portrait');
	    }
	  }

	  dispose() {
	    const {
	      player,
	      disposers,
	      resumePausedTimeouts_
	    } = this;
	    window.removeEventListener('resize', this.debouncedSetSizeClass);

	    if (resumePausedTimeouts_ && resumePausedTimeouts_ instanceof Array) {
	      forEach(resumePausedTimeouts_).call(resumePausedTimeouts_, function clearResumePausedTimeout(resumePausedTimeouts) {
	        clearTimeout(resumePausedTimeouts);
	      });

	      this.resumePausedTimeouts_ = [];
	    } // Prevent to dispose player multiple times


	    if (!this.isDisposed) {
	      if (player) {
	        try {
	          player.dispose();
	          this.isDisposed = true;
	        } catch (err) {
	          console.error(err);
	        }

	        if (disposers && disposers.length) {
	          forEach(disposers).call(disposers, disposer => disposer());
	        }

	        this.disposers = null;
	      }

	      super.dispose.apply(this);
	    }
	  }

	  static loadTech(options = {}) {
	    if (window.videojs) {
	      VideoJsAdapter.techLoadedPromise = promise.resolve();
	    }

	    if (VideoJsAdapter.techLoadedPromise) {
	      return VideoJsAdapter.techLoadedPromise;
	    }

	    const {
	      playerBaseUrl = `https://assets.espn.com/players/web-player-bundle/${"3.3.40"}/`,
	      unminified = false
	    } = options;
	    const techUrl = `${playerBaseUrl}dtci.video${unminified ? '' : '.min'}.js`;
	    VideoJsAdapter.techLoadedPromise = loadScript.url(techUrl);
	    return VideoJsAdapter.techLoadedPromise;
	  }

	}

	VideoJsAdapter.techLoadedPromise = null;

	class BrightcoveAdapter extends VideoJsAdapter {
	  constructor(element, configs = {}, coordinator) {
	    super(element, configs, coordinator);
	    const {
	      player
	    } = this; // video-monitor.html swaps in vanilla VJS for the BC player, so `bcinfo` may not always be available

	    player.bcinfo = player.bcinfo || {};
	    player.bcinfo.applicationId = `espn-web-player-bundle@v${"3.3.40"}`;
	    this.mergeAdsConfig_();
	  }

	  get tech() {
	    return window.BrightcovePlayer || window.bc;
	  }

	  get playerName() {
	    const bcAnalyticsSettings = this.bcAnalyticsSettings_();
	    return bcAnalyticsSettings && bcAnalyticsSettings.playerName;
	  }

	  get platformVersion() {
	    const bcAnalyticsSettings = this.bcAnalyticsSettings_();
	    const bcVersion = bcAnalyticsSettings && bcAnalyticsSettings.platformVersion;
	    return `bundle: v${"3.3.40"} - BC: ${BrightcoveAdapter.playerId}@${bcVersion}`;
	  }

	  bcAnalyticsSettings_() {
	    return this.player.bcAnalytics && this.player.bcAnalytics.settings;
	  }

	  mergeAdsConfig_() {
	    const adProvider = this.configs_ && this.configs_.adProvider;

	    if (adProvider) {
	      const options = adProvider.options || {};
	      this.configs_.adProvider = {
	        options,
	        provider: adProvider.provider || 'Google'
	      };
	    }
	  }

	  static loadTech(options = {}, brandConfig = {}) {
	    if (window.BrightcovePlayer) {
	      BrightcoveAdapter.techLoadedPromise = promise.resolve();
	    }

	    if (BrightcoveAdapter.techLoadedPromise) {
	      return BrightcoveAdapter.techLoadedPromise;
	    }

	    const playerId = BrightcoveAdapter.getPlayerId(options, brandConfig) || 'aqgsinRY0_default';
	    BrightcoveAdapter.playerId = playerId;
	    const {
	      accountId = '3948005062001',
	      unminified = false
	    } = options;
	    const techUrl = `https://players.brightcove.net/${accountId}/${playerId}/index${unminified ? '' : '.min'}.js`;

	    const scriptLoaded = loadScript.url(techUrl) || promise.resolve();

	    scriptLoaded.then(function renameBrightcoveNamespace() {
	      const win = window;

	      if (win && win.bc) {
	        win.BrightcovePlayer = win.bc;
	      }
	    });
	    BrightcoveAdapter.techLoadedPromise = scriptLoaded;
	    return scriptLoaded;
	  }

	  static getPlayerId(options = {}, brandConfig = {}) {
	    const {
	      type,
	      hasDRM,
	      playerId
	    } = options;
	    const id = playerId || brandConfig.playerId;

	    if (!id) {
	      const isVideoHasDRM = type === 'video' && hasDRM;
	      const isVideoNoDRM = type === 'video' && !hasDRM;
	      const isAudioHasDRM = type === 'audio' && hasDRM;
	      const isAudioNoDRM = type === 'audio' && !hasDRM;

	      switch (true) {
	        case isVideoHasDRM:
	          return 'aqgsinRY0_default';

	        case isVideoNoDRM:
	          return 'Yo9Nxoqv9_default';

	        case isAudioHasDRM:
	          return '8mRX4ixi7Y_default';

	        case isAudioNoDRM:
	          return 'i8dWsOdVt_default';

	        default:
	          return null;
	      }
	    }

	    return id;
	  }

	}

	BrightcoveAdapter.techLoadedPromise = null;

	const PLAYER_CONFIG_URL_QA = 'https://api.config.watchabc.go.com/appsconfig/qa/js-mmp-espn/001/1.0.0/config.json';
	const PLAYER_CONFIG_URL_PROD = 'https://api.config.watchabc.go.com/appsconfig/prod/js-mmp-espn/001/1.0.0/config.json';

	class BootstrapConfig {
	  get configuration() {
	    return this.configuration_;
	  }

	  set configuration(v) {
	    this.configuration_ = v;
	  }

	  constructor(configuration) {
	    this.configuration_ = null;
	    this.configuration = configuration;
	  }

	  async getBootstrapConfig() {
	    const url = this.getBootstrapConfigUrl(this.configuration);
	    const result = await fetchServices({
	      url,
	      method: 'GET'
	    });

	    if (result && result.success) {
	      return result.response;
	    }

	    return null;
	  }

	  getBootstrapConfigUrl(config) {
	    const isApiForQA = this.isApiForQA_(config);
	    const url = isApiForQA ? PLAYER_CONFIG_URL_QA : PLAYER_CONFIG_URL_PROD;
	    return url;
	  }

	  isApiForQA_(config) {
	    const {
	      api: {
	        apienv = ''
	      } = {}
	    } = config || {};

	    if (apienv.toLowerCase() === 'qa') {
	      return true;
	    }

	    const regex = /(?=.*apienv=qa)/i;
	    const url = window && window.location.href && window.location.href;
	    return url && url.match(regex) !== null;
	  }

	  mergeNewRelicConfig(bootstrapConfig) {
	    const newRelicConfig = this.getNewRelicConfig(bootstrapConfig);

	    if (this.configuration.analytics) {
	      this.configuration.analytics = { ...this.configuration.analytics,
	        newRelic: { ...newRelicConfig,
	          ...this.configuration.analytics.newRelic
	        }
	      };
	    } else {
	      this.configuration.analytics = {
	        newRelic: newRelicConfig
	      };
	    }

	    return this.configuration;
	  }

	  getNewRelicConfig(bootstrapConfig) {
	    const {
	      features: {
	        analytics: {
	          newRelic
	        } = {}
	      } = {}
	    } = bootstrapConfig || {};
	    return newRelic;
	  }

	}

	function buildAuthorizationPayload(payload, mediaItem) {
	  const {
	    accountId,
	    authenticationType,
	    customData: {
	      resource,
	      token,
	      tokenType,
	      zipcode,
	      mvpd
	    } = {},
	    provider
	  } = payload || {};
	  const customData = {
	    resource,
	    token,
	    tokenType,
	    zipcode,
	    mvpd
	  };
	  const authenticatedProvider = new AuthenticatedProvider(provider, provider, null, null);
	  let authType = authenticationType;

	  if (mediaItem && mediaItem.authenticationTypes) {
	    authType = getAuthenticationType(mediaItem, tokenType);
	  }

	  return new AuthorizationPayload(authType, authenticatedProvider, accountId, customData);
	}

	function injectPlayerBundleCssIntoDom() {
	  try {
	    const {
	      location: {
	        host
	      } = {}
	    } = window || {};
	    let playerBaseUrl = `https://assets.espn.com/players/web-player-bundle/${"3.3.40"}/`;

	    if (host === 'local.espn.com:9000') {
	      playerBaseUrl = './';
	    }

	    const noPlayerCss = !document.querySelector('link[href*=espn-web-player-bundle]');

	    if (noPlayerCss) {
	      const playerStyles = document.createElement('link');
	      playerStyles.id = 'web_player_css';
	      playerStyles.rel = 'stylesheet';
	      playerStyles.href = `${playerBaseUrl}espn-web-player-bundle.css`;
	      document.head.appendChild(playerStyles);
	    }
	  } catch (err) {
	    console.error(`injectPlayerBundleCssIntoDom error: ${err}`);
	  }
	}

	/**
	 * The DTCIVideoPlayer class.
	 * @class
	 */

	class DTCIVideoPlayer {
	  /**
	   * @param {(string|Element)}  the DOM element where the player will be embedded
	   * @param {Object}      [techOptions]
	   */
	  constructor(element, techOptions = {}) {
	    this.Adapter_ = null;
	    this.type_ = undefined;
	    this.element_ = Object.prototype.toString.call(element) === '[object String]' ? document.getElementById(element) : element;

	    if (!this.element_) {
	      throw new Error('element MUST be an HTML element or a valid selector');
	    }

	    if (this.element_.parentNode) {
	      this.container_ = this.element_.parentNode;
	      this.containerClone_ = this.container_.cloneNode(true);
	    }

	    DTCIVideoPlayer.techLoadedPromise = new promise((resolve, reject) => {
	      this.resolveTechLoadedPromise_ = resolve;
	      this.rejectTechLoadedPromise_ = reject;
	    });
	    this.techOptions = techOptions;
	    this.coordinator = new EventCoordinator();
	    this.type = techOptions.type; // player css will be removed when player is disposed. We may need to inject it again if css is removed.

	    injectPlayerBundleCssIntoDom();
	  }

	  set Adapter(v) {
	    this.Adapter_ = v;
	  }

	  get Adapter() {
	    return this.Adapter_;
	  }

	  set type(v) {
	    this.type_ = v;
	  }

	  get type() {
	    return this.type_;
	  }

	  get bundle() {
	    return this.bundle_;
	  }

	  set bundle(value) {
	    this.bundle_ = value;
	    return this.bundle_;
	  }

	  get isPlaying() {
	    return this.bundle && this.bundle.isPlaying;
	  }

	  get adId() {
	    return this.bundle && this.bundle.adId;
	  }

	  get mediaItem() {
	    return this.bundle && this.bundle.mediaItem;
	  }

	  get playerName() {
	    return this.bundle && this.bundle.playerName;
	  }

	  get platformVersion() {
	    return this.bundle && this.bundle.platformVersion;
	  }

	  async load(loadRequest) {
	    const {
	      advertisingInfo,
	      authorizationPayload,
	      configuration,
	      identifier,
	      mediaItem
	    } = loadRequest;
	    configuration.advertisingInfo = advertisingInfo; // Prevents duplicated tracks,
	    // html5 is used by videojs to set some user configurations for UX, for more info please go to
	    // https://docs.videojs.com/tutorial-text-tracks.html#emulated-text-tracks

	    if (!configuration.html5) {
	      configuration.html5 = {
	        nativeTextTracks: true
	      };
	    }

	    if (authorizationPayload instanceof AuthorizationPayload) {
	      configuration.authorizationPayload = authorizationPayload;
	    } else {
	      configuration.authorizationPayload = buildAuthorizationPayload(authorizationPayload, mediaItem);
	    }

	    configuration.identifier = identifier;
	    configuration.mediaItem = mediaItem;
	    configuration.type = this.type;

	    if (mediaItem) {
	      configuration.isAudio = mediaItem.type === 'audio';

	      if (!configuration.brand) {
	        configuration.brand = mediaItem.brand;
	      }
	    }

	    return this.initBundleOrUpdateConfigs_(configuration);
	  }

	  async initBundleOrUpdateConfigs_(configuration) {
	    const noBundle = !DTCIVideoPlayer.loadedPromise || DTCIVideoPlayer.loadedPromise && !this.bundle;

	    if (noBundle) {
	      const bootstrap = new BootstrapConfig(configuration);
	      this.bootstrapConfig = await bootstrap.getBootstrapConfig();

	      if (this.bootstrapConfig && this.bootstrapConfig.brands) {
	        configuration.brandConfig = this.bootstrapConfig.brands[configuration.brand];
	      }
	      /**
	       * Bundle is not present that is because either player script is not loaded or
	       * bundle is disposed by calling player unembed. On either case, we need to
	       * to initialize the bundle
	       */


	      const techLoadedPromise = await this.getTechLoadedPromise(configuration.brandConfig);

	      if (techLoadedPromise || !this.bundle) {
	        const mergedConfig = this.mergeBootstrapConfig(bootstrap, configuration);
	        this.bundle = new this.Adapter(this.element_, mergedConfig, this.coordinator);
	        DTCIVideoPlayer.loadedPromise = true;
	        return this.bundle;
	      }
	    } else if (this.bundle) {
	      this.bundle.updateConfiguration(configuration);
	      this.updateAnalytics({ ...configuration.analytics
	      });
	    }

	    return this;
	  }

	  async getTechLoadedPromise(brandConfig) {
	    let result;
	    const {
	      techOptions
	    } = this;

	    switch (techOptions.tech) {
	      case 'videojs':
	        this.Adapter = VideoJsAdapter;
	        break;

	      default:
	        this.Adapter = BrightcoveAdapter;
	    }

	    try {
	      result = await this.Adapter.loadTech(techOptions, brandConfig);
	    } catch (err) {
	      this.rejectTechLoadedPromise_(err);
	    }

	    this.resolveTechLoadedPromise_(result);
	    return DTCIVideoPlayer.techLoadedPromise;
	  }

	  mergeBootstrapConfig(bootstrap, configuration) {
	    const {
	      bootstrapConfig
	    } = this;

	    if (bootstrapConfig) {
	      const {
	        webservices: {
	          shield: {
	            palEnabled
	          } = {}
	        } = {}
	      } = bootstrapConfig;
	      const {
	        api
	      } = configuration;
	      const mergedConfig = bootstrap.mergeNewRelicConfig(bootstrapConfig);

	      if (api && api.palEnabled === undefined) {
	        api.palEnabled = palEnabled;
	      }

	      return mergedConfig;
	    }

	    return configuration;
	  }

	  updateAnalytics(configs) {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.updateAnalytics(configs);
	  }

	  addEventListener(event, listener) {
	    this.coordinator.addEventListener(event, listener);
	    return this;
	  }

	  addEventInterceptor(event, interceptor) {
	    this.coordinator.addEventInterceptor(event, interceptor);
	    return this;
	  }

	  removeEventListener(event, listener) {
	    this.coordinator.removeEventListener(event, listener);
	    return this;
	  }

	  removeEventInterceptor(event) {
	    this.coordinator.removeEventInterceptor(event);
	    return this;
	  }

	  async play() {
	    const {
	      bundle
	    } = this;

	    if (bundle) {
	      try {
	        return await bundle.play();
	      } catch (error) {
	        return promise.reject(error);
	      }
	    }

	    return promise.reject(new Error('Player bundle is not ready'));
	  }

	  pause() {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.pause();
	  }

	  muted(value) {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.muted(value);
	  }

	  currentTime(value) {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.currentTime(value);
	  }

	  autoplay() {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.autoplay();
	  }

	  currentType() {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.currentType();
	  }

	  playbackRate() {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.playbackRate();
	  }

	  duration() {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.duration();
	  }

	  language() {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.language();
	  }

	  requestFullscreen() {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.requestFullscreen();
	  }

	  exitFullscreen() {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.exitFullscreen();
	  }
	  /**
	   * Set caption display state
	   * @param {Boolean}   [showCaptions=false]
	   */


	  captions(showCaptions) {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.captions(showCaptions);
	  }
	  /**
	   * Unembed the video player
	   * @param {removeContainer}   [removeContainer=false]
	   */


	  unembed(removeContainer = false) {
	    const {
	      bundle,
	      container_,
	      containerClone_
	    } = this;

	    if (!bundle) {
	      return;
	    }

	    bundle.dispose();
	    this.bundle = null;

	    if (container_ && container_.parentNode) {
	      if (removeContainer) {
	        container_.parentNode.removeChild(container_);
	      } else {
	        container_.parentNode.replaceChild(containerClone_, container_);
	      }
	    }
	  }
	  /**
	   * Remove the video player and it's container. This is an alias for DTCIVideoPlayer.unembed(true)
	   */


	  remove() {
	    this.unembed(true);
	  }
	  /**
	   * Display an error message
	   * @param {string|object} error
	   * - an error code (`'AUTHZ_FAILURE'`, etc.) or
	   * - a media error object (`{type: 'NOT_FOUND', message: 'This video is unavailable.'}`)
	   * @param {(string|HTMLElement)}  [content] - optional, showCustomErrorContent on errorDisplay modal
	   */


	  error(err, content) {
	    const {
	      bundle
	    } = this;

	    if (bundle) {
	      bundle.error(err, content);
	    }

	    return this;
	  } // static getBootstrapConfig() {
	  // }


	}

	DTCIVideoPlayer.techLoadedPromise = null;
	DTCIVideoPlayer.loadedPromise = null;
	DTCIVideoPlayer.VERSION = "3.3.40";
	injectPlayerBundleCssIntoDom();

	return DTCIVideoPlayer;

})));
//# sourceMappingURL=espn-web-player-bundle.js.map
